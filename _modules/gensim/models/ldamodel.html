

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>gensim.models.ldamodel</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="" href="../../../index.html"/>
        <link rel="up" title="gensim.models" href="../models.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> NLP APIs
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../gensim_tutorial/tutorial.html">Gensim Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../nltk_intro.html">Natural Language Toolkit</a></li>
</ul>
<p class="caption"><span class="caption-text">Autogenerated API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/nltk.html"><code class="docutils literal"><span class="pre">nltk</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.html"><code class="docutils literal"><span class="pre">gensim</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.interfaces.html"><code class="docutils literal"><span class="pre">gensim.interfaces</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.matutils.html"><code class="docutils literal"><span class="pre">gensim.matutils</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.utils.html"><code class="docutils literal"><span class="pre">gensim.utils</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.corpora.html"><code class="docutils literal"><span class="pre">gensim.corpora</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.models.html"><code class="docutils literal"><span class="pre">gensim.models</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.parsing.html"><code class="docutils literal"><span class="pre">gensim.parsing</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.scripts.html"><code class="docutils literal"><span class="pre">gensim.scripts</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.similarities.html"><code class="docutils literal"><span class="pre">gensim.similarities</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.summarization.html"><code class="docutils literal"><span class="pre">gensim.summarization</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.topic_coherence.html"><code class="docutils literal"><span class="pre">gensim.topic_coherence</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/simserver.html"><code class="docutils literal"><span class="pre">simserver</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/word2vec.html"><code class="docutils literal"><span class="pre">word2vec</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/stop_words.html"><code class="docutils literal"><span class="pre">stop_words</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/nltk.classify.html"><code class="docutils literal"><span class="pre">nltk.classify</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/nltk.cluster.html"><code class="docutils literal"><span class="pre">nltk.cluster</span></code></a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">NLP APIs</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          













<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../gensim.html">gensim</a> &raquo;</li>
        
          <li><a href="../models.html">gensim.models</a> &raquo;</li>
        
      <li>gensim.models.ldamodel</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for gensim.models.ldamodel</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2011 Radim Rehurek &lt;radimrehurek@seznam.cz&gt;</span>
<span class="c1"># Licensed under the GNU LGPL v2.1 - http://www.gnu.org/licenses/lgpl.html</span>
<span class="c1">#</span>
<span class="c1"># Parts of the LDA inference code come from Dr. Hoffman&#39;s `onlineldavb.py` script,</span>
<span class="c1"># (C) 2010  Matthew D. Hoffman, GNU GPL 3.0</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">**For a faster implementation of LDA (parallelized for multicore machines), see** :mod:`gensim.models.ldamulticore`.</span>

<span class="sd">Latent Dirichlet Allocation (LDA) in Python.</span>

<span class="sd">This module allows both LDA model estimation from a training corpus and inference of topic</span>
<span class="sd">distribution on new, unseen documents. The model can also be updated with new documents</span>
<span class="sd">for online training.</span>

<span class="sd">The core estimation code is based on the `onlineldavb.py` script by M. Hoffman [1]_, see</span>
<span class="sd">**Hoffman, Blei, Bach: Online Learning for Latent Dirichlet Allocation, NIPS 2010.**</span>

<span class="sd">The algorithm:</span>

<span class="sd">* is **streamed**: training documents may come in sequentially, no random access required,</span>
<span class="sd">* runs in **constant memory** w.r.t. the number of documents: size of the</span>
<span class="sd">  training corpus does not affect memory footprint, can process corpora larger than RAM, and</span>
<span class="sd">* is **distributed**: makes use of a cluster of machines, if available, to</span>
<span class="sd">  speed up model estimation.</span>

<span class="sd">.. [1] http://www.cs.princeton.edu/~mdhoffma</span>

<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">numpy</span>  <span class="c1"># for arrays, array broadcasting etc.</span>
<span class="kn">import</span> <span class="nn">numbers</span>

<span class="kn">from</span> <span class="nn">gensim</span> <span class="kn">import</span> <span class="n">interfaces</span><span class="p">,</span> <span class="n">utils</span><span class="p">,</span> <span class="n">matutils</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">gammaln</span><span class="p">,</span> <span class="n">psi</span>  <span class="c1"># gamma function utils</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">polygamma</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="kn">import</span> <span class="nb">xrange</span>
<span class="kn">import</span> <span class="nn">six</span>

<span class="c1"># log(sum(exp(x))) that tries to avoid overflow</span>
<span class="k">try</span><span class="p">:</span>
    <span class="c1"># try importing from here if older scipy is installed</span>
    <span class="kn">from</span> <span class="nn">scipy.maxentropy</span> <span class="kn">import</span> <span class="n">logsumexp</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="c1"># maxentropy has been removed in recent releases, logsumexp now in misc</span>
    <span class="kn">from</span> <span class="nn">scipy.misc</span> <span class="kn">import</span> <span class="n">logsumexp</span>


<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;gensim.models.ldamodel&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">dirichlet_expectation</span><span class="p">(</span><span class="n">alpha</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For a vector `theta~Dir(alpha)`, compute `E[log(theta)]`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">alpha</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">psi</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">-</span> <span class="n">psi</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">alpha</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">psi</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">-</span> <span class="n">psi</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="mi">1</span><span class="p">))[:,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">alpha</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>  <span class="c1"># keep the same precision as input</span>


<span class="k">def</span> <span class="nf">update_dir_prior</span><span class="p">(</span><span class="n">prior</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">logphat</span><span class="p">,</span> <span class="n">rho</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Updates a given prior using Newton&#39;s method, described in</span>
<span class="sd">    **Huang: Maximum Likelihood Estimation of Dirichlet Distribution Parameters.**</span>
<span class="sd">    http://jonathan-huang.org/research/dirichlet/dirichlet.pdf</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dprior</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">prior</span><span class="p">)</span>
    <span class="n">gradf</span> <span class="o">=</span> <span class="n">N</span> <span class="o">*</span> <span class="p">(</span><span class="n">psi</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">prior</span><span class="p">))</span> <span class="o">-</span> <span class="n">psi</span><span class="p">(</span><span class="n">prior</span><span class="p">)</span> <span class="o">+</span> <span class="n">logphat</span><span class="p">)</span>

    <span class="n">c</span> <span class="o">=</span> <span class="n">N</span> <span class="o">*</span> <span class="n">polygamma</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">prior</span><span class="p">))</span>
    <span class="n">q</span> <span class="o">=</span> <span class="o">-</span><span class="n">N</span> <span class="o">*</span> <span class="n">polygamma</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">prior</span><span class="p">)</span>

    <span class="n">b</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">gradf</span> <span class="o">/</span> <span class="n">q</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">c</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">q</span><span class="p">))</span>

    <span class="n">dprior</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">gradf</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="n">q</span>

    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">rho</span> <span class="o">*</span> <span class="n">dprior</span> <span class="o">+</span> <span class="n">prior</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">prior</span> <span class="o">+=</span> <span class="n">rho</span> <span class="o">*</span> <span class="n">dprior</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;updated prior not positive&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">prior</span>

<span class="k">def</span> <span class="nf">get_random_state</span><span class="p">(</span><span class="n">seed</span><span class="p">):</span>
     <span class="sd">&quot;&quot;&quot; Turn seed into a np.random.RandomState instance.</span>

<span class="sd">         Method originally from maciejkula/glove-python, and written by @joshloyal</span>
<span class="sd">     &quot;&quot;&quot;</span>
     <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">seed</span> <span class="ow">is</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="p">:</span>
         <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">mtrand</span><span class="o">.</span><span class="n">_rand</span>
     <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="p">(</span><span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
         <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
     <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">seed</span>
     <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%r</span><span class="s1"> cannot be used to seed a numpy.random.RandomState&#39;</span>
                      <span class="s1">&#39; instance&#39;</span> <span class="o">%</span> <span class="n">seed</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">LdaState</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">SaveLoad</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Encapsulate information for distributed computation of LdaModel objects.</span>

<span class="sd">    Objects of this class are sent over the network, so try to keep them lean to</span>
<span class="sd">    reduce traffic.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eta</span> <span class="o">=</span> <span class="n">eta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sstats</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numdocs</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepare the state for a new EM iteration (reset sufficient stats).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sstats</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numdocs</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merge the result of an E step from one node with that of another node</span>
<span class="sd">        (summing up sufficient statistics).</span>

<span class="sd">        The merging is trivial and after merging all cluster nodes, we have the</span>
<span class="sd">        exact same result as if the computation was run on a single node (no</span>
<span class="sd">        approximation).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">other</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sstats</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">sstats</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numdocs</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">numdocs</span>

    <span class="k">def</span> <span class="nf">blend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhot</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">targetsize</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given LdaState `other`, merge it with the current state. Stretch both to</span>
<span class="sd">        `targetsize` documents before merging, so that they are of comparable</span>
<span class="sd">        magnitude.</span>

<span class="sd">        Merging is done by average weighting: in the extremes, `rhot=0.0` means</span>
<span class="sd">        `other` is completely ignored; `rhot=1.0` means `self` is completely ignored.</span>

<span class="sd">        This procedure corresponds to the stochastic gradient update from Hoffman</span>
<span class="sd">        et al., algorithm 2 (eq. 14).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">other</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="n">targetsize</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">targetsize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numdocs</span>

        <span class="c1"># stretch the current model&#39;s expected n*phi counts to target size</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">numdocs</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">targetsize</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">numdocs</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">targetsize</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">numdocs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sstats</span> <span class="o">*=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">rhot</span><span class="p">)</span> <span class="o">*</span> <span class="n">scale</span>

        <span class="c1"># stretch the incoming n*phi counts to target size</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">numdocs</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">targetsize</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">numdocs</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;merging changes from </span><span class="si">%i</span><span class="s2"> documents into a model of </span><span class="si">%i</span><span class="s2"> documents&quot;</span><span class="p">,</span>
                        <span class="n">other</span><span class="o">.</span><span class="n">numdocs</span><span class="p">,</span> <span class="n">targetsize</span><span class="p">)</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">targetsize</span> <span class="o">/</span> <span class="n">other</span><span class="o">.</span><span class="n">numdocs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sstats</span> <span class="o">+=</span> <span class="n">rhot</span> <span class="o">*</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">sstats</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">numdocs</span> <span class="o">=</span> <span class="n">targetsize</span>

    <span class="k">def</span> <span class="nf">blend2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhot</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">targetsize</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Alternative, more simple blend.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">other</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="n">targetsize</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">targetsize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numdocs</span>

        <span class="c1"># merge the two matrices by summing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sstats</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">sstats</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numdocs</span> <span class="o">=</span> <span class="n">targetsize</span>

    <span class="k">def</span> <span class="nf">get_lambda</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sstats</span>

    <span class="k">def</span> <span class="nf">get_Elogbeta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">dirichlet_expectation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_lambda</span><span class="p">())</span>
<span class="c1"># endclass LdaState</span>


<div class="viewcode-block" id="LdaModel"><a class="viewcode-back" href="../../../generated/generated/gensim.models.LdaModel.html#gensim.models.LdaModel">[docs]</a><span class="k">class</span> <span class="nc">LdaModel</span><span class="p">(</span><span class="n">interfaces</span><span class="o">.</span><span class="n">TransformationABC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The constructor estimates Latent Dirichlet Allocation model parameters based</span>
<span class="sd">    on a training corpus:</span>

<span class="sd">    &gt;&gt;&gt; lda = LdaModel(corpus, num_topics=10)</span>

<span class="sd">    You can then infer topic distributions on new, unseen documents, with</span>

<span class="sd">    &gt;&gt;&gt; doc_lda = lda[doc_bow]</span>

<span class="sd">    The model can be updated (trained) with new documents via</span>

<span class="sd">    &gt;&gt;&gt; lda.update(other_corpus)</span>

<span class="sd">    Model persistency is achieved through its `load`/`save` methods.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="LdaModel.__init__"><a class="viewcode-back" href="../../../generated/generated/gensim.models.LdaModel.__init__.html#gensim.models.LdaModel.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">corpus</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">num_topics</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">id2word</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">distributed</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="n">passes</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">update_every</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">alpha</span><span class="o">=</span><span class="s1">&#39;symmetric&#39;</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">decay</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                 <span class="n">eval_every</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">gamma_threshold</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>
                 <span class="n">minimum_probability</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ns_conf</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If given, start training from the iterable `corpus` straight away. If not given,</span>
<span class="sd">        the model is left untrained (presumably because you want to call `update()` manually).</span>

<span class="sd">        `num_topics` is the number of requested latent topics to be extracted from</span>
<span class="sd">        the training corpus.</span>

<span class="sd">        `id2word` is a mapping from word ids (integers) to words (strings). It is</span>
<span class="sd">        used to determine the vocabulary size, as well as for debugging and topic</span>
<span class="sd">        printing.</span>

<span class="sd">        `alpha` and `eta` are hyperparameters that affect sparsity of the document-topic</span>
<span class="sd">        (theta) and topic-word (lambda) distributions. Both default to a symmetric</span>
<span class="sd">        1.0/num_topics prior.</span>

<span class="sd">        `alpha` can be set to an explicit array = prior of your choice. It also</span>
<span class="sd">        support special values of &#39;asymmetric&#39; and &#39;auto&#39;: the former uses a fixed</span>
<span class="sd">        normalized asymmetric 1.0/topicno prior, the latter learns an asymmetric</span>
<span class="sd">        prior directly from your data.</span>

<span class="sd">        `eta` can be a scalar for a symmetric prior over topic/word</span>
<span class="sd">        distributions, or a matrix of shape num_topics x num_words, which can</span>
<span class="sd">        be used to impose asymmetric priors over the word distribution on a</span>
<span class="sd">        per-topic basis. This may be useful if you want to seed certain topics</span>
<span class="sd">        with particular words by boosting the priors for those words.  It also</span>
<span class="sd">        supports the special value &#39;auto&#39;, which learns an asymmetric prior</span>
<span class="sd">        directly from your data.</span>

<span class="sd">        Turn on `distributed` to force distributed computing (see the `web tutorial &lt;http://radimrehurek.com/gensim/distributed.html&gt;`_</span>
<span class="sd">        on how to set up a cluster of machines for gensim).</span>

<span class="sd">        Calculate and log perplexity estimate from the latest mini-batch every</span>
<span class="sd">        `eval_every` model updates (setting this to 1 slows down training ~2x;</span>
<span class="sd">        default is 10 for better performance). Set to None to disable perplexity estimation.</span>

<span class="sd">        `decay` and `offset` parameters are the same as Kappa and Tau_0 in</span>
<span class="sd">        Hoffman et al, respectively.</span>

<span class="sd">        `minimum_probability` controls filtering the topics returned for a document (bow).</span>

<span class="sd">        `random_state` can be a numpy.random.RandomState object or the seed for one</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; lda = LdaModel(corpus, num_topics=100)  # train model</span>
<span class="sd">        &gt;&gt;&gt; print(lda[doc_bow]) # get topic probability distribution for a document</span>
<span class="sd">        &gt;&gt;&gt; lda.update(corpus2) # update the LDA model with additional documents</span>
<span class="sd">        &gt;&gt;&gt; print(lda[doc_bow])</span>

<span class="sd">        &gt;&gt;&gt; lda = LdaModel(corpus, num_topics=50, alpha=&#39;auto&#39;, eval_every=5)  # train asymmetric alpha from data</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># store user-supplied parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id2word</span> <span class="o">=</span> <span class="n">id2word</span>
        <span class="k">if</span> <span class="n">corpus</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">id2word</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;at least one of corpus/id2word must be specified, to establish input space dimensionality&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">id2word</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;no word id mapping provided; initializing from corpus, assuming identity&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">id2word</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">dict_from_corpus</span><span class="p">(</span><span class="n">corpus</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_terms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id2word</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id2word</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_terms</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id2word</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_terms</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_terms</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot compute LDA over an empty collection (no terms)&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">distributed</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">distributed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_topics</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">num_topics</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chunksize</span> <span class="o">=</span> <span class="n">chunksize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decay</span> <span class="o">=</span> <span class="n">decay</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minimum_probability</span> <span class="o">=</span> <span class="n">minimum_probability</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_updates</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">passes</span> <span class="o">=</span> <span class="n">passes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_every</span> <span class="o">=</span> <span class="n">update_every</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eval_every</span> <span class="o">=</span> <span class="n">eval_every</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimize_alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_dir_prior</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="s1">&#39;alpha&#39;</span><span class="p">)</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_topics</span><span class="p">,),</span> <span class="s2">&quot;Invalid alpha shape. Got shape </span><span class="si">%s</span><span class="s2">, but expected (</span><span class="si">%d</span><span class="s2">, )&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_topics</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimize_eta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_dir_prior</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span> <span class="s1">&#39;eta&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">get_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>

        <span class="k">assert</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_topics</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_topics</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_terms</span><span class="p">)),</span> <span class="p">(</span>
            <span class="s2">&quot;Invalid eta shape. Got shape </span><span class="si">%s</span><span class="s2">, but expected (</span><span class="si">%d</span><span class="s2">, 1) or (</span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span>
            <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_topics</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_topics</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_terms</span><span class="p">))</span>

        <span class="c1"># VB constants</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iterations</span> <span class="o">=</span> <span class="n">iterations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gamma_threshold</span> <span class="o">=</span> <span class="n">gamma_threshold</span>

        <span class="c1"># set up distributed environment if necessary</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">distributed</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;using serial LDA version on this node&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dispatcher</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">numworkers</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimize_alpha</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;auto-optimizing alpha not implemented in distributed LDA&quot;</span><span class="p">)</span>
            <span class="c1"># set up distributed version</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="kn">import</span> <span class="nn">Pyro4</span>
                <span class="k">with</span> <span class="n">utils</span><span class="o">.</span><span class="n">getNS</span><span class="p">(</span><span class="o">**</span><span class="n">ns_conf</span><span class="p">)</span> <span class="k">as</span> <span class="n">ns</span><span class="p">:</span>
                    <span class="kn">from</span> <span class="nn">gensim.models.lda_dispatcher</span> <span class="kn">import</span> <span class="n">LDA_DISPATCHER_PREFIX</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dispatcher</span> <span class="o">=</span> <span class="n">Pyro4</span><span class="o">.</span><span class="n">Proxy</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">list</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="n">LDA_DISPATCHER_PREFIX</span><span class="p">)[</span><span class="n">LDA_DISPATCHER_PREFIX</span><span class="p">])</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;looking for dispatcher at </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dispatcher</span><span class="o">.</span><span class="n">_pyroUri</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dispatcher</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">id2word</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id2word</span><span class="p">,</span> <span class="n">num_topics</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_topics</span><span class="p">,</span>
                                               <span class="n">chunksize</span><span class="o">=</span><span class="n">chunksize</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span><span class="n">eta</span><span class="p">,</span> <span class="n">distributed</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">numworkers</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dispatcher</span><span class="o">.</span><span class="n">getworkers</span><span class="p">())</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;using distributed version with </span><span class="si">%i</span><span class="s2"> workers&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">numworkers</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;failed to initialize distributed LDA (</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;failed to initialize distributed LDA (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="n">err</span><span class="p">)</span>

        <span class="c1"># Initialize the variational distribution q(beta|lambda)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">LdaState</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_topics</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_terms</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">sstats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="mf">100.</span><span class="p">,</span> <span class="mf">1.</span> <span class="o">/</span> <span class="mf">100.</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_topics</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_terms</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expElogbeta</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">dirichlet_expectation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">sstats</span><span class="p">))</span>

        <span class="c1"># if a training corpus was provided, start estimating the model right away</span>
        <span class="k">if</span> <span class="n">corpus</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">use_numpy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispatcher</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">corpus</span><span class="p">,</span> <span class="n">chunks_as_numpy</span><span class="o">=</span><span class="n">use_numpy</span><span class="p">)</span></div>

<div class="viewcode-block" id="LdaModel.init_dir_prior"><a class="viewcode-back" href="../../../generated/generated/gensim.models.LdaModel.init_dir_prior.html#gensim.models.LdaModel.init_dir_prior">[docs]</a>    <span class="k">def</span> <span class="nf">init_dir_prior</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prior</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">prior</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">prior</span> <span class="o">=</span> <span class="s1">&#39;symmetric&#39;</span>

        <span class="n">is_auto</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prior</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">prior</span> <span class="o">==</span> <span class="s1">&#39;symmetric&#39;</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;using symmetric </span><span class="si">%s</span><span class="s2"> at </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_topics</span><span class="p">)</span>
                <span class="n">init_prior</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_topics</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_topics</span><span class="p">)])</span>
            <span class="k">elif</span> <span class="n">prior</span> <span class="o">==</span> <span class="s1">&#39;asymmetric&#39;</span><span class="p">:</span>
                <span class="n">init_prior</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_topics</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_topics</span><span class="p">)])</span>
                <span class="n">init_prior</span> <span class="o">/=</span> <span class="n">init_prior</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;using asymmetric </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">init_prior</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">prior</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
                <span class="n">is_auto</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">init_prior</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_topics</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_topics</span><span class="p">)])</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;using autotuned </span><span class="si">%s</span><span class="s2">, starting with </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">init_prior</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unable to determine proper </span><span class="si">%s</span><span class="s2"> value given &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">prior</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prior</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">init_prior</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">prior</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prior</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">init_prior</span> <span class="o">=</span> <span class="n">prior</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prior</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">number</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prior</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">):</span>
            <span class="n">init_prior</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">prior</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_topics</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> must be either a numpy array of scalars, list of scalars, or scalar&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;eta&#39;</span><span class="p">:</span>
            <span class="c1"># please note the difference in shapes between alpha and eta:</span>
            <span class="c1"># alpha is a row: [0.1, 0.1]</span>
            <span class="c1"># eta is a column: [[0.1],</span>
            <span class="c1">#                   [0.1]]</span>
            <span class="k">if</span> <span class="n">init_prior</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_topics</span><span class="p">,)</span> <span class="ow">or</span> <span class="n">init_prior</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_topics</span><span class="p">):</span>
                <span class="n">init_prior</span> <span class="o">=</span> <span class="n">init_prior</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_topics</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>  <span class="c1"># this statement throws ValueError if eta did not match self.num_topics</span>

        <span class="k">return</span> <span class="n">init_prior</span><span class="p">,</span> <span class="n">is_auto</span></div>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;LdaModel(num_terms=</span><span class="si">%s</span><span class="s2">, num_topics=</span><span class="si">%s</span><span class="s2">, decay=</span><span class="si">%s</span><span class="s2">, chunksize=</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> \
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_terms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_topics</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">decay</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunksize</span><span class="p">)</span>

<div class="viewcode-block" id="LdaModel.sync_state"><a class="viewcode-back" href="../../../generated/generated/gensim.models.LdaModel.sync_state.html#gensim.models.LdaModel.sync_state">[docs]</a>    <span class="k">def</span> <span class="nf">sync_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expElogbeta</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">get_Elogbeta</span><span class="p">())</span></div>

<div class="viewcode-block" id="LdaModel.clear"><a class="viewcode-back" href="../../../generated/generated/gensim.models.LdaModel.clear.html#gensim.models.LdaModel.clear">[docs]</a>    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clear model state (free up some memory). Used in the distributed algo.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Elogbeta</span> <span class="o">=</span> <span class="bp">None</span></div>

<div class="viewcode-block" id="LdaModel.inference"><a class="viewcode-back" href="../../../generated/generated/gensim.models.LdaModel.inference.html#gensim.models.LdaModel.inference">[docs]</a>    <span class="k">def</span> <span class="nf">inference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">collect_sstats</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a chunk of sparse document vectors, estimate gamma (parameters</span>
<span class="sd">        controlling the topic weights) for each document in the chunk.</span>

<span class="sd">        This function does not modify the model (=is read-only aka const). The</span>
<span class="sd">        whole input chunk of document is assumed to fit in RAM; chunking of a</span>
<span class="sd">        large corpus must be done earlier in the pipeline.</span>

<span class="sd">        If `collect_sstats` is True, also collect sufficient statistics needed</span>
<span class="sd">        to update the model&#39;s topic-word distributions, and return a 2-tuple</span>
<span class="sd">        `(gamma, sstats)`. Otherwise, return `(gamma, None)`. `gamma` is of shape</span>
<span class="sd">        `len(chunk) x self.num_topics`.</span>

<span class="sd">        Avoids computing the `phi` variational parameter directly using the</span>
<span class="sd">        optimization presented in **Lee, Seung: Algorithms for non-negative matrix factorization, NIPS 2001**.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="c1"># convert iterators/generators to plain list, so we have len() etc.</span>
            <span class="n">chunk</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;performing inference on a chunk of </span><span class="si">%i</span><span class="s2"> documents&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk</span><span class="p">))</span>

        <span class="c1"># Initialize the variational distribution q(theta|gamma) for the chunk</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="mf">100.</span><span class="p">,</span> <span class="mf">1.</span> <span class="o">/</span> <span class="mf">100.</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chunk</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_topics</span><span class="p">))</span>
        <span class="n">Elogtheta</span> <span class="o">=</span> <span class="n">dirichlet_expectation</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
        <span class="n">expElogtheta</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">Elogtheta</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">collect_sstats</span><span class="p">:</span>
            <span class="n">sstats</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expElogbeta</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sstats</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">converged</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Now, for each document d update that document&#39;s gamma and phi</span>
        <span class="c1"># Inference code copied from Hoffman&#39;s `onlineldavb.py` (esp. the</span>
        <span class="c1"># Lee&amp;Seung trick which speeds things up by an order of magnitude, compared</span>
        <span class="c1"># to Blei&#39;s original LDA-C code, cool!).</span>
        <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">doc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">chunk</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">doc</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">doc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">six</span><span class="o">.</span><span class="n">integer_types</span><span class="p">):</span>
                <span class="c1"># make sure the term IDs are ints, otherwise numpy will get upset</span>
                <span class="n">ids</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span> <span class="k">for</span> <span class="nb">id</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ids</span> <span class="o">=</span> <span class="p">[</span><span class="nb">id</span> <span class="k">for</span> <span class="nb">id</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">]</span>
            <span class="n">cts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cnt</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">cnt</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">])</span>
            <span class="n">gammad</span> <span class="o">=</span> <span class="n">gamma</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">Elogthetad</span> <span class="o">=</span> <span class="n">Elogtheta</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">expElogthetad</span> <span class="o">=</span> <span class="n">expElogtheta</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">expElogbetad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expElogbeta</span><span class="p">[:,</span> <span class="n">ids</span><span class="p">]</span>

            <span class="c1"># The optimal phi_{dwk} is proportional to expElogthetad_k * expElogbetad_w.</span>
            <span class="c1"># phinorm is the normalizer.</span>
            <span class="c1"># TODO treat zeros explicitly, instead of adding 1e-100?</span>
            <span class="n">phinorm</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">expElogthetad</span><span class="p">,</span> <span class="n">expElogbetad</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-100</span>

            <span class="c1"># Iterate between gamma and phi until convergence</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iterations</span><span class="p">):</span>
                <span class="n">lastgamma</span> <span class="o">=</span> <span class="n">gammad</span>
                <span class="c1"># We represent phi implicitly to save memory and time.</span>
                <span class="c1"># Substituting the value of the optimal phi back into</span>
                <span class="c1"># the update for gamma gives this update. Cf. Lee&amp;Seung 2001.</span>
                <span class="n">gammad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">expElogthetad</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">cts</span> <span class="o">/</span> <span class="n">phinorm</span><span class="p">,</span> <span class="n">expElogbetad</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                <span class="n">Elogthetad</span> <span class="o">=</span> <span class="n">dirichlet_expectation</span><span class="p">(</span><span class="n">gammad</span><span class="p">)</span>
                <span class="n">expElogthetad</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">Elogthetad</span><span class="p">)</span>
                <span class="n">phinorm</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">expElogthetad</span><span class="p">,</span> <span class="n">expElogbetad</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-100</span>
                <span class="c1"># If gamma hasn&#39;t changed much, we&#39;re done.</span>
                <span class="n">meanchange</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">gammad</span> <span class="o">-</span> <span class="n">lastgamma</span><span class="p">))</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">meanchange</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma_threshold</span><span class="p">):</span>
                    <span class="n">converged</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">break</span>
            <span class="n">gamma</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">gammad</span>
            <span class="k">if</span> <span class="n">collect_sstats</span><span class="p">:</span>
                <span class="c1"># Contribution of document d to the expected sufficient</span>
                <span class="c1"># statistics for the M step.</span>
                <span class="n">sstats</span><span class="p">[:,</span> <span class="n">ids</span><span class="p">]</span> <span class="o">+=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">expElogthetad</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">cts</span> <span class="o">/</span> <span class="n">phinorm</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%i</span><span class="s2">/</span><span class="si">%i</span><span class="s2"> documents converged within </span><span class="si">%i</span><span class="s2"> iterations&quot;</span><span class="p">,</span>
                         <span class="n">converged</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterations</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">collect_sstats</span><span class="p">:</span>
            <span class="c1"># This step finishes computing the sufficient statistics for the</span>
            <span class="c1"># M step, so that</span>
            <span class="c1"># sstats[k, w] = \sum_d n_{dw} * phi_{dwk}</span>
            <span class="c1"># = \sum_d n_{dw} * exp{Elogtheta_{dk} + Elogbeta_{kw}} / phinorm_{dw}.</span>
            <span class="n">sstats</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expElogbeta</span>
        <span class="k">return</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">sstats</span></div>

<div class="viewcode-block" id="LdaModel.do_estep"><a class="viewcode-back" href="../../../generated/generated/gensim.models.LdaModel.do_estep.html#gensim.models.LdaModel.do_estep">[docs]</a>    <span class="k">def</span> <span class="nf">do_estep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform inference on a chunk of documents, and accumulate the collected</span>
<span class="sd">        sufficient statistics in `state` (or `self.state` if None).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">state</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span>
        <span class="n">gamma</span><span class="p">,</span> <span class="n">sstats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inference</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">collect_sstats</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">state</span><span class="o">.</span><span class="n">sstats</span> <span class="o">+=</span> <span class="n">sstats</span>
        <span class="n">state</span><span class="o">.</span><span class="n">numdocs</span> <span class="o">+=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># avoids calling len(chunk) on a generator</span>
        <span class="k">return</span> <span class="n">gamma</span></div>

<div class="viewcode-block" id="LdaModel.update_alpha"><a class="viewcode-back" href="../../../generated/generated/gensim.models.LdaModel.update_alpha.html#gensim.models.LdaModel.update_alpha">[docs]</a>    <span class="k">def</span> <span class="nf">update_alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gammat</span><span class="p">,</span> <span class="n">rho</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update parameters for the Dirichlet prior on the per-document</span>
<span class="sd">        topic weights `alpha` given the last `gammat`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gammat</span><span class="p">))</span>
        <span class="n">logphat</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dirichlet_expectation</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span> <span class="k">for</span> <span class="n">gamma</span> <span class="ow">in</span> <span class="n">gammat</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">update_dir_prior</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">logphat</span><span class="p">,</span> <span class="n">rho</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;optimized alpha </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span></div>

<div class="viewcode-block" id="LdaModel.update_eta"><a class="viewcode-back" href="../../../generated/generated/gensim.models.LdaModel.update_eta.html#gensim.models.LdaModel.update_eta">[docs]</a>    <span class="k">def</span> <span class="nf">update_eta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lambdat</span><span class="p">,</span> <span class="n">rho</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update parameters for the Dirichlet prior on the per-topic</span>
<span class="sd">        word weights `eta` given the last `lambdat`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t use update_eta with eta matrices, only column vectors.&quot;</span><span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">lambdat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">logphat</span> <span class="o">=</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">dirichlet_expectation</span><span class="p">(</span><span class="n">lambda_</span><span class="p">)</span> <span class="k">for</span> <span class="n">lambda_</span> <span class="ow">in</span> <span class="n">lambdat</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_topics</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">eta</span> <span class="o">=</span> <span class="n">update_dir_prior</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">logphat</span><span class="p">,</span> <span class="n">rho</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;optimized eta </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_topics</span><span class="p">))))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span></div>

<div class="viewcode-block" id="LdaModel.log_perplexity"><a class="viewcode-back" href="../../../generated/generated/gensim.models.LdaModel.log_perplexity.html#gensim.models.LdaModel.log_perplexity">[docs]</a>    <span class="k">def</span> <span class="nf">log_perplexity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">total_docs</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate and return per-word likelihood bound, using the `chunk` of</span>
<span class="sd">        documents as evaluation corpus. Also output the calculated statistics. incl.</span>
<span class="sd">        perplexity=2^(-bound), to log at INFO level.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">total_docs</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">total_docs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
        <span class="n">corpus_words</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">cnt</span> <span class="k">for</span> <span class="n">document</span> <span class="ow">in</span> <span class="n">chunk</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">cnt</span> <span class="ow">in</span> <span class="n">document</span><span class="p">)</span>
        <span class="n">subsample_ratio</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">total_docs</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
        <span class="n">perwordbound</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bound</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">subsample_ratio</span><span class="o">=</span><span class="n">subsample_ratio</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">subsample_ratio</span> <span class="o">*</span> <span class="n">corpus_words</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%.3f</span><span class="s2"> per-word bound, </span><span class="si">%.1f</span><span class="s2"> perplexity estimate based on a held-out corpus of </span><span class="si">%i</span><span class="s2"> documents with </span><span class="si">%i</span><span class="s2"> words&quot;</span> <span class="o">%</span>
                    <span class="p">(</span><span class="n">perwordbound</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp2</span><span class="p">(</span><span class="o">-</span><span class="n">perwordbound</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk</span><span class="p">),</span> <span class="n">corpus_words</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">perwordbound</span></div>

<div class="viewcode-block" id="LdaModel.update"><a class="viewcode-back" href="../../../generated/generated/gensim.models.LdaModel.update.html#gensim.models.LdaModel.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">corpus</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">decay</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
               <span class="n">passes</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">update_every</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">eval_every</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
               <span class="n">gamma_threshold</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">chunks_as_numpy</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Train the model with new documents, by EM-iterating over `corpus` until</span>
<span class="sd">        the topics converge (or until the maximum number of allowed iterations</span>
<span class="sd">        is reached). `corpus` must be an iterable (repeatable stream of documents),</span>

<span class="sd">        In distributed mode, the E step is distributed over a cluster of machines.</span>

<span class="sd">        This update also supports updating an already trained model (`self`)</span>
<span class="sd">        with new documents from `corpus`; the two models are then merged in</span>
<span class="sd">        proportion to the number of old vs. new documents. This feature is still</span>
<span class="sd">        experimental for non-stationary input streams.</span>

<span class="sd">        For stationary input (no topic drift in new documents), on the other hand,</span>
<span class="sd">        this equals the online update of Hoffman et al. and is guaranteed to</span>
<span class="sd">        converge for any `decay` in (0.5, 1.0&gt;. Additionally, for smaller</span>
<span class="sd">        `corpus` sizes, an increasing `offset` may be beneficial (see</span>
<span class="sd">        Table 1 in Hoffman et al.)</span>

<span class="sd">        Args:</span>
<span class="sd">            corpus (gensim corpus): The corpus with which the LDA model should be updated.</span>

<span class="sd">            chunks_as_numpy (bool): Whether each chunk passed to `.inference` should be a numpy</span>
<span class="sd">                array of not. Numpy can in some settings turn the term IDs</span>
<span class="sd">                into floats, these will be converted back into integers in</span>
<span class="sd">                inference, which incurs a performance hit. For distributed</span>
<span class="sd">                computing it may be desirable to keep the chunks as numpy</span>
<span class="sd">                arrays.</span>

<span class="sd">        For other parameter settings, see :class:`LdaModel` constructor.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># use parameters given in constructor, unless user explicitly overrode them</span>
        <span class="k">if</span> <span class="n">decay</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">decay</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decay</span>
        <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span>
        <span class="k">if</span> <span class="n">passes</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">passes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">passes</span>
        <span class="k">if</span> <span class="n">update_every</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">update_every</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_every</span>
        <span class="k">if</span> <span class="n">eval_every</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">eval_every</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval_every</span>
        <span class="k">if</span> <span class="n">iterations</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">iterations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterations</span>
        <span class="k">if</span> <span class="n">gamma_threshold</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">gamma_threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma_threshold</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">lencorpus</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">corpus</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;input corpus stream has no len(); counting documents&quot;</span><span class="p">)</span>
            <span class="n">lencorpus</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">corpus</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lencorpus</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;LdaModel.update() called with an empty corpus&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">chunksize</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">chunksize</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">lencorpus</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunksize</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">numdocs</span> <span class="o">+=</span> <span class="n">lencorpus</span>

        <span class="k">if</span> <span class="n">update_every</span><span class="p">:</span>
            <span class="n">updatetype</span> <span class="o">=</span> <span class="s2">&quot;online&quot;</span>
            <span class="n">updateafter</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">lencorpus</span><span class="p">,</span> <span class="n">update_every</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">numworkers</span> <span class="o">*</span> <span class="n">chunksize</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">updatetype</span> <span class="o">=</span> <span class="s2">&quot;batch&quot;</span>
            <span class="n">updateafter</span> <span class="o">=</span> <span class="n">lencorpus</span>
        <span class="n">evalafter</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">lencorpus</span><span class="p">,</span> <span class="p">(</span><span class="n">eval_every</span> <span class="ow">or</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">numworkers</span> <span class="o">*</span> <span class="n">chunksize</span><span class="p">)</span>

        <span class="n">updates_per_pass</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">lencorpus</span> <span class="o">/</span> <span class="n">updateafter</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;running </span><span class="si">%s</span><span class="s2"> LDA training, </span><span class="si">%s</span><span class="s2"> topics, </span><span class="si">%i</span><span class="s2"> passes over &quot;</span>
                    <span class="s2">&quot;the supplied corpus of </span><span class="si">%i</span><span class="s2"> documents, updating model once &quot;</span>
                    <span class="s2">&quot;every </span><span class="si">%i</span><span class="s2"> documents, evaluating perplexity every </span><span class="si">%i</span><span class="s2"> documents, &quot;</span>
                    <span class="s2">&quot;iterating </span><span class="si">%i</span><span class="s2">x with a convergence threshold of </span><span class="si">%f</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">updatetype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_topics</span><span class="p">,</span> <span class="n">passes</span><span class="p">,</span> <span class="n">lencorpus</span><span class="p">,</span>
                        <span class="n">updateafter</span><span class="p">,</span> <span class="n">evalafter</span><span class="p">,</span> <span class="n">iterations</span><span class="p">,</span>
                        <span class="n">gamma_threshold</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">updates_per_pass</span> <span class="o">*</span> <span class="n">passes</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;too few updates, training might not converge; consider &quot;</span>
                           <span class="s2">&quot;increasing the number of passes or iterations to improve accuracy&quot;</span><span class="p">)</span>

        <span class="c1"># rho is the &quot;speed&quot; of updating; TODO try other fncs</span>
        <span class="c1"># pass_ + num_updates handles increasing the starting t for each pass,</span>
        <span class="c1"># while allowing it to &quot;reset&quot; on the first pass of each update</span>
        <span class="k">def</span> <span class="nf">rho</span><span class="p">():</span>
            <span class="k">return</span> <span class="nb">pow</span><span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">pass_</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_updates</span> <span class="o">/</span> <span class="n">chunksize</span><span class="p">),</span> <span class="o">-</span><span class="n">decay</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">pass_</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">passes</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispatcher</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;initializing </span><span class="si">%s</span><span class="s1"> workers&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">numworkers</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dispatcher</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">other</span> <span class="o">=</span> <span class="n">LdaState</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">sstats</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">dirty</span> <span class="o">=</span> <span class="bp">False</span>

            <span class="n">reallen</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">chunk_no</span><span class="p">,</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">grouper</span><span class="p">(</span><span class="n">corpus</span><span class="p">,</span> <span class="n">chunksize</span><span class="p">,</span> <span class="n">as_numpy</span><span class="o">=</span><span class="n">chunks_as_numpy</span><span class="p">)):</span>
                <span class="n">reallen</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>  <span class="c1"># keep track of how many documents we&#39;ve processed so far</span>

                <span class="k">if</span> <span class="n">eval_every</span> <span class="ow">and</span> <span class="p">((</span><span class="n">reallen</span> <span class="o">==</span> <span class="n">lencorpus</span><span class="p">)</span> <span class="ow">or</span> <span class="p">((</span><span class="n">chunk_no</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">eval_every</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">numworkers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log_perplexity</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">total_docs</span><span class="o">=</span><span class="n">lencorpus</span><span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispatcher</span><span class="p">:</span>
                    <span class="c1"># add the chunk to dispatcher&#39;s job queue, so workers can munch on it</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;PROGRESS: pass </span><span class="si">%i</span><span class="s1">, dispatching documents up to #</span><span class="si">%i</span><span class="s1">/</span><span class="si">%i</span><span class="s1">&#39;</span><span class="p">,</span>
                                <span class="n">pass_</span><span class="p">,</span> <span class="n">chunk_no</span> <span class="o">*</span> <span class="n">chunksize</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk</span><span class="p">),</span> <span class="n">lencorpus</span><span class="p">)</span>
                    <span class="c1"># this will eventually block until some jobs finish, because the queue has a small finite length</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dispatcher</span><span class="o">.</span><span class="n">putjob</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;PROGRESS: pass </span><span class="si">%i</span><span class="s1">, at document #</span><span class="si">%i</span><span class="s1">/</span><span class="si">%i</span><span class="s1">&#39;</span><span class="p">,</span>
                                <span class="n">pass_</span><span class="p">,</span> <span class="n">chunk_no</span> <span class="o">*</span> <span class="n">chunksize</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk</span><span class="p">),</span> <span class="n">lencorpus</span><span class="p">)</span>
                    <span class="n">gammat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_estep</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimize_alpha</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">update_alpha</span><span class="p">(</span><span class="n">gammat</span><span class="p">,</span> <span class="n">rho</span><span class="p">())</span>

                <span class="n">dirty</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">del</span> <span class="n">chunk</span>

                <span class="c1"># perform an M step. determine when based on update_every, don&#39;t do this after every chunk</span>
                <span class="k">if</span> <span class="n">update_every</span> <span class="ow">and</span> <span class="p">(</span><span class="n">chunk_no</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">update_every</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">numworkers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispatcher</span><span class="p">:</span>
                        <span class="c1"># distributed mode: wait for all workers to finish</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;reached the end of input; now waiting for all remaining jobs to finish&quot;</span><span class="p">)</span>
                        <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispatcher</span><span class="o">.</span><span class="n">getstate</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">do_mstep</span><span class="p">(</span><span class="n">rho</span><span class="p">(),</span> <span class="n">other</span><span class="p">,</span> <span class="n">pass_</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="k">del</span> <span class="n">other</span>  <span class="c1"># frees up memory</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispatcher</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;initializing workers&#39;</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">dispatcher</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">other</span> <span class="o">=</span> <span class="n">LdaState</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">sstats</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="n">dirty</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="c1"># endfor single corpus iteration</span>
            <span class="k">if</span> <span class="n">reallen</span> <span class="o">!=</span> <span class="n">lencorpus</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;input corpus size changed during training (don&#39;t use generators as input)&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">dirty</span><span class="p">:</span>
                <span class="c1"># finish any remaining updates</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispatcher</span><span class="p">:</span>
                    <span class="c1"># distributed mode: wait for all workers to finish</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;reached the end of input; now waiting for all remaining jobs to finish&quot;</span><span class="p">)</span>
                    <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispatcher</span><span class="o">.</span><span class="n">getstate</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">do_mstep</span><span class="p">(</span><span class="n">rho</span><span class="p">(),</span> <span class="n">other</span><span class="p">,</span> <span class="n">pass_</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">other</span>
                <span class="n">dirty</span> <span class="o">=</span> <span class="bp">False</span></div>
        <span class="c1"># endfor entire corpus update</span>

<div class="viewcode-block" id="LdaModel.do_mstep"><a class="viewcode-back" href="../../../generated/generated/gensim.models.LdaModel.do_mstep.html#gensim.models.LdaModel.do_mstep">[docs]</a>    <span class="k">def</span> <span class="nf">do_mstep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">extra_pass</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        M step: use linear interpolation between the existing topics and</span>
<span class="sd">        collected sufficient statistics in `other` to update the topics.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;updating topics&quot;</span><span class="p">)</span>
        <span class="c1"># update self with the new blend; also keep track of how much did</span>
        <span class="c1"># the topics change through this update, to assess convergence</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expElogbeta</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">blend</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="n">diff</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">get_Elogbeta</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sync_state</span><span class="p">()</span>

        <span class="c1"># print out some debug info at the end of each EM iteration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print_topics</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;topic diff=</span><span class="si">%f</span><span class="s2">, rho=</span><span class="si">%f</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diff</span><span class="p">)),</span> <span class="n">rho</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimize_eta</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_eta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">get_lambda</span><span class="p">(),</span> <span class="n">rho</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">extra_pass</span><span class="p">:</span>
            <span class="c1"># only update if this isn&#39;t an additional pass</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_updates</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">numdocs</span></div>

<div class="viewcode-block" id="LdaModel.bound"><a class="viewcode-back" href="../../../generated/generated/gensim.models.LdaModel.bound.html#gensim.models.LdaModel.bound">[docs]</a>    <span class="k">def</span> <span class="nf">bound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">corpus</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">subsample_ratio</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate the variational bound of documents from `corpus`:</span>
<span class="sd">        E_q[log p(corpus)] - E_q[log q(corpus)]</span>

<span class="sd">        `gamma` are the variational parameters on topic weights for each `corpus`</span>
<span class="sd">        document (=2d matrix=what comes out of `inference()`).</span>
<span class="sd">        If not supplied, will be inferred from the model.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">score</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">_lambda</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">get_lambda</span><span class="p">()</span>
        <span class="n">Elogbeta</span> <span class="o">=</span> <span class="n">dirichlet_expectation</span><span class="p">(</span><span class="n">_lambda</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">doc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">corpus</span><span class="p">):</span>  <span class="c1"># stream the input doc-by-doc, in case it&#39;s too large to fit in RAM</span>
            <span class="k">if</span> <span class="n">d</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunksize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;bound: at document #</span><span class="si">%i</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">gamma</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">gammad</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inference</span><span class="p">([</span><span class="n">doc</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gammad</span> <span class="o">=</span> <span class="n">gamma</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>
            <span class="n">Elogthetad</span> <span class="o">=</span> <span class="n">dirichlet_expectation</span><span class="p">(</span><span class="n">gammad</span><span class="p">)</span>

            <span class="c1"># E[log p(doc | theta, beta)]</span>
            <span class="n">score</span> <span class="o">+=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cnt</span> <span class="o">*</span> <span class="n">logsumexp</span><span class="p">(</span><span class="n">Elogthetad</span> <span class="o">+</span> <span class="n">Elogbeta</span><span class="p">[:,</span> <span class="nb">id</span><span class="p">])</span> <span class="k">for</span> <span class="nb">id</span><span class="p">,</span> <span class="n">cnt</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">)</span>

            <span class="c1"># E[log p(theta | alpha) - log q(theta | gamma)]; assumes alpha is a vector</span>
            <span class="n">score</span> <span class="o">+=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">-</span> <span class="n">gammad</span><span class="p">)</span> <span class="o">*</span> <span class="n">Elogthetad</span><span class="p">)</span>
            <span class="n">score</span> <span class="o">+=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">gammaln</span><span class="p">(</span><span class="n">gammad</span><span class="p">)</span> <span class="o">-</span> <span class="n">gammaln</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">))</span>
            <span class="n">score</span> <span class="o">+=</span> <span class="n">gammaln</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">))</span> <span class="o">-</span> <span class="n">gammaln</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">gammad</span><span class="p">))</span>

        <span class="c1"># compensate likelihood for when `corpus` above is only a sample of the whole corpus</span>
        <span class="n">score</span> <span class="o">*=</span> <span class="n">subsample_ratio</span>

        <span class="c1"># E[log p(beta | eta) - log q (beta | lambda)]; assumes eta is a scalar</span>
        <span class="n">score</span> <span class="o">+=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">eta</span> <span class="o">-</span> <span class="n">_lambda</span><span class="p">)</span> <span class="o">*</span> <span class="n">Elogbeta</span><span class="p">)</span>
        <span class="n">score</span> <span class="o">+=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">gammaln</span><span class="p">(</span><span class="n">_lambda</span><span class="p">)</span> <span class="o">-</span> <span class="n">gammaln</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sum_eta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_terms</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sum_eta</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">score</span> <span class="o">+=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">gammaln</span><span class="p">(</span><span class="n">sum_eta</span><span class="p">)</span> <span class="o">-</span> <span class="n">gammaln</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">_lambda</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">score</span></div>

<div class="viewcode-block" id="LdaModel.print_topics"><a class="viewcode-back" href="../../../generated/generated/gensim.models.LdaModel.print_topics.html#gensim.models.LdaModel.print_topics">[docs]</a>    <span class="k">def</span> <span class="nf">print_topics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_topics</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">num_words</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">show_topics</span><span class="p">(</span><span class="n">num_topics</span><span class="p">,</span> <span class="n">num_words</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="LdaModel.show_topics"><a class="viewcode-back" href="../../../generated/generated/gensim.models.LdaModel.show_topics.html#gensim.models.LdaModel.show_topics">[docs]</a>    <span class="k">def</span> <span class="nf">show_topics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_topics</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">num_words</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">formatted</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For `num_topics` number of topics, return `num_words` most significant words</span>
<span class="sd">        (10 words per topic, by default).</span>

<span class="sd">        The topics are returned as a list -- a list of strings if `formatted` is</span>
<span class="sd">        True, or a list of `(word, probability)` 2-tuples if False.</span>

<span class="sd">        If `log` is True, also output this result to log.</span>

<span class="sd">        Unlike LSA, there is no natural ordering between the topics in LDA.</span>
<span class="sd">        The returned `num_topics &lt;= self.num_topics` subset of all topics is therefore</span>
<span class="sd">        arbitrary and may change between two LDA training runs.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">num_topics</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">num_topics</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_topics</span><span class="p">:</span>
            <span class="n">num_topics</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_topics</span>
            <span class="n">chosen_topics</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_topics</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_topics</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">num_topics</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_topics</span><span class="p">)</span>

            <span class="c1"># add a little random jitter, to randomize results around the same alpha</span>
            <span class="n">sort_alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">+</span> <span class="mf">0.0001</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">))</span>

            <span class="n">sorted_topics</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">matutils</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">sort_alpha</span><span class="p">))</span>
            <span class="n">chosen_topics</span> <span class="o">=</span> <span class="n">sorted_topics</span><span class="p">[:</span><span class="n">num_topics</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">sorted_topics</span><span class="p">[</span><span class="o">-</span><span class="n">num_topics</span> <span class="o">//</span> <span class="mi">2</span><span class="p">:]</span>

        <span class="n">shown</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">chosen_topics</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">formatted</span><span class="p">:</span>
                <span class="n">topic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_topic</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">topn</span><span class="o">=</span><span class="n">num_words</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">topic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">show_topic</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">topn</span><span class="o">=</span><span class="n">num_words</span><span class="p">)</span>

            <span class="n">shown</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">topic</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;topic #</span><span class="si">%i</span><span class="s2"> (</span><span class="si">%.3f</span><span class="s2">): </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">topic</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">shown</span></div>

<div class="viewcode-block" id="LdaModel.show_topic"><a class="viewcode-back" href="../../../generated/generated/gensim.models.LdaModel.show_topic.html#gensim.models.LdaModel.show_topic">[docs]</a>    <span class="k">def</span> <span class="nf">show_topic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">topicid</span><span class="p">,</span> <span class="n">topn</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of `(word, probability)` 2-tuples for the most probable</span>
<span class="sd">        words in topic `topicid`.</span>

<span class="sd">        Only return 2-tuples for the topn most probable words (ignore the rest).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">id2word</span><span class="p">[</span><span class="nb">id</span><span class="p">],</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="nb">id</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_topic_terms</span><span class="p">(</span><span class="n">topicid</span><span class="p">,</span> <span class="n">topn</span><span class="p">)]</span></div>

<div class="viewcode-block" id="LdaModel.get_topic_terms"><a class="viewcode-back" href="../../../generated/generated/gensim.models.LdaModel.get_topic_terms.html#gensim.models.LdaModel.get_topic_terms">[docs]</a>    <span class="k">def</span> <span class="nf">get_topic_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">topicid</span><span class="p">,</span> <span class="n">topn</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of `(word_id, probability)` 2-tuples for the most</span>
<span class="sd">        probable words in topic `topicid`.</span>

<span class="sd">        Only return 2-tuples for the topn most probable words (ignore the rest).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">topic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">get_lambda</span><span class="p">()[</span><span class="n">topicid</span><span class="p">]</span>
        <span class="n">topic</span> <span class="o">=</span> <span class="n">topic</span> <span class="o">/</span> <span class="n">topic</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>  <span class="c1"># normalize to probability distribution</span>
        <span class="n">bestn</span> <span class="o">=</span> <span class="n">matutils</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">topic</span><span class="p">,</span> <span class="n">topn</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[(</span><span class="nb">id</span><span class="p">,</span> <span class="n">topic</span><span class="p">[</span><span class="nb">id</span><span class="p">])</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">bestn</span><span class="p">]</span></div>

<div class="viewcode-block" id="LdaModel.print_topic"><a class="viewcode-back" href="../../../generated/generated/gensim.models.LdaModel.print_topic.html#gensim.models.LdaModel.print_topic">[docs]</a>    <span class="k">def</span> <span class="nf">print_topic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">topicid</span><span class="p">,</span> <span class="n">topn</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the result of `show_topic`, but formatted as a single string.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39; + &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;</span><span class="si">%.3f</span><span class="s1">*</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">show_topic</span><span class="p">(</span><span class="n">topicid</span><span class="p">,</span> <span class="n">topn</span><span class="p">)])</span></div>

<div class="viewcode-block" id="LdaModel.top_topics"><a class="viewcode-back" href="../../../generated/generated/gensim.models.LdaModel.top_topics.html#gensim.models.LdaModel.top_topics">[docs]</a>    <span class="k">def</span> <span class="nf">top_topics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">corpus</span><span class="p">,</span> <span class="n">num_words</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the Umass topic coherence for each topic. Algorithm from</span>
<span class="sd">        **Mimno, Wallach, Talley, Leenders, McCallum: Optimizing Semantic Coherence in Topic Models, CEMNLP 2011.**</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">is_corpus</span><span class="p">,</span> <span class="n">corpus</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_corpus</span><span class="p">(</span><span class="n">corpus</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_corpus</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;LdaModel.top_topics() called with an empty corpus&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">topics</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">str_topics</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">topic</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">get_lambda</span><span class="p">():</span>
            <span class="n">topic</span> <span class="o">=</span> <span class="n">topic</span> <span class="o">/</span> <span class="n">topic</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>  <span class="c1"># normalize to probability distribution</span>
            <span class="n">bestn</span> <span class="o">=</span> <span class="n">matutils</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">topic</span><span class="p">,</span> <span class="n">topn</span><span class="o">=</span><span class="n">num_words</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">topics</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bestn</span><span class="p">)</span>
            <span class="n">beststr</span> <span class="o">=</span> <span class="p">[(</span><span class="n">topic</span><span class="p">[</span><span class="nb">id</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">id2word</span><span class="p">[</span><span class="nb">id</span><span class="p">])</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">bestn</span><span class="p">]</span>
            <span class="n">str_topics</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beststr</span><span class="p">)</span>

        <span class="c1"># top_ids are limited to every topics top words. should not exceed the</span>
        <span class="c1"># vocabulary size.</span>
        <span class="n">top_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">topics</span><span class="p">))</span>

        <span class="c1"># create a document occurence sparse matrix for each word</span>
        <span class="n">doc_word_list</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">top_ids</span><span class="p">:</span>
            <span class="n">id_list</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">document</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">corpus</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">id</span> <span class="ow">in</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">document</span><span class="p">):</span>
                    <span class="n">id_list</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

            <span class="n">doc_word_list</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">id_list</span>

        <span class="n">coherence_scores</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">top_words</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">topics</span><span class="p">):</span>
            <span class="c1"># Calculate each coherence score C(t, top_words)</span>
            <span class="n">coherence</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="c1"># Sum of top words m=2..M</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">top_words</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="c1"># m_docs is v_m^(t)</span>
                <span class="n">m_docs</span> <span class="o">=</span> <span class="n">doc_word_list</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
                <span class="n">m_index</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">top_words</span> <span class="o">==</span> <span class="n">m</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># Sum of top words l=1..m-1</span>
                <span class="c1"># i.e., all words ranked higher than the current word m</span>
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">top_words</span><span class="p">[:</span><span class="n">m_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="c1"># l_docs is v_l^(t)</span>
                    <span class="n">l_docs</span> <span class="o">=</span> <span class="n">doc_word_list</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>

                    <span class="c1"># make sure this word appears in some documents.</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l_docs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># co_doc_frequency is D(v_m^(t), v_l^(t))</span>
                        <span class="n">co_doc_frequency</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">m_docs</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">l_docs</span><span class="p">))</span>

                        <span class="c1"># add to the coherence sum for these two words m, l</span>
                        <span class="n">coherence</span> <span class="o">+=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">((</span><span class="n">co_doc_frequency</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">l_docs</span><span class="p">))</span>

            <span class="n">coherence_scores</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">str_topics</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="n">coherence</span><span class="p">))</span>

        <span class="n">top_topics</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">coherence_scores</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">top_topics</span></div>

<div class="viewcode-block" id="LdaModel.get_document_topics"><a class="viewcode-back" href="../../../generated/generated/gensim.models.LdaModel.get_document_topics.html#gensim.models.LdaModel.get_document_topics">[docs]</a>    <span class="k">def</span> <span class="nf">get_document_topics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bow</span><span class="p">,</span> <span class="n">minimum_probability</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">minimum_phi_value</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">per_word_topics</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return topic distribution for the given document `bow`, as a list of</span>
<span class="sd">        (topic_id, topic_probability) 2-tuples.</span>

<span class="sd">        Ignore topics with very low probability (below `minimum_probability`).</span>

<span class="sd">        If per_word_topics is True, it also returns a list of topics, sorted in descending order of most likely topics for that word.</span>
<span class="sd">        It also returns a list of word_ids and each words corresponding topics&#39; phi_values, multiplied by feature length (i.e, word count)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">minimum_probability</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">minimum_probability</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimum_probability</span>
        <span class="n">minimum_probability</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">minimum_probability</span><span class="p">,</span> <span class="mf">1e-8</span><span class="p">)</span>  <span class="c1"># never allow zero values in sparse output</span>

        <span class="k">if</span> <span class="n">minimum_phi_value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">minimum_phi_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimum_probability</span>
        <span class="n">minimum_phi_value</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">minimum_phi_value</span><span class="p">,</span> <span class="mf">1e-8</span><span class="p">)</span>  <span class="c1"># never allow zero values in sparse output</span>

        <span class="c1"># if the input vector is a corpus, return a transformed corpus</span>
        <span class="n">is_corpus</span><span class="p">,</span> <span class="n">corpus</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_corpus</span><span class="p">(</span><span class="n">bow</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_corpus</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply</span><span class="p">(</span><span class="n">corpus</span><span class="p">)</span>

        <span class="n">gamma</span><span class="p">,</span> <span class="n">phis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inference</span><span class="p">([</span><span class="n">bow</span><span class="p">],</span> <span class="n">collect_sstats</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">topic_dist</span> <span class="o">=</span> <span class="n">gamma</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">gamma</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># normalize distribution</span>

        <span class="n">document_topics</span> <span class="o">=</span> <span class="p">[(</span><span class="n">topicid</span><span class="p">,</span> <span class="n">topicvalue</span><span class="p">)</span> <span class="k">for</span> <span class="n">topicid</span><span class="p">,</span> <span class="n">topicvalue</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">topic_dist</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">topicvalue</span> <span class="o">&gt;=</span> <span class="n">minimum_probability</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">per_word_topics</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">document_topics</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">word_topic</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># contains word and corresponding topic</span>
            <span class="n">word_phi</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># contains word and phi values</span>
            <span class="k">for</span> <span class="n">word_type</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="n">bow</span><span class="p">:</span>
                <span class="n">phi_values</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># contains (phi_value, topic) pairing to later be sorted</span>
                <span class="n">phi_topic</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># contains topic and corresponding phi value to be returned &#39;raw&#39; to user</span>
                <span class="k">for</span> <span class="n">topic_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_topics</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">phis</span><span class="p">[</span><span class="n">topic_id</span><span class="p">][</span><span class="n">word_type</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">minimum_phi_value</span><span class="p">:</span>
                        <span class="c1"># appends phi values for each topic for that word</span>
                        <span class="c1"># these phi values are scaled by feature length</span>
                        <span class="n">phi_values</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">phis</span><span class="p">[</span><span class="n">topic_id</span><span class="p">][</span><span class="n">word_type</span><span class="p">],</span> <span class="n">topic_id</span><span class="p">))</span>
                        <span class="n">phi_topic</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">topic_id</span><span class="p">,</span> <span class="n">phis</span><span class="p">[</span><span class="n">topic_id</span><span class="p">][</span><span class="n">word_type</span><span class="p">]))</span>

                <span class="c1"># list with ({word_id =&gt; [(topic_0, phi_value), (topic_1, phi_value) ...]).</span>
                <span class="n">word_phi</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">word_type</span><span class="p">,</span> <span class="n">phi_topic</span><span class="p">))</span>
                <span class="c1"># sorts the topics based on most likely topic</span>
                <span class="c1"># returns a list like ({word_id =&gt; [topic_id_most_probable, topic_id_second_most_probable, ...]).</span>
                <span class="n">sorted_phi_values</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">phi_values</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="n">topics_sorted</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sorted_phi_values</span><span class="p">]</span>
                <span class="n">word_topic</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">word_type</span><span class="p">,</span> <span class="n">topics_sorted</span><span class="p">))</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">document_topics</span><span class="p">,</span> <span class="n">word_topic</span><span class="p">,</span> <span class="n">word_phi</span><span class="p">)</span> <span class="c1"># returns 2-tuple</span></div>

<div class="viewcode-block" id="LdaModel.get_term_topics"><a class="viewcode-back" href="../../../generated/generated/gensim.models.LdaModel.get_term_topics.html#gensim.models.LdaModel.get_term_topics">[docs]</a>    <span class="k">def</span> <span class="nf">get_term_topics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word_id</span><span class="p">,</span> <span class="n">minimum_probability</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns most likely topics for a particular word in vocab.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">minimum_probability</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">minimum_probability</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimum_probability</span>
        <span class="n">minimum_probability</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">minimum_probability</span><span class="p">,</span> <span class="mf">1e-8</span><span class="p">)</span>  <span class="c1"># never allow zero values in sparse output</span>

        <span class="c1"># if user enters word instead of id in vocab, change to get id</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">word_id</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">word_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id2word</span><span class="o">.</span><span class="n">doc2bow</span><span class="p">([</span><span class="n">word_id</span><span class="p">])[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">topic_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_topics</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expElogbeta</span><span class="p">[</span><span class="n">topic_id</span><span class="p">][</span><span class="n">word_id</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">minimum_probability</span><span class="p">:</span>
                <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">topic_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">expElogbeta</span><span class="p">[</span><span class="n">topic_id</span><span class="p">][</span><span class="n">word_id</span><span class="p">]))</span>

        <span class="k">return</span> <span class="n">values</span></div>


    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bow</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return topic distribution for the given document `bow`, as a list of</span>
<span class="sd">        (topic_id, topic_probability) 2-tuples.</span>

<span class="sd">        Ignore topics with very low probability (below `eps`).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_document_topics</span><span class="p">(</span><span class="n">bow</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>

<div class="viewcode-block" id="LdaModel.save"><a class="viewcode-back" href="../../../generated/generated/gensim.models.LdaModel.save.html#gensim.models.LdaModel.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;state&#39;</span><span class="p">,</span> <span class="s1">&#39;dispatcher&#39;</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the model to file.</span>

<span class="sd">        Large internal arrays may be stored into separate files, with `fname` as prefix.</span>

<span class="sd">        `separately` can be used to define which arrays should be stored in separate files.</span>

<span class="sd">        `ignore` parameter can be used to define which variables should be ignored, i.e. left</span>
<span class="sd">        out from the pickled lda model. By default the internal `state` is ignored as it uses</span>
<span class="sd">        its own serialisation not the one provided by `LdaModel`. The `state` and `dispatcher`</span>
<span class="sd">        will be added to any ignore parameter defined.</span>


<span class="sd">        Note: do not save as a compressed file if you intend to load the file back with `mmap`.</span>

<span class="sd">        Note: If you intend to use models across Python 2/3 versions there are a few things to</span>
<span class="sd">        keep in mind:</span>

<span class="sd">          1. The pickled Python dictionaries will not work across Python versions</span>
<span class="sd">          2. The `save` method does not automatically save all NumPy arrays using NumPy, only</span>
<span class="sd">             those ones that exceed `sep_limit` set in `gensim.utils.SaveLoad.save`. The main</span>
<span class="sd">             concern here is the `alpha` array if for instance using `alpha=&#39;auto&#39;`.</span>

<span class="sd">        Please refer to the wiki recipes section (https://github.com/piskvorky/gensim/wiki/Recipes-&amp;-FAQ#q9-how-do-i-load-a-model-in-python-3-that-was-trained-and-saved-using-python-2)</span>
<span class="sd">        for an example on how to work around these issues.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">smart_extension</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;.state&#39;</span><span class="p">),</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># make sure &#39;state&#39; and &#39;dispatcher&#39; are ignored from the pickled object, even if</span>
        <span class="c1"># someone sets the ignore list themselves</span>
        <span class="k">if</span> <span class="n">ignore</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">ignore</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ignore</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
                <span class="n">ignore</span> <span class="o">=</span> <span class="p">[</span><span class="n">ignore</span><span class="p">]</span>
            <span class="n">ignore</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">ignore</span> <span class="k">if</span> <span class="n">e</span><span class="p">]</span> <span class="c1"># make sure None and &#39;&#39; are not in the list</span>
            <span class="n">ignore</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="s1">&#39;state&#39;</span><span class="p">,</span> <span class="s1">&#39;dispatcher&#39;</span><span class="p">])</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">ignore</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ignore</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;state&#39;</span><span class="p">,</span> <span class="s1">&#39;dispatcher&#39;</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">LdaModel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="n">ignore</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="LdaModel.load"><a class="viewcode-back" href="../../../generated/generated/gensim.models.LdaModel.load.html#gensim.models.LdaModel.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load a previously saved object from file (also see `save`).</span>

<span class="sd">        Large arrays can be memmap&#39;ed back as read-only (shared memory) by setting `mmap=&#39;r&#39;`:</span>

<span class="sd">            &gt;&gt;&gt; LdaModel.load(fname, mmap=&#39;r&#39;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;mmap&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;mmap&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">LdaModel</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">state_fname</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">smart_extension</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;.state&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">LdaModel</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">state_fname</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;failed to load state from </span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">state_fname</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div></div>
<span class="c1"># endclass LdaModel</span>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../../_static/copybutton.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>