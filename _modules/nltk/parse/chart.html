

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>nltk.parse.chart</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="" href="../../../index.html"/>
        <link rel="up" title="nltk" href="../../nltk.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> NLP APIs
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../gensim_tutorial/tutorial.html">Gensim Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../nltk_intro.html">Natural Language Toolkit</a></li>
</ul>
<p class="caption"><span class="caption-text">Autogenerated API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/nltk.html"><code class="docutils literal"><span class="pre">nltk</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.html"><code class="docutils literal"><span class="pre">gensim</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.interfaces.html"><code class="docutils literal"><span class="pre">gensim.interfaces</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.matutils.html"><code class="docutils literal"><span class="pre">gensim.matutils</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.utils.html"><code class="docutils literal"><span class="pre">gensim.utils</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.corpora.html"><code class="docutils literal"><span class="pre">gensim.corpora</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.models.html"><code class="docutils literal"><span class="pre">gensim.models</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.parsing.html"><code class="docutils literal"><span class="pre">gensim.parsing</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.scripts.html"><code class="docutils literal"><span class="pre">gensim.scripts</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.similarities.html"><code class="docutils literal"><span class="pre">gensim.similarities</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.summarization.html"><code class="docutils literal"><span class="pre">gensim.summarization</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.topic_coherence.html"><code class="docutils literal"><span class="pre">gensim.topic_coherence</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/simserver.html"><code class="docutils literal"><span class="pre">simserver</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/word2vec.html"><code class="docutils literal"><span class="pre">word2vec</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/stop_words.html"><code class="docutils literal"><span class="pre">stop_words</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/nltk.classify.html"><code class="docutils literal"><span class="pre">nltk.classify</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/nltk.cluster.html"><code class="docutils literal"><span class="pre">nltk.cluster</span></code></a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">NLP APIs</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          













<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../nltk.html">nltk</a> &raquo;</li>
        
      <li>nltk.parse.chart</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for nltk.parse.chart</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1"># Natural Language Toolkit: A Chart Parser</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2001-2015 NLTK Project</span>
<span class="c1"># Author: Edward Loper &lt;edloper@gmail.com&gt;</span>
<span class="c1">#         Steven Bird &lt;stevenbird1@gmail.com&gt;</span>
<span class="c1">#         Jean Mark Gawron &lt;gawron@mail.sdsu.edu&gt;</span>
<span class="c1">#         Peter Ljungl√∂f &lt;peter.ljunglof@heatherleaf.se&gt;</span>
<span class="c1"># URL: &lt;http://nltk.org/&gt;</span>
<span class="c1"># For license information, see LICENSE.TXT</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Data classes and parser implementations for &quot;chart parsers&quot;, which</span>
<span class="sd">use dynamic programming to efficiently parse a text.  A chart</span>
<span class="sd">parser derives parse trees for a text by iteratively adding &quot;edges&quot;</span>
<span class="sd">to a &quot;chart.&quot;  Each edge represents a hypothesis about the tree</span>
<span class="sd">structure for a subsequence of the text.  The chart is a</span>
<span class="sd">&quot;blackboard&quot; for composing and combining these hypotheses.</span>

<span class="sd">When a chart parser begins parsing a text, it creates a new (empty)</span>
<span class="sd">chart, spanning the text.  It then incrementally adds new edges to the</span>
<span class="sd">chart.  A set of &quot;chart rules&quot; specifies the conditions under which</span>
<span class="sd">new edges should be added to the chart.  Once the chart reaches a</span>
<span class="sd">stage where none of the chart rules adds any new edges, parsing is</span>
<span class="sd">complete.</span>

<span class="sd">Charts are encoded with the ``Chart`` class, and edges are encoded with</span>
<span class="sd">the ``TreeEdge`` and ``LeafEdge`` classes.  The chart parser module</span>
<span class="sd">defines three chart parsers:</span>

<span class="sd">  - ``ChartParser`` is a simple and flexible chart parser.  Given a</span>
<span class="sd">    set of chart rules, it will apply those rules to the chart until</span>
<span class="sd">    no more edges are added.</span>

<span class="sd">  - ``SteppingChartParser`` is a subclass of ``ChartParser`` that can</span>
<span class="sd">    be used to step through the parsing process.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">unicode_literals</span>

<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">nltk</span> <span class="kn">import</span> <span class="n">compat</span>
<span class="kn">from</span> <span class="nn">nltk.tree</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="kn">from</span> <span class="nn">nltk.grammar</span> <span class="kn">import</span> <span class="n">PCFG</span><span class="p">,</span> <span class="n">is_nonterminal</span><span class="p">,</span> <span class="n">is_terminal</span>
<span class="kn">from</span> <span class="nn">nltk.util</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">nltk.internals</span> <span class="kn">import</span> <span class="n">raise_unorderable_types</span>
<span class="kn">from</span> <span class="nn">nltk.compat</span> <span class="kn">import</span> <span class="p">(</span><span class="n">total_ordering</span><span class="p">,</span> <span class="n">python_2_unicode_compatible</span><span class="p">,</span>
                         <span class="n">unicode_repr</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">nltk.parse.api</span> <span class="kn">import</span> <span class="n">ParserI</span>


<span class="c1">########################################################################</span>
<span class="c1">##  Edges</span>
<span class="c1">########################################################################</span>

<span class="nd">@total_ordering</span>
<span class="k">class</span> <span class="nc">EdgeI</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A hypothesis about the structure of part of a sentence.</span>
<span class="sd">    Each edge records the fact that a structure is (partially)</span>
<span class="sd">    consistent with the sentence.  An edge contains:</span>

<span class="sd">    - A span, indicating what part of the sentence is</span>
<span class="sd">      consistent with the hypothesized structure.</span>
<span class="sd">    - A left-hand side, specifying what kind of structure is</span>
<span class="sd">      hypothesized.</span>
<span class="sd">    - A right-hand side, specifying the contents of the</span>
<span class="sd">      hypothesized structure.</span>
<span class="sd">    - A dot position, indicating how much of the hypothesized</span>
<span class="sd">      structure is consistent with the sentence.</span>

<span class="sd">    Every edge is either complete or incomplete:</span>

<span class="sd">    - An edge is complete if its structure is fully consistent</span>
<span class="sd">      with the sentence.</span>
<span class="sd">    - An edge is incomplete if its structure is partially</span>
<span class="sd">      consistent with the sentence.  For every incomplete edge, the</span>
<span class="sd">      span specifies a possible prefix for the edge&#39;s structure.</span>

<span class="sd">    There are two kinds of edge:</span>

<span class="sd">    - A ``TreeEdge`` records which trees have been found to</span>
<span class="sd">      be (partially) consistent with the text.</span>
<span class="sd">    - A ``LeafEdge`` records the tokens occurring in the text.</span>

<span class="sd">    The ``EdgeI`` interface provides a common interface to both types</span>
<span class="sd">    of edge, allowing chart parsers to treat them in a uniform manner.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span> <span class="o">==</span> <span class="n">EdgeI</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Edge is an abstract interface&#39;</span><span class="p">)</span>

    <span class="c1">#////////////////////////////////////////////////////////////</span>
    <span class="c1"># Span</span>
    <span class="c1">#////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">span</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a tuple ``(s, e)``, where ``tokens[s:e]`` is the</span>
<span class="sd">        portion of the sentence that is consistent with this</span>
<span class="sd">        edge&#39;s structure.</span>

<span class="sd">        :rtype: tuple(int, int)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the start index of this edge&#39;s span.</span>

<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">end</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the end index of this edge&#39;s span.</span>

<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the length of this edge&#39;s span.</span>

<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="c1">#////////////////////////////////////////////////////////////</span>
    <span class="c1"># Left Hand Side</span>
    <span class="c1">#////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">lhs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return this edge&#39;s left-hand side, which specifies what kind</span>
<span class="sd">        of structure is hypothesized by this edge.</span>

<span class="sd">        :see: ``TreeEdge`` and ``LeafEdge`` for a description of</span>
<span class="sd">            the left-hand side values for each edge type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="c1">#////////////////////////////////////////////////////////////</span>
    <span class="c1"># Right Hand Side</span>
    <span class="c1">#////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">rhs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return this edge&#39;s right-hand side, which specifies</span>
<span class="sd">        the content of the structure hypothesized by this edge.</span>

<span class="sd">        :see: ``TreeEdge`` and ``LeafEdge`` for a description of</span>
<span class="sd">            the right-hand side values for each edge type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return this edge&#39;s dot position, which indicates how much of</span>
<span class="sd">        the hypothesized structure is consistent with the</span>
<span class="sd">        sentence.  In particular, ``self.rhs[:dot]`` is consistent</span>
<span class="sd">        with ``tokens[self.start():self.end()]``.</span>

<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">nextsym</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the element of this edge&#39;s right-hand side that</span>
<span class="sd">        immediately follows its dot.</span>

<span class="sd">        :rtype: Nonterminal or terminal or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">is_complete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if this edge&#39;s structure is fully consistent</span>
<span class="sd">        with the text.</span>

<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">is_incomplete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if this edge&#39;s structure is partially consistent</span>
<span class="sd">        with the text.</span>

<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="c1">#////////////////////////////////////////////////////////////</span>
    <span class="c1"># Comparisons &amp; hashing</span>
    <span class="c1">#////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span> <span class="ow">is</span> <span class="n">other</span><span class="o">.</span><span class="n">__class__</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_comparison_key</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_comparison_key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">EdgeI</span><span class="p">):</span>
            <span class="n">raise_unorderable_types</span><span class="p">(</span><span class="s2">&quot;&lt;&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span> <span class="ow">is</span> <span class="n">other</span><span class="o">.</span><span class="n">__class__</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comparison_key</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">_comparison_key</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_comparison_key</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span>


<span class="nd">@python_2_unicode_compatible</span>
<span class="k">class</span> <span class="nc">TreeEdge</span><span class="p">(</span><span class="n">EdgeI</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An edge that records the fact that a tree is (partially)</span>
<span class="sd">    consistent with the sentence.  A tree edge consists of:</span>

<span class="sd">    - A span, indicating what part of the sentence is</span>
<span class="sd">      consistent with the hypothesized tree.</span>
<span class="sd">    - A left-hand side, specifying the hypothesized tree&#39;s node</span>
<span class="sd">      value.</span>
<span class="sd">    - A right-hand side, specifying the hypothesized tree&#39;s</span>
<span class="sd">      children.  Each element of the right-hand side is either a</span>
<span class="sd">      terminal, specifying a token with that terminal as its leaf</span>
<span class="sd">      value; or a nonterminal, specifying a subtree with that</span>
<span class="sd">      nonterminal&#39;s symbol as its node value.</span>
<span class="sd">    - A dot position, indicating which children are consistent</span>
<span class="sd">      with part of the sentence.  In particular, if ``dot`` is the</span>
<span class="sd">      dot position, ``rhs`` is the right-hand size, ``(start,end)``</span>
<span class="sd">      is the span, and ``sentence`` is the list of tokens in the</span>
<span class="sd">      sentence, then ``tokens[start:end]`` can be spanned by the</span>
<span class="sd">      children specified by ``rhs[:dot]``.</span>

<span class="sd">    For more information about edges, see the ``EdgeI`` interface.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">span</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">dot</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new ``TreeEdge``.</span>

<span class="sd">        :type span: tuple(int, int)</span>
<span class="sd">        :param span: A tuple ``(s, e)``, where ``tokens[s:e]`` is the</span>
<span class="sd">            portion of the sentence that is consistent with the new</span>
<span class="sd">            edge&#39;s structure.</span>
<span class="sd">        :type lhs: Nonterminal</span>
<span class="sd">        :param lhs: The new edge&#39;s left-hand side, specifying the</span>
<span class="sd">            hypothesized tree&#39;s node value.</span>
<span class="sd">        :type rhs: list(Nonterminal and str)</span>
<span class="sd">        :param rhs: The new edge&#39;s right-hand side, specifying the</span>
<span class="sd">            hypothesized tree&#39;s children.</span>
<span class="sd">        :type dot: int</span>
<span class="sd">        :param dot: The position of the new edge&#39;s dot.  This position</span>
<span class="sd">            specifies what prefix of the production&#39;s right hand side</span>
<span class="sd">            is consistent with the text.  In particular, if</span>
<span class="sd">            ``sentence`` is the list of tokens in the sentence, then</span>
<span class="sd">            ``okens[span[0]:span[1]]`` can be spanned by the</span>
<span class="sd">            children specified by ``rhs[:dot]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_span</span> <span class="o">=</span> <span class="n">span</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lhs</span> <span class="o">=</span> <span class="n">lhs</span>
        <span class="n">rhs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rhs</span> <span class="o">=</span> <span class="n">rhs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dot</span> <span class="o">=</span> <span class="n">dot</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comparison_key</span> <span class="o">=</span> <span class="p">(</span><span class="n">span</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">dot</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_production</span><span class="p">(</span><span class="n">production</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new ``TreeEdge`` formed from the given production.</span>
<span class="sd">        The new edge&#39;s left-hand side and right-hand side will</span>
<span class="sd">        be taken from ``production``; its span will be</span>
<span class="sd">        ``(index,index)``; and its dot position will be ``0``.</span>

<span class="sd">        :rtype: TreeEdge</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TreeEdge</span><span class="p">(</span><span class="n">span</span><span class="o">=</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">index</span><span class="p">),</span> <span class="n">lhs</span><span class="o">=</span><span class="n">production</span><span class="o">.</span><span class="n">lhs</span><span class="p">(),</span>
                        <span class="n">rhs</span><span class="o">=</span><span class="n">production</span><span class="o">.</span><span class="n">rhs</span><span class="p">(),</span> <span class="n">dot</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">move_dot_forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_end</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new ``TreeEdge`` formed from this edge.</span>
<span class="sd">        The new edge&#39;s dot position is increased by ``1``,</span>
<span class="sd">        and its end index will be replaced by ``new_end``.</span>

<span class="sd">        :param new_end: The new end index.</span>
<span class="sd">        :type new_end: int</span>
<span class="sd">        :rtype: TreeEdge</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TreeEdge</span><span class="p">(</span><span class="n">span</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_span</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">new_end</span><span class="p">),</span>
                        <span class="n">lhs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_rhs</span><span class="p">,</span>
                        <span class="n">dot</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_dot</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Accessors</span>
    <span class="k">def</span> <span class="nf">lhs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lhs</span>
    <span class="k">def</span> <span class="nf">span</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_span</span>
    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_span</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">def</span> <span class="nf">end</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_span</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_span</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_span</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">def</span> <span class="nf">rhs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rhs</span>
    <span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dot</span>
    <span class="k">def</span> <span class="nf">is_complete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dot</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rhs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">is_incomplete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dot</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rhs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">nextsym</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dot</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rhs</span><span class="p">):</span> <span class="k">return</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rhs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_dot</span><span class="p">]</span>

    <span class="c1"># String representation</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;[</span><span class="si">%s</span><span class="s1">:</span><span class="si">%s</span><span class="s1">] &#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_span</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_span</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="nb">str</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">%-2r</span><span class="s1"> -&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lhs</span><span class="p">,)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rhs</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dot</span><span class="p">:</span> <span class="nb">str</span> <span class="o">+=</span> <span class="s1">&#39; *&#39;</span>
            <span class="nb">str</span> <span class="o">+=</span> <span class="s1">&#39; </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">unicode_repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rhs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rhs</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dot</span><span class="p">:</span> <span class="nb">str</span> <span class="o">+=</span> <span class="s1">&#39; *&#39;</span>
        <span class="k">return</span> <span class="nb">str</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;[Edge: </span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="bp">self</span>


<span class="nd">@python_2_unicode_compatible</span>
<span class="k">class</span> <span class="nc">LeafEdge</span><span class="p">(</span><span class="n">EdgeI</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An edge that records the fact that a leaf value is consistent with</span>
<span class="sd">    a word in the sentence.  A leaf edge consists of:</span>

<span class="sd">    - An index, indicating the position of the word.</span>
<span class="sd">    - A leaf, specifying the word&#39;s content.</span>

<span class="sd">    A leaf edge&#39;s left-hand side is its leaf value, and its right hand</span>
<span class="sd">    side is ``()``.  Its span is ``[index, index+1]``, and its dot</span>
<span class="sd">    position is ``0``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">leaf</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new ``LeafEdge``.</span>

<span class="sd">        :param leaf: The new edge&#39;s leaf value, specifying the word</span>
<span class="sd">            that is recorded by this edge.</span>
<span class="sd">        :param index: The new edge&#39;s index, specifying the position of</span>
<span class="sd">            the word that is recorded by this edge.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_leaf</span> <span class="o">=</span> <span class="n">leaf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="n">index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comparison_key</span> <span class="o">=</span> <span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="c1"># Accessors</span>
    <span class="k">def</span> <span class="nf">lhs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leaf</span>
    <span class="k">def</span> <span class="nf">span</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span>
    <span class="k">def</span> <span class="nf">end</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">+</span><span class="mi">1</span>
    <span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="mi">1</span>
    <span class="k">def</span> <span class="nf">rhs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="p">()</span>
    <span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="mi">0</span>
    <span class="k">def</span> <span class="nf">is_complete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">True</span>
    <span class="k">def</span> <span class="nf">is_incomplete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">False</span>
    <span class="k">def</span> <span class="nf">nextsym</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">None</span>

    <span class="c1"># String representations</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;[</span><span class="si">%s</span><span class="s1">:</span><span class="si">%s</span><span class="s1">] </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">unicode_repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_leaf</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;[Edge: </span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<span class="c1">########################################################################</span>
<span class="c1">##  Chart</span>
<span class="c1">########################################################################</span>

<span class="k">class</span> <span class="nc">Chart</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A blackboard for hypotheses about the syntactic constituents of a</span>
<span class="sd">    sentence.  A chart contains a set of edges, and each edge encodes</span>
<span class="sd">    a single hypothesis about the structure of some portion of the</span>
<span class="sd">    sentence.</span>

<span class="sd">    The ``select`` method can be used to select a specific collection</span>
<span class="sd">    of edges.  For example ``chart.select(is_complete=True, start=0)``</span>
<span class="sd">    yields all complete edges whose start indices are 0.  To ensure</span>
<span class="sd">    the efficiency of these selection operations, ``Chart`` dynamically</span>
<span class="sd">    creates and maintains an index for each set of attributes that</span>
<span class="sd">    have been selected on.</span>

<span class="sd">    In order to reconstruct the trees that are represented by an edge,</span>
<span class="sd">    the chart associates each edge with a set of child pointer lists.</span>
<span class="sd">    A child pointer list is a list of the edges that license an</span>
<span class="sd">    edge&#39;s right-hand side.</span>

<span class="sd">    :ivar _tokens: The sentence that the chart covers.</span>
<span class="sd">    :ivar _num_leaves: The number of tokens.</span>
<span class="sd">    :ivar _edges: A list of the edges in the chart</span>
<span class="sd">    :ivar _edge_to_cpls: A dictionary mapping each edge to a set</span>
<span class="sd">        of child pointer lists that are associated with that edge.</span>
<span class="sd">    :ivar _indexes: A dictionary mapping tuples of edge attributes</span>
<span class="sd">        to indices, where each index maps the corresponding edge</span>
<span class="sd">        attribute values to lists of edges.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new chart. The chart is initialized with the</span>
<span class="sd">        leaf edges corresponding to the terminal leaves.</span>

<span class="sd">        :type tokens: list</span>
<span class="sd">        :param tokens: The sentence that this chart will be used to parse.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Record the sentence token and the sentence length.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tokens</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_num_leaves</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tokens</span><span class="p">)</span>

        <span class="c1"># Initialise the chart.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clear the chart.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># A list of edges contained in this chart.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># The set of child pointer lists associated with each edge.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edge_to_cpls</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Indexes mapping attribute values to lists of edges</span>
        <span class="c1"># (used by select()).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1">#////////////////////////////////////////////////////////////</span>
    <span class="c1"># Sentence Access</span>
    <span class="c1">#////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">num_leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of words in this chart&#39;s sentence.</span>

<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_leaves</span>

    <span class="k">def</span> <span class="nf">leaf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the leaf value of the word at the given index.</span>

<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tokens</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of the leaf values of each word in the</span>
<span class="sd">        chart&#39;s sentence.</span>

<span class="sd">        :rtype: list(str)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tokens</span>

    <span class="c1">#////////////////////////////////////////////////////////////</span>
    <span class="c1"># Edge access</span>
    <span class="c1">#////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of all edges in this chart.  New edges</span>
<span class="sd">        that are added to the chart after the call to edges()</span>
<span class="sd">        will *not* be contained in this list.</span>

<span class="sd">        :rtype: list(EdgeI)</span>
<span class="sd">        :see: ``iteredges``, ``select``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[:]</span>

    <span class="k">def</span> <span class="nf">iteredges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an iterator over the edges in this chart.  It is</span>
<span class="sd">        not guaranteed that new edges which are added to the</span>
<span class="sd">        chart before the iterator is exhausted will also be generated.</span>

<span class="sd">        :rtype: iter(EdgeI)</span>
<span class="sd">        :see: ``edges``, ``select``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">)</span>

    <span class="c1"># Iterating over the chart yields its edges.</span>
    <span class="n">__iter__</span> <span class="o">=</span> <span class="n">iteredges</span>

    <span class="k">def</span> <span class="nf">num_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of edges contained in this chart.</span>

<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_to_cpls</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">restrictions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an iterator over the edges in this chart.  Any</span>
<span class="sd">        new edges that are added to the chart before the iterator</span>
<span class="sd">        is exahusted will also be generated.  ``restrictions``</span>
<span class="sd">        can be used to restrict the set of edges that will be</span>
<span class="sd">        generated.</span>

<span class="sd">        :param span: Only generate edges ``e`` where ``e.span()==span``</span>
<span class="sd">        :param start: Only generate edges ``e`` where ``e.start()==start``</span>
<span class="sd">        :param end: Only generate edges ``e`` where ``e.end()==end``</span>
<span class="sd">        :param length: Only generate edges ``e`` where ``e.length()==length``</span>
<span class="sd">        :param lhs: Only generate edges ``e`` where ``e.lhs()==lhs``</span>
<span class="sd">        :param rhs: Only generate edges ``e`` where ``e.rhs()==rhs``</span>
<span class="sd">        :param nextsym: Only generate edges ``e`` where</span>
<span class="sd">            ``e.nextsym()==nextsym``</span>
<span class="sd">        :param dot: Only generate edges ``e`` where ``e.dot()==dot``</span>
<span class="sd">        :param is_complete: Only generate edges ``e`` where</span>
<span class="sd">            ``e.is_complete()==is_complete``</span>
<span class="sd">        :param is_incomplete: Only generate edges ``e`` where</span>
<span class="sd">            ``e.is_incomplete()==is_incomplete``</span>
<span class="sd">        :rtype: iter(EdgeI)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If there are no restrictions, then return all edges.</span>
        <span class="k">if</span> <span class="n">restrictions</span><span class="o">==</span><span class="p">{}:</span> <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">)</span>

        <span class="c1"># Find the index corresponding to the given restrictions.</span>
        <span class="n">restr_keys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">restrictions</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">restr_keys</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">restr_keys</span><span class="p">)</span>

        <span class="c1"># If it doesn&#39;t exist, then create it.</span>
        <span class="k">if</span> <span class="n">restr_keys</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_index</span><span class="p">(</span><span class="n">restr_keys</span><span class="p">)</span>

        <span class="n">vals</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">restrictions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">restr_keys</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">[</span><span class="n">restr_keys</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="p">[]))</span>

    <span class="k">def</span> <span class="nf">_add_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">restr_keys</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A helper function for ``select``, which creates a new index for</span>
<span class="sd">        a given set of attributes (aka restriction keys).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make sure it&#39;s a valid index.</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">restr_keys</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">EdgeI</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Bad restriction: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span>

        <span class="c1"># Create the index.</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">[</span><span class="n">restr_keys</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Add all existing edges to the index.</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">:</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">key</span><span class="p">)()</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">restr_keys</span><span class="p">)</span>
            <span class="n">index</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_register_with_indexes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A helper function for ``insert``, which registers the new</span>
<span class="sd">        edge with all existing indexes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">restr_keys</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">key</span><span class="p">)()</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">restr_keys</span><span class="p">)</span>
            <span class="n">index</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

    <span class="c1">#////////////////////////////////////////////////////////////</span>
    <span class="c1"># Edge Insertion</span>
    <span class="c1">#////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">insert_with_backpointer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_edge</span><span class="p">,</span> <span class="n">previous_edge</span><span class="p">,</span> <span class="n">child_edge</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a new edge to the chart, using a pointer to the previous edge.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cpls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">child_pointer_lists</span><span class="p">(</span><span class="n">previous_edge</span><span class="p">)</span>
        <span class="n">new_cpls</span> <span class="o">=</span> <span class="p">[</span><span class="n">cpl</span><span class="o">+</span><span class="p">(</span><span class="n">child_edge</span><span class="p">,)</span> <span class="k">for</span> <span class="n">cpl</span> <span class="ow">in</span> <span class="n">cpls</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="o">*</span><span class="n">new_cpls</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="o">*</span><span class="n">child_pointer_lists</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a new edge to the chart, and return True if this operation</span>
<span class="sd">        modified the chart.  In particular, return true iff the chart</span>
<span class="sd">        did not already contain ``edge``, or if it did not already associate</span>
<span class="sd">        ``child_pointer_lists`` with ``edge``.</span>

<span class="sd">        :type edge: EdgeI</span>
<span class="sd">        :param edge: The new edge</span>
<span class="sd">        :type child_pointer_lists: sequence of tuple(EdgeI)</span>
<span class="sd">        :param child_pointer_lists: A sequence of lists of the edges that</span>
<span class="sd">            were used to form this edge.  This list is used to reconstruct</span>
<span class="sd">            the trees (or partial trees) that are associated with ``edge``.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Is it a new edge?</span>
        <span class="k">if</span> <span class="n">edge</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_to_cpls</span><span class="p">:</span>
            <span class="c1"># Add it to the list of edges.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_append_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
            <span class="c1"># Register with indexes.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_register_with_indexes</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

        <span class="c1"># Get the set of child pointer lists for this edge.</span>
        <span class="n">cpls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_to_cpls</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">())</span>
        <span class="n">chart_was_modified</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">child_pointer_list</span> <span class="ow">in</span> <span class="n">child_pointer_lists</span><span class="p">:</span>
            <span class="n">child_pointer_list</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">child_pointer_list</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">child_pointer_list</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cpls</span><span class="p">:</span>
                <span class="c1"># It&#39;s a new CPL; register it, and return true.</span>
                <span class="n">cpls</span><span class="p">[</span><span class="n">child_pointer_list</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">chart_was_modified</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="n">chart_was_modified</span>

    <span class="k">def</span> <span class="nf">_append_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

    <span class="c1">#////////////////////////////////////////////////////////////</span>
    <span class="c1"># Tree extraction &amp; child pointer lists</span>
    <span class="c1">#////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">parses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">tree_class</span><span class="o">=</span><span class="n">Tree</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an iterator of the complete tree structures that span</span>
<span class="sd">        the entire chart, and whose root node is ``root``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_leaves</span><span class="p">,</span> <span class="n">lhs</span><span class="o">=</span><span class="n">root</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trees</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">tree_class</span><span class="o">=</span><span class="n">tree_class</span><span class="p">,</span> <span class="n">complete</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">tree</span>

    <span class="k">def</span> <span class="nf">trees</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">tree_class</span><span class="o">=</span><span class="n">Tree</span><span class="p">,</span> <span class="n">complete</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an iterator of the tree structures that are associated</span>
<span class="sd">        with ``edge``.</span>

<span class="sd">        If ``edge`` is incomplete, then the unexpanded children will be</span>
<span class="sd">        encoded as childless subtrees, whose node value is the</span>
<span class="sd">        corresponding terminal or nonterminal.</span>

<span class="sd">        :rtype: list(Tree)</span>
<span class="sd">        :note: If two trees share a common subtree, then the same</span>
<span class="sd">            Tree may be used to encode that subtree in</span>
<span class="sd">            both trees.  If you need to eliminate this subtree</span>
<span class="sd">            sharing, then create a deep copy of each tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_trees</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">complete</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="p">{},</span> <span class="n">tree_class</span><span class="o">=</span><span class="n">tree_class</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_trees</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">complete</span><span class="p">,</span> <span class="n">memo</span><span class="p">,</span> <span class="n">tree_class</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A helper function for ``trees``.</span>

<span class="sd">        :param memo: A dictionary used to record the trees that we&#39;ve</span>
<span class="sd">            generated for each edge, so that when we see an edge more</span>
<span class="sd">            than once, we can reuse the same trees.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If we&#39;ve seen this edge before, then reuse our old answer.</span>
        <span class="k">if</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">memo</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">memo</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span>

        <span class="c1"># when we&#39;re reading trees off the chart, don&#39;t use incomplete edges</span>
        <span class="k">if</span> <span class="n">complete</span> <span class="ow">and</span> <span class="n">edge</span><span class="o">.</span><span class="n">is_incomplete</span><span class="p">():</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="c1"># Leaf edges.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">LeafEdge</span><span class="p">):</span>
            <span class="n">leaf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tokens</span><span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">start</span><span class="p">()]</span>
            <span class="n">memo</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">leaf</span><span class="p">]</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">leaf</span><span class="p">]</span>

        <span class="c1"># Until we&#39;re done computing the trees for edge, set</span>
        <span class="c1"># memo[edge] to be empty.  This has the effect of filtering</span>
        <span class="c1"># out any cyclic trees (i.e., trees that contain themselves as</span>
        <span class="c1"># descendants), because if we reach this edge via a cycle,</span>
        <span class="c1"># then it will appear that the edge doesn&#39;t generate any trees.</span>
        <span class="n">memo</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">trees</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lhs</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">lhs</span><span class="p">()</span><span class="o">.</span><span class="n">symbol</span><span class="p">()</span>

        <span class="c1"># Each child pointer list can be used to form trees.</span>
        <span class="k">for</span> <span class="n">cpl</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">child_pointer_lists</span><span class="p">(</span><span class="n">edge</span><span class="p">):</span>
            <span class="c1"># Get the set of child choices for each child pointer.</span>
            <span class="c1"># child_choices[i] is the set of choices for the tree&#39;s</span>
            <span class="c1"># ith child.</span>
            <span class="n">child_choices</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_trees</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">complete</span><span class="p">,</span> <span class="n">memo</span><span class="p">,</span> <span class="n">tree_class</span><span class="p">)</span>
                             <span class="k">for</span> <span class="n">cp</span> <span class="ow">in</span> <span class="n">cpl</span><span class="p">]</span>

            <span class="c1"># For each combination of children, add a tree.</span>
            <span class="k">for</span> <span class="n">children</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">child_choices</span><span class="p">):</span>
                <span class="n">trees</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tree_class</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">children</span><span class="p">))</span>

        <span class="c1"># If the edge is incomplete, then extend it with &quot;partial trees&quot;:</span>
        <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">is_incomplete</span><span class="p">():</span>
            <span class="n">unexpanded</span> <span class="o">=</span> <span class="p">[</span><span class="n">tree_class</span><span class="p">(</span><span class="n">elt</span><span class="p">,[])</span>
                          <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="n">edge</span><span class="o">.</span><span class="n">rhs</span><span class="p">()[</span><span class="n">edge</span><span class="o">.</span><span class="n">dot</span><span class="p">():]]</span>
            <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">trees</span><span class="p">:</span>
                <span class="n">tree</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">unexpanded</span><span class="p">)</span>

        <span class="c1"># Update the memoization dictionary.</span>
        <span class="n">memo</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span> <span class="o">=</span> <span class="n">trees</span>

        <span class="c1"># Return the list of trees.</span>
        <span class="k">return</span> <span class="n">trees</span>

    <span class="k">def</span> <span class="nf">child_pointer_lists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the set of child pointer lists for the given edge.</span>
<span class="sd">        Each child pointer list is a list of edges that have</span>
<span class="sd">        been used to form this edge.</span>

<span class="sd">        :rtype: list(list(EdgeI))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make a copy, in case they modify it.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_to_cpls</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

    <span class="c1">#////////////////////////////////////////////////////////////</span>
    <span class="c1"># Display</span>
    <span class="c1">#////////////////////////////////////////////////////////////</span>
    <span class="k">def</span> <span class="nf">pretty_format_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a pretty-printed string representation of a given edge</span>
<span class="sd">        in this chart.</span>

<span class="sd">        :rtype: str</span>
<span class="sd">        :param width: The number of characters allotted to each</span>
<span class="sd">            index in the sentence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">width</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="n">width</span> <span class="o">=</span> <span class="mi">50</span> <span class="o">//</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">edge</span><span class="o">.</span><span class="n">end</span><span class="p">())</span>

        <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;|&#39;</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="o">+</span><span class="s1">&#39; &#39;</span><span class="o">*</span><span class="p">(</span><span class="n">width</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="n">start</span>

        <span class="c1"># Zero-width edges are &quot;#&quot; if complete, &quot;&gt;&quot; if incomplete</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">is_complete</span><span class="p">():</span> <span class="nb">str</span> <span class="o">+=</span> <span class="s1">&#39;#&#39;</span>
            <span class="k">else</span><span class="p">:</span> <span class="nb">str</span> <span class="o">+=</span> <span class="s1">&#39;&gt;&#39;</span>

        <span class="c1"># Spanning complete edges are &quot;[===]&quot;; Other edges are</span>
        <span class="c1"># &quot;[---]&quot; if complete, &quot;[---&gt;&quot; if incomplete</span>
        <span class="k">elif</span> <span class="n">edge</span><span class="o">.</span><span class="n">is_complete</span><span class="p">()</span> <span class="ow">and</span> <span class="n">edge</span><span class="o">.</span><span class="n">span</span><span class="p">()</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_leaves</span><span class="p">):</span>
            <span class="nb">str</span> <span class="o">+=</span> <span class="s1">&#39;[&#39;</span><span class="o">+</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="n">width</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="p">(</span><span class="n">width</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;]&#39;</span>
        <span class="k">elif</span> <span class="n">edge</span><span class="o">.</span><span class="n">is_complete</span><span class="p">():</span>
            <span class="nb">str</span> <span class="o">+=</span> <span class="s1">&#39;[&#39;</span><span class="o">+</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="o">*</span><span class="n">width</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;-&#39;</span><span class="o">*</span><span class="p">(</span><span class="n">width</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;]&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">str</span> <span class="o">+=</span> <span class="s1">&#39;[&#39;</span><span class="o">+</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="o">*</span><span class="n">width</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;-&#39;</span><span class="o">*</span><span class="p">(</span><span class="n">width</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;&gt;&#39;</span>

        <span class="nb">str</span> <span class="o">+=</span> <span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">*</span><span class="p">(</span><span class="n">width</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.&#39;</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_leaves</span><span class="o">-</span><span class="n">end</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">str</span> <span class="o">+</span> <span class="s1">&#39;| </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">edge</span>

    <span class="k">def</span> <span class="nf">pretty_format_leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a pretty-printed string representation of this</span>
<span class="sd">        chart&#39;s leaves.  This string can be used as a header</span>
<span class="sd">        for calls to ``pretty_format_edge``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">width</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="n">width</span> <span class="o">=</span> <span class="mi">50</span> <span class="o">//</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tokens</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">width</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">header</span> <span class="o">=</span> <span class="s1">&#39;|.&#39;</span>
            <span class="k">for</span> <span class="n">tok</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tokens</span><span class="p">:</span>
                <span class="n">header</span> <span class="o">+=</span> <span class="n">tok</span><span class="p">[:</span><span class="n">width</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">width</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.&#39;</span>
            <span class="n">header</span> <span class="o">+=</span> <span class="s1">&#39;|&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">header</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

        <span class="k">return</span> <span class="n">header</span>

    <span class="k">def</span> <span class="nf">pretty_format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a pretty-printed string representation of this chart.</span>

<span class="sd">        :param width: The number of characters allotted to each</span>
<span class="sd">            index in the sentence.</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">width</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="n">width</span> <span class="o">=</span> <span class="mi">50</span> <span class="o">//</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># sort edges: primary key=length, secondary key=start index.</span>
        <span class="c1"># (and filter out the token edges)</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([(</span><span class="n">e</span><span class="o">.</span><span class="n">length</span><span class="p">(),</span> <span class="n">e</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">e</span><span class="p">)</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pretty_format_leaves</span><span class="p">(</span><span class="n">width</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span>
                <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pretty_format_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">))</span>

    <span class="c1">#////////////////////////////////////////////////////////////</span>
    <span class="c1"># Display: Dot (AT&amp;T Graphviz)</span>
    <span class="c1">#////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">dot_digraph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Header</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;digraph nltk_chart {</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="c1">#s += &#39;  size=&quot;5,5&quot;;\n&#39;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;  rankdir=LR;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;  node [height=0.1,width=0.1];</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;  node [style=filled, color=&quot;lightgray&quot;];</span><span class="se">\n</span><span class="s1">&#39;</span>

        <span class="c1"># Set up the nodes</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span><span class="p">(),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;  node [style=filled, color=&quot;black&quot;];</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="ow">or</span>
                              <span class="n">x</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">end</span><span class="p">()):</span>
                    <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;  </span><span class="si">%04d</span><span class="s1">.</span><span class="si">%04d</span><span class="s1"> [label=&quot;&quot;];</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>

        <span class="c1"># Add a spacer</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;  x [style=invis]; x-&gt;0000.0000 [style=invis];</span><span class="se">\n</span><span class="s1">&#39;</span>

        <span class="c1"># Declare ranks.</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;  {rank=same;&#39;</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="ow">or</span>
                              <span class="n">x</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">end</span><span class="p">()):</span>
                    <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39; </span><span class="si">%04d</span><span class="s1">.</span><span class="si">%04d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;}</span><span class="se">\n</span><span class="s1">&#39;</span>

        <span class="c1"># Add the leaves</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;  edge [style=invis, weight=100];</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;  node [shape=plaintext]</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;  0000.0000&#39;</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()):</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;-&gt;</span><span class="si">%s</span><span class="s1">-&gt;</span><span class="si">%04d</span><span class="s1">.0000&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">leaf</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;;</span><span class="se">\n\n</span><span class="s1">&#39;</span>

        <span class="c1"># Add the edges</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;  edge [style=solid, weight=1];</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">for</span> <span class="n">y</span><span class="p">,</span> <span class="n">edge</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">start</span><span class="p">()):</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="p">(</span><span class="s1">&#39;  </span><span class="si">%04d</span><span class="s1">.</span><span class="si">%04d</span><span class="s1"> -&gt; </span><span class="si">%04d</span><span class="s1">.</span><span class="si">%04d</span><span class="s1"> [style=&quot;invis&quot;];</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span>
                      <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="p">(</span><span class="s1">&#39;  </span><span class="si">%04d</span><span class="s1">.</span><span class="si">%04d</span><span class="s1"> -&gt; </span><span class="si">%04d</span><span class="s1">.</span><span class="si">%04d</span><span class="s1"> [label=&quot;</span><span class="si">%s</span><span class="s1">&quot;];</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span>
                  <span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">edge</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">edge</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()):</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="p">(</span><span class="s1">&#39;  </span><span class="si">%04d</span><span class="s1">.</span><span class="si">%04d</span><span class="s1"> -&gt; </span><span class="si">%04d</span><span class="s1">.</span><span class="si">%04d</span><span class="s1"> [style=&quot;invis&quot;];</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span>
                      <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;}</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">return</span> <span class="n">s</span>

<span class="c1">########################################################################</span>
<span class="c1">##  Chart Rules</span>
<span class="c1">########################################################################</span>

<span class="k">class</span> <span class="nc">ChartRuleI</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A rule that specifies what new edges are licensed by any given set</span>
<span class="sd">    of existing edges.  Each chart rule expects a fixed number of</span>
<span class="sd">    edges, as indicated by the class variable ``NUM_EDGES``.  In</span>
<span class="sd">    particular:</span>

<span class="sd">    - A chart rule with ``NUM_EDGES=0`` specifies what new edges are</span>
<span class="sd">      licensed, regardless of existing edges.</span>
<span class="sd">    - A chart rule with ``NUM_EDGES=1`` specifies what new edges are</span>
<span class="sd">      licensed by a single existing edge.</span>
<span class="sd">    - A chart rule with ``NUM_EDGES=2`` specifies what new edges are</span>
<span class="sd">      licensed by a pair of existing edges.</span>

<span class="sd">    :type NUM_EDGES: int</span>
<span class="sd">    :cvar NUM_EDGES: The number of existing edges that this rule uses</span>
<span class="sd">        to license new edges.  Typically, this number ranges from zero</span>
<span class="sd">        to two.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="o">*</span><span class="n">edges</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a generator that will add edges licensed by this rule</span>
<span class="sd">        and the given edges to the chart, one at a time.  Each</span>
<span class="sd">        time the generator is resumed, it will either add a new</span>
<span class="sd">        edge and yield that edge; or return.</span>

<span class="sd">        :type edges: list(EdgeI)</span>
<span class="sd">        :param edges: A set of existing edges.  The number of edges</span>
<span class="sd">            that should be passed to ``apply()`` is specified by the</span>
<span class="sd">            ``NUM_EDGES`` class variable.</span>
<span class="sd">        :rtype: iter(EdgeI)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">apply_everywhere</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a generator that will add all edges licensed by</span>
<span class="sd">        this rule, given the edges that are currently in the</span>
<span class="sd">        chart, one at a time.  Each time the generator is resumed,</span>
<span class="sd">        it will either add a new edge and yield that edge; or return.</span>

<span class="sd">        :rtype: iter(EdgeI)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>


<span class="nd">@python_2_unicode_compatible</span>
<span class="k">class</span> <span class="nc">AbstractChartRule</span><span class="p">(</span><span class="n">ChartRuleI</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An abstract base class for chart rules.  ``AbstractChartRule``</span>
<span class="sd">    provides:</span>

<span class="sd">    - A default implementation for ``apply``.</span>
<span class="sd">    - A default implementation for ``apply_everywhere``,</span>
<span class="sd">      (Currently, this implementation assumes that ``NUM_EDGES``&lt;=3.)</span>
<span class="sd">    - A default implementation for ``__str__``, which returns a</span>
<span class="sd">      name based on the rule&#39;s class name.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Subclasses must define apply.</span>
    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="o">*</span><span class="n">edges</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="c1"># Default: loop through the given number of edges, and call</span>
    <span class="c1"># self.apply() for each set of edges.</span>
    <span class="k">def</span> <span class="nf">apply_everywhere</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">NUM_EDGES</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">new_edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">new_edge</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">NUM_EDGES</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">e1</span> <span class="ow">in</span> <span class="n">chart</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">new_edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">e1</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">new_edge</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">NUM_EDGES</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">e1</span> <span class="ow">in</span> <span class="n">chart</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">e2</span> <span class="ow">in</span> <span class="n">chart</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">new_edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">):</span>
                        <span class="k">yield</span> <span class="n">new_edge</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">NUM_EDGES</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">e1</span> <span class="ow">in</span> <span class="n">chart</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">e2</span> <span class="ow">in</span> <span class="n">chart</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">e3</span> <span class="ow">in</span> <span class="n">chart</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">new_edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span><span class="n">grammar</span><span class="p">,</span><span class="n">e1</span><span class="p">,</span><span class="n">e2</span><span class="p">,</span><span class="n">e3</span><span class="p">):</span>
                            <span class="k">yield</span> <span class="n">new_edge</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;NUM_EDGES&gt;3 is not currently supported&#39;</span><span class="p">)</span>

    <span class="c1"># Default: return a name based on the class name.</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Add spaces between InitialCapsWords.</span>
        <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;([a-z])([A-Z])&#39;</span><span class="p">,</span> <span class="s1">r&#39;\1 \2&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>

<span class="c1">#////////////////////////////////////////////////////////////</span>
<span class="c1"># Fundamental Rule</span>
<span class="c1">#////////////////////////////////////////////////////////////</span>

<span class="k">class</span> <span class="nc">FundamentalRule</span><span class="p">(</span><span class="n">AbstractChartRule</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A rule that joins two adjacent edges to form a single combined</span>
<span class="sd">    edge.  In particular, this rule specifies that any pair of edges</span>

<span class="sd">    - ``[A -&gt; alpha \* B beta][i:j]``</span>
<span class="sd">    - ``[B -&gt; gamma \*][j:k]``</span>

<span class="sd">    licenses the edge:</span>

<span class="sd">    - ``[A -&gt; alpha B * beta][i:j]``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">NUM_EDGES</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">left_edge</span><span class="p">,</span> <span class="n">right_edge</span><span class="p">):</span>
        <span class="c1"># Make sure the rule is applicable.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">left_edge</span><span class="o">.</span><span class="n">is_incomplete</span><span class="p">()</span> <span class="ow">and</span>
                <span class="n">right_edge</span><span class="o">.</span><span class="n">is_complete</span><span class="p">()</span> <span class="ow">and</span>
                <span class="n">left_edge</span><span class="o">.</span><span class="n">end</span><span class="p">()</span> <span class="o">==</span> <span class="n">right_edge</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="ow">and</span>
                <span class="n">left_edge</span><span class="o">.</span><span class="n">nextsym</span><span class="p">()</span> <span class="o">==</span> <span class="n">right_edge</span><span class="o">.</span><span class="n">lhs</span><span class="p">()):</span>
            <span class="k">return</span>

        <span class="c1"># Construct the new edge.</span>
        <span class="n">new_edge</span> <span class="o">=</span> <span class="n">left_edge</span><span class="o">.</span><span class="n">move_dot_forward</span><span class="p">(</span><span class="n">right_edge</span><span class="o">.</span><span class="n">end</span><span class="p">())</span>

        <span class="c1"># Insert it into the chart.</span>
        <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert_with_backpointer</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="n">left_edge</span><span class="p">,</span> <span class="n">right_edge</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">new_edge</span>

<span class="k">class</span> <span class="nc">SingleEdgeFundamentalRule</span><span class="p">(</span><span class="n">FundamentalRule</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A rule that joins a given edge with adjacent edges in the chart,</span>
<span class="sd">    to form combined edges.  In particular, this rule specifies that</span>
<span class="sd">    either of the edges:</span>

<span class="sd">    - ``[A -&gt; alpha \* B beta][i:j]``</span>
<span class="sd">    - ``[B -&gt; gamma \*][j:k]``</span>

<span class="sd">    licenses the edge:</span>

<span class="sd">    - ``[A -&gt; alpha B * beta][i:j]``</span>

<span class="sd">    if the other edge is already in the chart.</span>

<span class="sd">    :note: This is basically ``FundamentalRule``, with one edge left</span>
<span class="sd">        unspecified.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">NUM_EDGES</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">is_incomplete</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">new_edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_incomplete</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">new_edge</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">new_edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_complete</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">new_edge</span>

    <span class="k">def</span> <span class="nf">_apply_complete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">right_edge</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">left_edge</span> <span class="ow">in</span> <span class="n">chart</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">end</span><span class="o">=</span><span class="n">right_edge</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span>
                                      <span class="n">is_complete</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                      <span class="n">nextsym</span><span class="o">=</span><span class="n">right_edge</span><span class="o">.</span><span class="n">lhs</span><span class="p">()):</span>
            <span class="n">new_edge</span> <span class="o">=</span> <span class="n">left_edge</span><span class="o">.</span><span class="n">move_dot_forward</span><span class="p">(</span><span class="n">right_edge</span><span class="o">.</span><span class="n">end</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert_with_backpointer</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="n">left_edge</span><span class="p">,</span> <span class="n">right_edge</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">new_edge</span>

    <span class="k">def</span> <span class="nf">_apply_incomplete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">left_edge</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">right_edge</span> <span class="ow">in</span> <span class="n">chart</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">left_edge</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span>
                                       <span class="n">is_complete</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                       <span class="n">lhs</span><span class="o">=</span><span class="n">left_edge</span><span class="o">.</span><span class="n">nextsym</span><span class="p">()):</span>
            <span class="n">new_edge</span> <span class="o">=</span> <span class="n">left_edge</span><span class="o">.</span><span class="n">move_dot_forward</span><span class="p">(</span><span class="n">right_edge</span><span class="o">.</span><span class="n">end</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert_with_backpointer</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="n">left_edge</span><span class="p">,</span> <span class="n">right_edge</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">new_edge</span>

<span class="c1">#////////////////////////////////////////////////////////////</span>
<span class="c1"># Inserting Terminal Leafs</span>
<span class="c1">#////////////////////////////////////////////////////////////</span>

<span class="k">class</span> <span class="nc">LeafInitRule</span><span class="p">(</span><span class="n">AbstractChartRule</span><span class="p">):</span>
    <span class="n">NUM_EDGES</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">chart</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()):</span>
            <span class="n">new_edge</span> <span class="o">=</span> <span class="n">LeafEdge</span><span class="p">(</span><span class="n">chart</span><span class="o">.</span><span class="n">leaf</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="n">index</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="p">()):</span>
                <span class="k">yield</span> <span class="n">new_edge</span>

<span class="c1">#////////////////////////////////////////////////////////////</span>
<span class="c1"># Top-Down Prediction</span>
<span class="c1">#////////////////////////////////////////////////////////////</span>

<span class="k">class</span> <span class="nc">TopDownInitRule</span><span class="p">(</span><span class="n">AbstractChartRule</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A rule licensing edges corresponding to the grammar productions for</span>
<span class="sd">    the grammar&#39;s start symbol.  In particular, this rule specifies that</span>
<span class="sd">    ``[S -&gt; \* alpha][0:i]`` is licensed for each grammar production</span>
<span class="sd">    ``S -&gt; alpha``, where ``S`` is the grammar&#39;s start symbol.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">NUM_EDGES</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">productions</span><span class="p">(</span><span class="n">lhs</span><span class="o">=</span><span class="n">grammar</span><span class="o">.</span><span class="n">start</span><span class="p">()):</span>
            <span class="n">new_edge</span> <span class="o">=</span> <span class="n">TreeEdge</span><span class="o">.</span><span class="n">from_production</span><span class="p">(</span><span class="n">prod</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="p">()):</span>
                <span class="k">yield</span> <span class="n">new_edge</span>

<span class="k">class</span> <span class="nc">TopDownPredictRule</span><span class="p">(</span><span class="n">AbstractChartRule</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A rule licensing edges corresponding to the grammar productions</span>
<span class="sd">    for the nonterminal following an incomplete edge&#39;s dot.  In</span>
<span class="sd">    particular, this rule specifies that</span>
<span class="sd">    ``[A -&gt; alpha \* B beta][i:j]`` licenses the edge</span>
<span class="sd">    ``[B -&gt; \* gamma][j:j]`` for each grammar production ``B -&gt; gamma``.</span>

<span class="sd">    :note: This rule corresponds to the Predictor Rule in Earley parsing.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">NUM_EDGES</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">is_complete</span><span class="p">():</span> <span class="k">return</span>
        <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">productions</span><span class="p">(</span><span class="n">lhs</span><span class="o">=</span><span class="n">edge</span><span class="o">.</span><span class="n">nextsym</span><span class="p">()):</span>
            <span class="n">new_edge</span> <span class="o">=</span> <span class="n">TreeEdge</span><span class="o">.</span><span class="n">from_production</span><span class="p">(</span><span class="n">prod</span><span class="p">,</span> <span class="n">edge</span><span class="o">.</span><span class="n">end</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="p">()):</span>
                <span class="k">yield</span> <span class="n">new_edge</span>

<span class="k">class</span> <span class="nc">CachedTopDownPredictRule</span><span class="p">(</span><span class="n">TopDownPredictRule</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A cached version of ``TopDownPredictRule``.  After the first time</span>
<span class="sd">    this rule is applied to an edge with a given ``end`` and ``next``,</span>
<span class="sd">    it will not generate any more edges for edges with that ``end`` and</span>
<span class="sd">    ``next``.</span>

<span class="sd">    If ``chart`` or ``grammar`` are changed, then the cache is flushed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">TopDownPredictRule</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_done</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">is_complete</span><span class="p">():</span> <span class="k">return</span>
        <span class="n">nextsym</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">nextsym</span><span class="p">(),</span> <span class="n">edge</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_nonterminal</span><span class="p">(</span><span class="n">nextsym</span><span class="p">):</span> <span class="k">return</span>

        <span class="c1"># If we&#39;ve already applied this rule to an edge with the same</span>
        <span class="c1"># next &amp; end, and the chart &amp; grammar have not changed, then</span>
        <span class="c1"># just return (no new edges to add).</span>
        <span class="n">done</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_done</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">nextsym</span><span class="p">,</span> <span class="n">index</span><span class="p">),</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">done</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">chart</span> <span class="ow">and</span> <span class="n">done</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="n">grammar</span><span class="p">:</span> <span class="k">return</span>

        <span class="c1"># Add all the edges indicated by the top down expand rule.</span>
        <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">productions</span><span class="p">(</span><span class="n">lhs</span><span class="o">=</span><span class="n">nextsym</span><span class="p">):</span>
            <span class="c1"># If the left corner in the predicted production is</span>
            <span class="c1"># leaf, it must match with the input.</span>
            <span class="k">if</span> <span class="n">prod</span><span class="o">.</span><span class="n">rhs</span><span class="p">():</span>
                <span class="n">first</span> <span class="o">=</span> <span class="n">prod</span><span class="o">.</span><span class="n">rhs</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">is_terminal</span><span class="p">(</span><span class="n">first</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="n">chart</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()</span> <span class="ow">or</span> <span class="n">first</span> <span class="o">!=</span> <span class="n">chart</span><span class="o">.</span><span class="n">leaf</span><span class="p">(</span><span class="n">index</span><span class="p">):</span> <span class="k">continue</span>

            <span class="n">new_edge</span> <span class="o">=</span> <span class="n">TreeEdge</span><span class="o">.</span><span class="n">from_production</span><span class="p">(</span><span class="n">prod</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="p">()):</span>
                <span class="k">yield</span> <span class="n">new_edge</span>

        <span class="c1"># Record the fact that we&#39;ve applied this rule.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_done</span><span class="p">[</span><span class="n">nextsym</span><span class="p">,</span> <span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">)</span>

<span class="c1">#////////////////////////////////////////////////////////////</span>
<span class="c1"># Bottom-Up Prediction</span>
<span class="c1">#////////////////////////////////////////////////////////////</span>

<span class="k">class</span> <span class="nc">BottomUpPredictRule</span><span class="p">(</span><span class="n">AbstractChartRule</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A rule licensing any edge corresponding to a production whose</span>
<span class="sd">    right-hand side begins with a complete edge&#39;s left-hand side.  In</span>
<span class="sd">    particular, this rule specifies that ``[A -&gt; alpha \*]`` licenses</span>
<span class="sd">    the edge ``[B -&gt; \* A beta]`` for each grammar production ``B -&gt; A beta``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">NUM_EDGES</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">is_incomplete</span><span class="p">():</span> <span class="k">return</span>
        <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">productions</span><span class="p">(</span><span class="n">rhs</span><span class="o">=</span><span class="n">edge</span><span class="o">.</span><span class="n">lhs</span><span class="p">()):</span>
            <span class="n">new_edge</span> <span class="o">=</span> <span class="n">TreeEdge</span><span class="o">.</span><span class="n">from_production</span><span class="p">(</span><span class="n">prod</span><span class="p">,</span> <span class="n">edge</span><span class="o">.</span><span class="n">start</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="p">()):</span>
                <span class="k">yield</span> <span class="n">new_edge</span>

<span class="k">class</span> <span class="nc">BottomUpPredictCombineRule</span><span class="p">(</span><span class="n">BottomUpPredictRule</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A rule licensing any edge corresponding to a production whose</span>
<span class="sd">    right-hand side begins with a complete edge&#39;s left-hand side.  In</span>
<span class="sd">    particular, this rule specifies that ``[A -&gt; alpha \*]``</span>
<span class="sd">    licenses the edge ``[B -&gt; A \* beta]`` for each grammar</span>
<span class="sd">    production ``B -&gt; A beta``.</span>

<span class="sd">    :note: This is like ``BottomUpPredictRule``, but it also applies</span>
<span class="sd">        the ``FundamentalRule`` to the resulting edge.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">NUM_EDGES</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">is_incomplete</span><span class="p">():</span> <span class="k">return</span>
        <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">productions</span><span class="p">(</span><span class="n">rhs</span><span class="o">=</span><span class="n">edge</span><span class="o">.</span><span class="n">lhs</span><span class="p">()):</span>
            <span class="n">new_edge</span> <span class="o">=</span> <span class="n">TreeEdge</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">span</span><span class="p">(),</span> <span class="n">prod</span><span class="o">.</span><span class="n">lhs</span><span class="p">(),</span> <span class="n">prod</span><span class="o">.</span><span class="n">rhs</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="p">(</span><span class="n">edge</span><span class="p">,)):</span>
                <span class="k">yield</span> <span class="n">new_edge</span>

<span class="k">class</span> <span class="nc">EmptyPredictRule</span><span class="p">(</span><span class="n">AbstractChartRule</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A rule that inserts all empty productions as passive edges,</span>
<span class="sd">    in every position in the chart.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">NUM_EDGES</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">productions</span><span class="p">(</span><span class="n">empty</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">compat</span><span class="o">.</span><span class="n">xrange</span><span class="p">(</span><span class="n">chart</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">new_edge</span> <span class="o">=</span> <span class="n">TreeEdge</span><span class="o">.</span><span class="n">from_production</span><span class="p">(</span><span class="n">prod</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="p">()):</span>
                    <span class="k">yield</span> <span class="n">new_edge</span>


<span class="c1">########################################################################</span>
<span class="c1">##  Filtered Bottom Up</span>
<span class="c1">########################################################################</span>

<span class="k">class</span> <span class="nc">FilteredSingleEdgeFundamentalRule</span><span class="p">(</span><span class="n">SingleEdgeFundamentalRule</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_apply_complete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">right_edge</span><span class="p">):</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">right_edge</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
        <span class="n">nexttoken</span> <span class="o">=</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">chart</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()</span> <span class="ow">and</span> <span class="n">chart</span><span class="o">.</span><span class="n">leaf</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">left_edge</span> <span class="ow">in</span> <span class="n">chart</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">end</span><span class="o">=</span><span class="n">right_edge</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span>
                                      <span class="n">is_complete</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                      <span class="n">nextsym</span><span class="o">=</span><span class="n">right_edge</span><span class="o">.</span><span class="n">lhs</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">_bottomup_filter</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">nexttoken</span><span class="p">,</span> <span class="n">left_edge</span><span class="o">.</span><span class="n">rhs</span><span class="p">(),</span> <span class="n">left_edge</span><span class="o">.</span><span class="n">dot</span><span class="p">()):</span>
                <span class="n">new_edge</span> <span class="o">=</span> <span class="n">left_edge</span><span class="o">.</span><span class="n">move_dot_forward</span><span class="p">(</span><span class="n">right_edge</span><span class="o">.</span><span class="n">end</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert_with_backpointer</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="n">left_edge</span><span class="p">,</span> <span class="n">right_edge</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">new_edge</span>

    <span class="k">def</span> <span class="nf">_apply_incomplete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">left_edge</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">right_edge</span> <span class="ow">in</span> <span class="n">chart</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">left_edge</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span>
                                       <span class="n">is_complete</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                       <span class="n">lhs</span><span class="o">=</span><span class="n">left_edge</span><span class="o">.</span><span class="n">nextsym</span><span class="p">()):</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">right_edge</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
            <span class="n">nexttoken</span> <span class="o">=</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">chart</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()</span> <span class="ow">and</span> <span class="n">chart</span><span class="o">.</span><span class="n">leaf</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">_bottomup_filter</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">nexttoken</span><span class="p">,</span> <span class="n">left_edge</span><span class="o">.</span><span class="n">rhs</span><span class="p">(),</span> <span class="n">left_edge</span><span class="o">.</span><span class="n">dot</span><span class="p">()):</span>
                <span class="n">new_edge</span> <span class="o">=</span> <span class="n">left_edge</span><span class="o">.</span><span class="n">move_dot_forward</span><span class="p">(</span><span class="n">right_edge</span><span class="o">.</span><span class="n">end</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert_with_backpointer</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="n">left_edge</span><span class="p">,</span> <span class="n">right_edge</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">new_edge</span>

<span class="k">class</span> <span class="nc">FilteredBottomUpPredictCombineRule</span><span class="p">(</span><span class="n">BottomUpPredictCombineRule</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">is_incomplete</span><span class="p">():</span>
            <span class="k">return</span>

        <span class="n">end</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
        <span class="n">nexttoken</span> <span class="o">=</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">chart</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()</span> <span class="ow">and</span> <span class="n">chart</span><span class="o">.</span><span class="n">leaf</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">productions</span><span class="p">(</span><span class="n">rhs</span><span class="o">=</span><span class="n">edge</span><span class="o">.</span><span class="n">lhs</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">_bottomup_filter</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">nexttoken</span><span class="p">,</span> <span class="n">prod</span><span class="o">.</span><span class="n">rhs</span><span class="p">()):</span>
                <span class="n">new_edge</span> <span class="o">=</span> <span class="n">TreeEdge</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">span</span><span class="p">(),</span> <span class="n">prod</span><span class="o">.</span><span class="n">lhs</span><span class="p">(),</span> <span class="n">prod</span><span class="o">.</span><span class="n">rhs</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="p">(</span><span class="n">edge</span><span class="p">,)):</span>
                    <span class="k">yield</span> <span class="n">new_edge</span>

<span class="k">def</span> <span class="nf">_bottomup_filter</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">nexttoken</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">dot</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">dot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="n">_next</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">[</span><span class="n">dot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">is_terminal</span><span class="p">(</span><span class="n">_next</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nexttoken</span> <span class="o">==</span> <span class="n">_next</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">grammar</span><span class="o">.</span><span class="n">is_leftcorner</span><span class="p">(</span><span class="n">_next</span><span class="p">,</span> <span class="n">nexttoken</span><span class="p">)</span>


<span class="c1">########################################################################</span>
<span class="c1">##  Generic Chart Parser</span>
<span class="c1">########################################################################</span>

<span class="n">TD_STRATEGY</span> <span class="o">=</span> <span class="p">[</span><span class="n">LeafInitRule</span><span class="p">(),</span>
               <span class="n">TopDownInitRule</span><span class="p">(),</span>
               <span class="n">CachedTopDownPredictRule</span><span class="p">(),</span>
               <span class="n">SingleEdgeFundamentalRule</span><span class="p">()]</span>
<span class="n">BU_STRATEGY</span> <span class="o">=</span> <span class="p">[</span><span class="n">LeafInitRule</span><span class="p">(),</span>
               <span class="n">EmptyPredictRule</span><span class="p">(),</span>
               <span class="n">BottomUpPredictRule</span><span class="p">(),</span>
               <span class="n">SingleEdgeFundamentalRule</span><span class="p">()]</span>
<span class="n">BU_LC_STRATEGY</span> <span class="o">=</span> <span class="p">[</span><span class="n">LeafInitRule</span><span class="p">(),</span>
                  <span class="n">EmptyPredictRule</span><span class="p">(),</span>
                  <span class="n">BottomUpPredictCombineRule</span><span class="p">(),</span>
                  <span class="n">SingleEdgeFundamentalRule</span><span class="p">()]</span>

<span class="n">LC_STRATEGY</span> <span class="o">=</span> <span class="p">[</span><span class="n">LeafInitRule</span><span class="p">(),</span>
               <span class="n">FilteredBottomUpPredictCombineRule</span><span class="p">(),</span>
               <span class="n">FilteredSingleEdgeFundamentalRule</span><span class="p">()]</span>

<div class="viewcode-block" id="ChartParser"><a class="viewcode-back" href="../../../generated/generated/nltk.ChartParser.html#nltk.ChartParser">[docs]</a><span class="k">class</span> <span class="nc">ChartParser</span><span class="p">(</span><span class="n">ParserI</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A generic chart parser.  A &quot;strategy&quot;, or list of</span>
<span class="sd">    ``ChartRuleI`` instances, is used to decide what edges to add to</span>
<span class="sd">    the chart.  In particular, ``ChartParser`` uses the following</span>
<span class="sd">    algorithm to parse texts:</span>

<span class="sd">    | Until no new edges are added:</span>
<span class="sd">    |   For each *rule* in *strategy*:</span>
<span class="sd">    |     Apply *rule* to any applicable edges in the chart.</span>
<span class="sd">    | Return any complete parses in the chart</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="ChartParser.__init__"><a class="viewcode-back" href="../../../generated/generated/nltk.ChartParser.__init__.html#nltk.ChartParser.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="n">BU_LC_STRATEGY</span><span class="p">,</span> <span class="n">trace</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="n">trace_chart_width</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">use_agenda</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">chart_class</span><span class="o">=</span><span class="n">Chart</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new chart parser, that uses ``grammar`` to parse</span>
<span class="sd">        texts.</span>

<span class="sd">        :type grammar: CFG</span>
<span class="sd">        :param grammar: The grammar used to parse texts.</span>
<span class="sd">        :type strategy: list(ChartRuleI)</span>
<span class="sd">        :param strategy: A list of rules that should be used to decide</span>
<span class="sd">            what edges to add to the chart (top-down strategy by default).</span>
<span class="sd">        :type trace: int</span>
<span class="sd">        :param trace: The level of tracing that should be used when</span>
<span class="sd">            parsing a text.  ``0`` will generate no tracing output;</span>
<span class="sd">            and higher numbers will produce more verbose tracing</span>
<span class="sd">            output.</span>
<span class="sd">        :type trace_chart_width: int</span>
<span class="sd">        :param trace_chart_width: The default total width reserved for</span>
<span class="sd">            the chart in trace output.  The remainder of each line will</span>
<span class="sd">            be used to display edges.</span>
<span class="sd">        :type use_agenda: bool</span>
<span class="sd">        :param use_agenda: Use an optimized agenda-based algorithm,</span>
<span class="sd">            if possible.</span>
<span class="sd">        :param chart_class: The class that should be used to create</span>
<span class="sd">            the parse charts.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span> <span class="o">=</span> <span class="n">grammar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_strategy</span> <span class="o">=</span> <span class="n">strategy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trace</span> <span class="o">=</span> <span class="n">trace</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trace_chart_width</span> <span class="o">=</span> <span class="n">trace_chart_width</span>
        <span class="c1"># If the strategy only consists of axioms (NUM_EDGES==0) and</span>
        <span class="c1"># inference rules (NUM_EDGES==1), we can use an agenda-based algorithm:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_use_agenda</span> <span class="o">=</span> <span class="n">use_agenda</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_chart_class</span> <span class="o">=</span> <span class="n">chart_class</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_axioms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inference_rules</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">strategy</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rule</span><span class="o">.</span><span class="n">NUM_EDGES</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_axioms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rule</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">rule</span><span class="o">.</span><span class="n">NUM_EDGES</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_inference_rules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rule</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_use_agenda</span> <span class="o">=</span> <span class="bp">False</span></div>

<div class="viewcode-block" id="ChartParser.grammar"><a class="viewcode-back" href="../../../generated/generated/nltk.ChartParser.grammar.html#nltk.ChartParser.grammar">[docs]</a>    <span class="k">def</span> <span class="nf">grammar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span></div>

    <span class="k">def</span> <span class="nf">_trace_new_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="n">new_edges</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">edge_width</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">trace</span><span class="p">:</span> <span class="k">return</span>
        <span class="n">print_rule_header</span> <span class="o">=</span> <span class="n">trace</span> <span class="o">&gt;</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">new_edges</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">print_rule_header</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">:&#39;</span> <span class="o">%</span> <span class="n">rule</span><span class="p">)</span>
                <span class="n">print_rule_header</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">print</span><span class="p">(</span><span class="n">chart</span><span class="o">.</span><span class="n">pretty_format_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">edge_width</span><span class="p">))</span>

<div class="viewcode-block" id="ChartParser.chart_parse"><a class="viewcode-back" href="../../../generated/generated/nltk.ChartParser.chart_parse.html#nltk.ChartParser.chart_parse">[docs]</a>    <span class="k">def</span> <span class="nf">chart_parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">,</span> <span class="n">trace</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the final parse ``Chart`` from which all possible</span>
<span class="sd">        parse trees can be extracted.</span>

<span class="sd">        :param tokens: The sentence to be parsed</span>
<span class="sd">        :type tokens: list(str)</span>
<span class="sd">        :rtype: Chart</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">trace</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="n">trace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trace</span>
        <span class="n">trace_new_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trace_new_edges</span>

        <span class="n">tokens</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span><span class="o">.</span><span class="n">check_coverage</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
        <span class="n">chart</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chart_class</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
        <span class="n">grammar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span>

        <span class="c1"># Width, for printing trace edges.</span>
        <span class="n">trace_edge_width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trace_chart_width</span> <span class="o">//</span> <span class="p">(</span><span class="n">chart</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">trace</span><span class="p">:</span> <span class="k">print</span><span class="p">(</span><span class="n">chart</span><span class="o">.</span><span class="n">pretty_format_leaves</span><span class="p">(</span><span class="n">trace_edge_width</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_agenda</span><span class="p">:</span>
            <span class="c1"># Use an agenda-based algorithm.</span>
            <span class="k">for</span> <span class="n">axiom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axioms</span><span class="p">:</span>
                <span class="n">new_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">axiom</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">))</span>
                <span class="n">trace_new_edges</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">axiom</span><span class="p">,</span> <span class="n">new_edges</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">trace_edge_width</span><span class="p">)</span>

            <span class="n">inference_rules</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inference_rules</span>
            <span class="n">agenda</span> <span class="o">=</span> <span class="n">chart</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
            <span class="c1"># We reverse the initial agenda, since it is a stack</span>
            <span class="c1"># but chart.edges() functions as a queue.</span>
            <span class="n">agenda</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="k">while</span> <span class="n">agenda</span><span class="p">:</span>
                <span class="n">edge</span> <span class="o">=</span> <span class="n">agenda</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">inference_rules</span><span class="p">:</span>
                    <span class="n">new_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">rule</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">edge</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">trace</span><span class="p">:</span>
                        <span class="n">trace_new_edges</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="n">new_edges</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">trace_edge_width</span><span class="p">)</span>
                    <span class="n">agenda</span> <span class="o">+=</span> <span class="n">new_edges</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Do not use an agenda-based algorithm.</span>
            <span class="n">edges_added</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">while</span> <span class="n">edges_added</span><span class="p">:</span>
                <span class="n">edges_added</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strategy</span><span class="p">:</span>
                    <span class="n">new_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">rule</span><span class="o">.</span><span class="n">apply_everywhere</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">))</span>
                    <span class="n">edges_added</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_edges</span><span class="p">)</span>
                    <span class="n">trace_new_edges</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="n">new_edges</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">trace_edge_width</span><span class="p">)</span>

        <span class="c1"># Return the final chart.</span>
        <span class="k">return</span> <span class="n">chart</span></div>

<div class="viewcode-block" id="ChartParser.parse"><a class="viewcode-back" href="../../../generated/generated/nltk.ChartParser.parse.html#nltk.ChartParser.parse">[docs]</a>    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">,</span> <span class="n">tree_class</span><span class="o">=</span><span class="n">Tree</span><span class="p">):</span>
        <span class="n">chart</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chart_parse</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="n">chart</span><span class="o">.</span><span class="n">parses</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">tree_class</span><span class="o">=</span><span class="n">tree_class</span><span class="p">))</span></div></div>

<div class="viewcode-block" id="TopDownChartParser"><a class="viewcode-back" href="../../../generated/generated/nltk.TopDownChartParser.html#nltk.TopDownChartParser">[docs]</a><span class="k">class</span> <span class="nc">TopDownChartParser</span><span class="p">(</span><span class="n">ChartParser</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A ``ChartParser`` using a top-down parsing strategy.</span>
<span class="sd">    See ``ChartParser`` for more information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="TopDownChartParser.__init__"><a class="viewcode-back" href="../../../generated/generated/nltk.TopDownChartParser.__init__.html#nltk.TopDownChartParser.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="o">**</span><span class="n">parser_args</span><span class="p">):</span>
        <span class="n">ChartParser</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">TD_STRATEGY</span><span class="p">,</span> <span class="o">**</span><span class="n">parser_args</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="BottomUpChartParser"><a class="viewcode-back" href="../../../generated/generated/nltk.BottomUpChartParser.html#nltk.BottomUpChartParser">[docs]</a><span class="k">class</span> <span class="nc">BottomUpChartParser</span><span class="p">(</span><span class="n">ChartParser</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A ``ChartParser`` using a bottom-up parsing strategy.</span>
<span class="sd">    See ``ChartParser`` for more information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="BottomUpChartParser.__init__"><a class="viewcode-back" href="../../../generated/generated/nltk.BottomUpChartParser.__init__.html#nltk.BottomUpChartParser.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="o">**</span><span class="n">parser_args</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">PCFG</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;BottomUpChartParser only works for CFG, &quot;</span>
                          <span class="s2">&quot;use BottomUpProbabilisticChartParser instead&quot;</span><span class="p">,</span>
                          <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="n">ChartParser</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">BU_STRATEGY</span><span class="p">,</span> <span class="o">**</span><span class="n">parser_args</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="BottomUpLeftCornerChartParser"><a class="viewcode-back" href="../../../generated/generated/nltk.BottomUpLeftCornerChartParser.html#nltk.BottomUpLeftCornerChartParser">[docs]</a><span class="k">class</span> <span class="nc">BottomUpLeftCornerChartParser</span><span class="p">(</span><span class="n">ChartParser</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A ``ChartParser`` using a bottom-up left-corner parsing strategy.</span>
<span class="sd">    This strategy is often more efficient than standard bottom-up.</span>
<span class="sd">    See ``ChartParser`` for more information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="BottomUpLeftCornerChartParser.__init__"><a class="viewcode-back" href="../../../generated/generated/nltk.BottomUpLeftCornerChartParser.__init__.html#nltk.BottomUpLeftCornerChartParser.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="o">**</span><span class="n">parser_args</span><span class="p">):</span>
        <span class="n">ChartParser</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">BU_LC_STRATEGY</span><span class="p">,</span> <span class="o">**</span><span class="n">parser_args</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="LeftCornerChartParser"><a class="viewcode-back" href="../../../generated/generated/nltk.LeftCornerChartParser.html#nltk.LeftCornerChartParser">[docs]</a><span class="k">class</span> <span class="nc">LeftCornerChartParser</span><span class="p">(</span><span class="n">ChartParser</span><span class="p">):</span>
<div class="viewcode-block" id="LeftCornerChartParser.__init__"><a class="viewcode-back" href="../../../generated/generated/nltk.LeftCornerChartParser.__init__.html#nltk.LeftCornerChartParser.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="o">**</span><span class="n">parser_args</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">grammar</span><span class="o">.</span><span class="n">is_nonempty</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;LeftCornerParser only works for grammars &quot;</span>
                             <span class="s2">&quot;without empty productions.&quot;</span><span class="p">)</span>
        <span class="n">ChartParser</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">LC_STRATEGY</span><span class="p">,</span> <span class="o">**</span><span class="n">parser_args</span><span class="p">)</span></div></div>

<span class="c1">########################################################################</span>
<span class="c1">##  Stepping Chart Parser</span>
<span class="c1">########################################################################</span>

<div class="viewcode-block" id="SteppingChartParser"><a class="viewcode-back" href="../../../generated/generated/nltk.SteppingChartParser.html#nltk.SteppingChartParser">[docs]</a><span class="k">class</span> <span class="nc">SteppingChartParser</span><span class="p">(</span><span class="n">ChartParser</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A ``ChartParser`` that allows you to step through the parsing</span>
<span class="sd">    process, adding a single edge at a time.  It also allows you to</span>
<span class="sd">    change the parser&#39;s strategy or grammar midway through parsing a</span>
<span class="sd">    text.</span>

<span class="sd">    The ``initialize`` method is used to start parsing a text.  ``step``</span>
<span class="sd">    adds a single edge to the chart.  ``set_strategy`` changes the</span>
<span class="sd">    strategy used by the chart parser.  ``parses`` returns the set of</span>
<span class="sd">    parses that has been found by the chart parser.</span>

<span class="sd">    :ivar _restart: Records whether the parser&#39;s strategy, grammar,</span>
<span class="sd">        or chart has been changed.  If so, then ``step`` must restart</span>
<span class="sd">        the parsing algorithm.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="SteppingChartParser.__init__"><a class="viewcode-back" href="../../../generated/generated/nltk.SteppingChartParser.__init__.html#nltk.SteppingChartParser.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="p">[],</span> <span class="n">trace</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_chart</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_chartrule</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">ChartParser</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">strategy</span><span class="p">,</span> <span class="n">trace</span><span class="p">)</span></div>

    <span class="c1">#////////////////////////////////////////////////////////////</span>
    <span class="c1"># Initialization</span>
    <span class="c1">#////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="SteppingChartParser.initialize"><a class="viewcode-back" href="../../../generated/generated/nltk.SteppingChartParser.initialize.html#nltk.SteppingChartParser.initialize">[docs]</a>    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
        <span class="s2">&quot;Begin parsing the given tokens.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_chart</span> <span class="o">=</span> <span class="n">Chart</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">tokens</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span> <span class="o">=</span> <span class="bp">True</span></div>

    <span class="c1">#////////////////////////////////////////////////////////////</span>
    <span class="c1"># Stepping</span>
    <span class="c1">#////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="SteppingChartParser.step"><a class="viewcode-back" href="../../../generated/generated/nltk.SteppingChartParser.step.html#nltk.SteppingChartParser.step">[docs]</a>    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a generator that adds edges to the chart, one at a</span>
<span class="sd">        time.  Each time the generator is resumed, it adds a single</span>
<span class="sd">        edge and yields that edge.  If no more edges can be added,</span>
<span class="sd">        then it yields None.</span>

<span class="sd">        If the parser&#39;s strategy, grammar, or chart is changed, then</span>
<span class="sd">        the generator will continue adding edges using the new</span>
<span class="sd">        strategy, grammar, or chart.</span>

<span class="sd">        Note that this generator never terminates, since the grammar</span>
<span class="sd">        or strategy might be changed to values that would add new</span>
<span class="sd">        edges.  Instead, it yields None when no more edges can be</span>
<span class="sd">        added with the current strategy and grammar.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chart</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Parser must be initialized first&#39;</span><span class="p">)</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">w</span> <span class="o">=</span> <span class="mi">50</span> <span class="o">//</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_chart</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse</span><span class="p">():</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trace</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> <span class="k">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_chartrule</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trace</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="k">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_chart</span><span class="o">.</span><span class="n">pretty_format_edge</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">w</span><span class="p">))</span>
                <span class="k">yield</span> <span class="n">e</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span><span class="p">:</span> <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield</span> <span class="bp">None</span> <span class="c1"># No more edges.</span></div>

    <span class="k">def</span> <span class="nf">_parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A generator that implements the actual parsing algorithm.</span>
<span class="sd">        ``step`` iterates through this generator, and restarts it</span>
<span class="sd">        whenever the parser&#39;s strategy, grammar, or chart is modified.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">chart</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chart</span>
        <span class="n">grammar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span>
        <span class="n">edges_added</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">edges_added</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">edges_added</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strategy</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_current_chartrule</span> <span class="o">=</span> <span class="n">rule</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">rule</span><span class="o">.</span><span class="n">apply_everywhere</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">):</span>
                    <span class="n">edges_added</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">yield</span> <span class="n">e</span>

    <span class="c1">#////////////////////////////////////////////////////////////</span>
    <span class="c1"># Accessors</span>
    <span class="c1">#////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="SteppingChartParser.strategy"><a class="viewcode-back" href="../../../generated/generated/nltk.SteppingChartParser.strategy.html#nltk.SteppingChartParser.strategy">[docs]</a>    <span class="k">def</span> <span class="nf">strategy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Return the strategy used by this parser.&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strategy</span></div>

<div class="viewcode-block" id="SteppingChartParser.grammar"><a class="viewcode-back" href="../../../generated/generated/nltk.SteppingChartParser.grammar.html#nltk.SteppingChartParser.grammar">[docs]</a>    <span class="k">def</span> <span class="nf">grammar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Return the grammar used by this parser.&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span></div>

<div class="viewcode-block" id="SteppingChartParser.chart"><a class="viewcode-back" href="../../../generated/generated/nltk.SteppingChartParser.chart.html#nltk.SteppingChartParser.chart">[docs]</a>    <span class="k">def</span> <span class="nf">chart</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Return the chart that is used by this parser.&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chart</span></div>

<div class="viewcode-block" id="SteppingChartParser.current_chartrule"><a class="viewcode-back" href="../../../generated/generated/nltk.SteppingChartParser.current_chartrule.html#nltk.SteppingChartParser.current_chartrule">[docs]</a>    <span class="k">def</span> <span class="nf">current_chartrule</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Return the chart rule used to generate the most recent edge.&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_chartrule</span></div>

<div class="viewcode-block" id="SteppingChartParser.parses"><a class="viewcode-back" href="../../../generated/generated/nltk.SteppingChartParser.parses.html#nltk.SteppingChartParser.parses">[docs]</a>    <span class="k">def</span> <span class="nf">parses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree_class</span><span class="o">=</span><span class="n">Tree</span><span class="p">):</span>
        <span class="s2">&quot;Return the parse trees currently contained in the chart.&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chart</span><span class="o">.</span><span class="n">parses</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">tree_class</span><span class="p">)</span></div>

    <span class="c1">#////////////////////////////////////////////////////////////</span>
    <span class="c1"># Parser modification</span>
    <span class="c1">#////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="SteppingChartParser.set_strategy"><a class="viewcode-back" href="../../../generated/generated/nltk.SteppingChartParser.set_strategy.html#nltk.SteppingChartParser.set_strategy">[docs]</a>    <span class="k">def</span> <span class="nf">set_strategy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strategy</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change the strategy that the parser uses to decide which edges</span>
<span class="sd">        to add to the chart.</span>

<span class="sd">        :type strategy: list(ChartRuleI)</span>
<span class="sd">        :param strategy: A list of rules that should be used to decide</span>
<span class="sd">            what edges to add to the chart.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">strategy</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strategy</span><span class="p">:</span> <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_strategy</span> <span class="o">=</span> <span class="n">strategy</span><span class="p">[:]</span> <span class="c1"># Make a copy.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span> <span class="o">=</span> <span class="bp">True</span></div>

<div class="viewcode-block" id="SteppingChartParser.set_grammar"><a class="viewcode-back" href="../../../generated/generated/nltk.SteppingChartParser.set_grammar.html#nltk.SteppingChartParser.set_grammar">[docs]</a>    <span class="k">def</span> <span class="nf">set_grammar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">):</span>
        <span class="s2">&quot;Change the grammar used by the parser.&quot;</span>
        <span class="k">if</span> <span class="n">grammar</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span><span class="p">:</span> <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span> <span class="o">=</span> <span class="n">grammar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span> <span class="o">=</span> <span class="bp">True</span></div>

<div class="viewcode-block" id="SteppingChartParser.set_chart"><a class="viewcode-back" href="../../../generated/generated/nltk.SteppingChartParser.set_chart.html#nltk.SteppingChartParser.set_chart">[docs]</a>    <span class="k">def</span> <span class="nf">set_chart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">):</span>
        <span class="s2">&quot;Load a given chart into the chart parser.&quot;</span>
        <span class="k">if</span> <span class="n">chart</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chart</span><span class="p">:</span> <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_chart</span> <span class="o">=</span> <span class="n">chart</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span> <span class="o">=</span> <span class="bp">True</span></div>

    <span class="c1">#////////////////////////////////////////////////////////////</span>
    <span class="c1"># Standard parser methods</span>
    <span class="c1">#////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="SteppingChartParser.parse"><a class="viewcode-back" href="../../../generated/generated/nltk.SteppingChartParser.parse.html#nltk.SteppingChartParser.parse">[docs]</a>    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">,</span> <span class="n">tree_class</span><span class="o">=</span><span class="n">Tree</span><span class="p">):</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span><span class="o">.</span><span class="n">check_coverage</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>

        <span class="c1"># Initialize ourselves.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>

        <span class="c1"># Step until no more edges are generated.</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">e</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="k">break</span>

        <span class="c1"># Return an iterator of complete parses.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parses</span><span class="p">(</span><span class="n">tree_class</span><span class="o">=</span><span class="n">tree_class</span><span class="p">)</span></div></div>

<span class="c1">########################################################################</span>
<span class="c1">##  Demo Code</span>
<span class="c1">########################################################################</span>

<span class="k">def</span> <span class="nf">demo_grammar</span><span class="p">():</span>
    <span class="kn">from</span> <span class="nn">nltk.grammar</span> <span class="kn">import</span> <span class="n">CFG</span>
    <span class="k">return</span> <span class="n">CFG</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">S  -&gt; NP VP</span>
<span class="s2">PP -&gt; &quot;with&quot; NP</span>
<span class="s2">NP -&gt; NP PP</span>
<span class="s2">VP -&gt; VP PP</span>
<span class="s2">VP -&gt; Verb NP</span>
<span class="s2">VP -&gt; Verb</span>
<span class="s2">NP -&gt; Det Noun</span>
<span class="s2">NP -&gt; &quot;John&quot;</span>
<span class="s2">NP -&gt; &quot;I&quot;</span>
<span class="s2">Det -&gt; &quot;the&quot;</span>
<span class="s2">Det -&gt; &quot;my&quot;</span>
<span class="s2">Det -&gt; &quot;a&quot;</span>
<span class="s2">Noun -&gt; &quot;dog&quot;</span>
<span class="s2">Noun -&gt; &quot;cookie&quot;</span>
<span class="s2">Verb -&gt; &quot;ate&quot;</span>
<span class="s2">Verb -&gt; &quot;saw&quot;</span>
<span class="s2">Prep -&gt; &quot;with&quot;</span>
<span class="s2">Prep -&gt; &quot;under&quot;</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">demo</span><span class="p">(</span><span class="n">choice</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
         <span class="n">print_times</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">print_grammar</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
         <span class="n">print_trees</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">trace</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
         <span class="n">sent</span><span class="o">=</span><span class="s1">&#39;I saw John with a dog with my cookie&#39;</span><span class="p">,</span> <span class="n">numparses</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A demonstration of the chart parsers.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">time</span>
    <span class="kn">from</span> <span class="nn">nltk</span> <span class="kn">import</span> <span class="n">nonterminals</span><span class="p">,</span> <span class="n">Production</span><span class="p">,</span> <span class="n">CFG</span>

    <span class="c1"># The grammar for ChartParser and SteppingChartParser:</span>
    <span class="n">grammar</span> <span class="o">=</span> <span class="n">demo_grammar</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">print_grammar</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;* Grammar&quot;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">grammar</span><span class="p">)</span>

    <span class="c1"># Tokenize the sample sentence.</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;* Sentence:&quot;</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">sent</span><span class="p">)</span>
    <span class="n">tokens</span> <span class="o">=</span> <span class="n">sent</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
    <span class="k">print</span><span class="p">()</span>

    <span class="c1"># Ask the user which parser to test,</span>
    <span class="c1"># if the parser wasn&#39;t provided as an argument</span>
    <span class="k">if</span> <span class="n">choice</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;  1: Top-down chart parser&#39;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;  2: Bottom-up chart parser&#39;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;  3: Bottom-up left-corner chart parser&#39;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;  4: Left-corner chart parser with bottom-up filter&#39;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;  5: Stepping chart parser (alternating top-down &amp; bottom-up)&#39;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;  6: All parsers&#39;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Which parser (1-6)? &#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
        <span class="n">choice</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">print</span><span class="p">()</span>

    <span class="n">choice</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">choice</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">choice</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s2">&quot;123456&quot;</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Bad parser number&#39;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="c1"># Keep track of how long each parser takes.</span>
    <span class="n">times</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">strategies</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;Top-down&#39;</span><span class="p">,</span> <span class="n">TD_STRATEGY</span><span class="p">),</span>
                  <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;Bottom-up&#39;</span><span class="p">,</span> <span class="n">BU_STRATEGY</span><span class="p">),</span>
                  <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;Bottom-up left-corner&#39;</span><span class="p">,</span> <span class="n">BU_LC_STRATEGY</span><span class="p">),</span>
                  <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;Filtered left-corner&#39;</span><span class="p">,</span> <span class="n">LC_STRATEGY</span><span class="p">)}</span>
    <span class="n">choices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">choice</span> <span class="ow">in</span> <span class="n">strategies</span><span class="p">:</span> <span class="n">choices</span> <span class="o">=</span> <span class="p">[</span><span class="n">choice</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">choice</span><span class="o">==</span><span class="s1">&#39;6&#39;</span><span class="p">:</span> <span class="n">choices</span> <span class="o">=</span> <span class="s2">&quot;1234&quot;</span>

    <span class="c1"># Run the requested chart parser(s), except the stepping parser.</span>
    <span class="k">for</span> <span class="n">strategy</span> <span class="ow">in</span> <span class="n">choices</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;* Strategy: &quot;</span> <span class="o">+</span> <span class="n">strategies</span><span class="p">[</span><span class="n">strategy</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">print</span><span class="p">()</span>
        <span class="n">cp</span> <span class="o">=</span> <span class="n">ChartParser</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">strategies</span><span class="p">[</span><span class="n">strategy</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">trace</span><span class="o">=</span><span class="n">trace</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">chart</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">chart_parse</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
        <span class="n">parses</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">chart</span><span class="o">.</span><span class="n">parses</span><span class="p">(</span><span class="n">grammar</span><span class="o">.</span><span class="n">start</span><span class="p">()))</span>
        
        <span class="n">times</span><span class="p">[</span><span class="n">strategies</span><span class="p">[</span><span class="n">strategy</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">t</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Nr edges in chart:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">chart</span><span class="o">.</span><span class="n">edges</span><span class="p">()))</span>
        <span class="k">if</span> <span class="n">numparses</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">parses</span><span class="p">)</span><span class="o">==</span><span class="n">numparses</span><span class="p">,</span> <span class="s1">&#39;Not all parses found&#39;</span>
        <span class="k">if</span> <span class="n">print_trees</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">parses</span><span class="p">:</span> <span class="k">print</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Nr trees:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">parses</span><span class="p">))</span>
        <span class="k">print</span><span class="p">()</span>

    <span class="c1"># Run the stepping parser, if requested.</span>
    <span class="k">if</span> <span class="n">choice</span> <span class="ow">in</span> <span class="s2">&quot;56&quot;</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;* Strategy: Stepping (top-down vs bottom-up)&quot;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">()</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">cp</span> <span class="o">=</span> <span class="n">SteppingChartParser</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">trace</span><span class="o">=</span><span class="n">trace</span><span class="p">)</span>
        <span class="n">cp</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;*** SWITCH TO TOP DOWN&#39;</span><span class="p">)</span>
            <span class="n">cp</span><span class="o">.</span><span class="n">set_strategy</span><span class="p">(</span><span class="n">TD_STRATEGY</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">step</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">j</span><span class="o">&gt;</span><span class="mi">20</span> <span class="ow">or</span> <span class="n">e</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="k">break</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;*** SWITCH TO BOTTOM UP&#39;</span><span class="p">)</span>
            <span class="n">cp</span><span class="o">.</span><span class="n">set_strategy</span><span class="p">(</span><span class="n">BU_STRATEGY</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">step</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">j</span><span class="o">&gt;</span><span class="mi">20</span> <span class="ow">or</span> <span class="n">e</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="k">break</span>
        <span class="n">times</span><span class="p">[</span><span class="s1">&#39;Stepping&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">t</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Nr edges in chart:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">chart</span><span class="p">()</span><span class="o">.</span><span class="n">edges</span><span class="p">()))</span>
        <span class="k">if</span> <span class="n">numparses</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">parses</span><span class="p">()))</span><span class="o">==</span><span class="n">numparses</span><span class="p">,</span> <span class="s1">&#39;Not all parses found&#39;</span>
        <span class="k">if</span> <span class="n">print_trees</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">cp</span><span class="o">.</span><span class="n">parses</span><span class="p">():</span> <span class="k">print</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Nr trees:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">parses</span><span class="p">())))</span>
        <span class="k">print</span><span class="p">()</span>

    <span class="c1"># Print the times of all parsers:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">print_times</span> <span class="ow">and</span> <span class="n">times</span><span class="p">):</span> <span class="k">return</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;* Parsing times&quot;</span><span class="p">)</span>
    <span class="k">print</span><span class="p">()</span>
    <span class="n">maxlen</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">times</span><span class="p">)</span>
    <span class="n">format</span> <span class="o">=</span> <span class="s1">&#39;%&#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">maxlen</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;s parser: </span><span class="si">%6.3f</span><span class="s1">sec&#39;</span>
    <span class="n">times_items</span> <span class="o">=</span> <span class="n">times</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">parser</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">times_items</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">format</span> <span class="o">%</span> <span class="p">(</span><span class="n">parser</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">demo</span><span class="p">()</span>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../../_static/copybutton.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>