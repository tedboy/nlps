

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>nltk.sem.logic</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="" href="../../../index.html"/>
        <link rel="up" title="nltk" href="../../nltk.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> NLP APIs
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../gensim_tutorial/tutorial.html">Gensim Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../nltk_intro.html">Natural Language Toolkit</a></li>
</ul>
<p class="caption"><span class="caption-text">Autogenerated API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/nltk.html"><code class="docutils literal"><span class="pre">nltk</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.html"><code class="docutils literal"><span class="pre">gensim</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.interfaces.html"><code class="docutils literal"><span class="pre">gensim.interfaces</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.matutils.html"><code class="docutils literal"><span class="pre">gensim.matutils</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.utils.html"><code class="docutils literal"><span class="pre">gensim.utils</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.corpora.html"><code class="docutils literal"><span class="pre">gensim.corpora</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.models.html"><code class="docutils literal"><span class="pre">gensim.models</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.parsing.html"><code class="docutils literal"><span class="pre">gensim.parsing</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.scripts.html"><code class="docutils literal"><span class="pre">gensim.scripts</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.similarities.html"><code class="docutils literal"><span class="pre">gensim.similarities</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.summarization.html"><code class="docutils literal"><span class="pre">gensim.summarization</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.topic_coherence.html"><code class="docutils literal"><span class="pre">gensim.topic_coherence</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/simserver.html"><code class="docutils literal"><span class="pre">simserver</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/word2vec.html"><code class="docutils literal"><span class="pre">word2vec</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/stop_words.html"><code class="docutils literal"><span class="pre">stop_words</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/nltk.classify.html"><code class="docutils literal"><span class="pre">nltk.classify</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/nltk.cluster.html"><code class="docutils literal"><span class="pre">nltk.cluster</span></code></a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">NLP APIs</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          













<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../nltk.html">nltk</a> &raquo;</li>
        
      <li>nltk.sem.logic</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for nltk.sem.logic</h1><div class="highlight"><pre>
<span></span><span class="c1"># Natural Language Toolkit: Logic</span>
<span class="c1">#</span>
<span class="c1"># Author: Dan Garrette &lt;dhgarrette@gmail.com&gt;</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2001-2015 NLTK Project</span>
<span class="c1"># URL: &lt;http://nltk.org&gt;</span>
<span class="c1"># For license information, see LICENSE.TXT</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">A version of first order predicate logic, built on</span>
<span class="sd">top of the typed lambda calculus.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">unicode_literals</span>

<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="nb">reduce</span>

<span class="kn">from</span> <span class="nn">nltk.util</span> <span class="kn">import</span> <span class="n">Trie</span>
<span class="kn">from</span> <span class="nn">nltk.internals</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="kn">from</span> <span class="nn">nltk.compat</span> <span class="kn">import</span> <span class="p">(</span><span class="n">total_ordering</span><span class="p">,</span> <span class="n">string_types</span><span class="p">,</span>
                         <span class="n">python_2_unicode_compatible</span><span class="p">)</span>

<span class="n">APP</span> <span class="o">=</span> <span class="s1">&#39;APP&#39;</span>

<span class="n">_counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">Tokens</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">LAMBDA</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">;</span>     <span class="n">LAMBDA_LIST</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">]</span>

    <span class="c1">#Quantifiers</span>
    <span class="n">EXISTS</span> <span class="o">=</span> <span class="s1">&#39;exists&#39;</span><span class="p">;</span> <span class="n">EXISTS_LIST</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;some&#39;</span><span class="p">,</span> <span class="s1">&#39;exists&#39;</span><span class="p">,</span> <span class="s1">&#39;exist&#39;</span><span class="p">]</span>
    <span class="n">ALL</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span><span class="p">;</span>       <span class="n">ALL_LIST</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;forall&#39;</span><span class="p">]</span>

    <span class="c1">#Punctuation</span>
    <span class="n">DOT</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span>
    <span class="n">OPEN</span> <span class="o">=</span> <span class="s1">&#39;(&#39;</span>
    <span class="n">CLOSE</span> <span class="o">=</span> <span class="s1">&#39;)&#39;</span>
    <span class="n">COMMA</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span>

    <span class="c1">#Operations</span>
    <span class="n">NOT</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span><span class="p">;</span>         <span class="n">NOT_LIST</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;not&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;!&#39;</span><span class="p">]</span>
    <span class="n">AND</span> <span class="o">=</span> <span class="s1">&#39;&amp;&#39;</span><span class="p">;</span>         <span class="n">AND_LIST</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;and&#39;</span><span class="p">,</span> <span class="s1">&#39;&amp;&#39;</span><span class="p">,</span> <span class="s1">&#39;^&#39;</span><span class="p">]</span>
    <span class="n">OR</span> <span class="o">=</span> <span class="s1">&#39;|&#39;</span><span class="p">;</span>          <span class="n">OR_LIST</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;or&#39;</span><span class="p">,</span> <span class="s1">&#39;|&#39;</span><span class="p">]</span>
    <span class="n">IMP</span> <span class="o">=</span> <span class="s1">&#39;-&gt;&#39;</span><span class="p">;</span>        <span class="n">IMP_LIST</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;implies&#39;</span><span class="p">,</span> <span class="s1">&#39;-&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;=&gt;&#39;</span><span class="p">]</span>
    <span class="n">IFF</span> <span class="o">=</span> <span class="s1">&#39;&lt;-&gt;&#39;</span><span class="p">;</span>       <span class="n">IFF_LIST</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;iff&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;-&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;=&gt;&#39;</span><span class="p">]</span>
    <span class="n">EQ</span> <span class="o">=</span> <span class="s1">&#39;=&#39;</span><span class="p">;</span>          <span class="n">EQ_LIST</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="s1">&#39;==&#39;</span><span class="p">]</span>
    <span class="n">NEQ</span> <span class="o">=</span> <span class="s1">&#39;!=&#39;</span><span class="p">;</span>        <span class="n">NEQ_LIST</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;!=&#39;</span><span class="p">]</span>

    <span class="c1">#Collections of tokens</span>
    <span class="n">BINOPS</span> <span class="o">=</span> <span class="n">AND_LIST</span> <span class="o">+</span> <span class="n">OR_LIST</span> <span class="o">+</span> <span class="n">IMP_LIST</span> <span class="o">+</span> <span class="n">IFF_LIST</span>
    <span class="n">QUANTS</span> <span class="o">=</span> <span class="n">EXISTS_LIST</span> <span class="o">+</span> <span class="n">ALL_LIST</span>
    <span class="n">PUNCT</span> <span class="o">=</span> <span class="p">[</span><span class="n">DOT</span><span class="p">,</span> <span class="n">OPEN</span><span class="p">,</span> <span class="n">CLOSE</span><span class="p">,</span> <span class="n">COMMA</span><span class="p">]</span>

    <span class="n">TOKENS</span> <span class="o">=</span> <span class="n">BINOPS</span> <span class="o">+</span> <span class="n">EQ_LIST</span> <span class="o">+</span> <span class="n">NEQ_LIST</span> <span class="o">+</span> <span class="n">QUANTS</span> <span class="o">+</span> <span class="n">LAMBDA_LIST</span> <span class="o">+</span> <span class="n">PUNCT</span> <span class="o">+</span> <span class="n">NOT_LIST</span>

    <span class="c1">#Special</span>
    <span class="n">SYMBOLS</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">TOKENS</span> <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">r&#39;^[-</span><span class="se">\\</span><span class="s1">.(),!&amp;^|&gt;=&lt;]*$&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)]</span>


<div class="viewcode-block" id="boolean_ops"><a class="viewcode-back" href="../../../generated/generated/nltk.boolean_ops.html#nltk.boolean_ops">[docs]</a><span class="k">def</span> <span class="nf">boolean_ops</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Boolean operators</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">names</span> <span class="o">=</span>  <span class="p">[</span><span class="s2">&quot;negation&quot;</span><span class="p">,</span> <span class="s2">&quot;conjunction&quot;</span><span class="p">,</span> <span class="s2">&quot;disjunction&quot;</span><span class="p">,</span> <span class="s2">&quot;implication&quot;</span><span class="p">,</span> <span class="s2">&quot;equivalence&quot;</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="p">[</span><span class="n">Tokens</span><span class="o">.</span><span class="n">NOT</span><span class="p">,</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">AND</span><span class="p">,</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">OR</span><span class="p">,</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">IMP</span><span class="p">,</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">IFF</span><span class="p">]):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%-15s</span><span class="se">\t</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>  <span class="n">pair</span><span class="p">)</span></div>

<div class="viewcode-block" id="equality_preds"><a class="viewcode-back" href="../../../generated/generated/nltk.equality_preds.html#nltk.equality_preds">[docs]</a><span class="k">def</span> <span class="nf">equality_preds</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Equality predicates</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">names</span> <span class="o">=</span>  <span class="p">[</span><span class="s2">&quot;equality&quot;</span><span class="p">,</span> <span class="s2">&quot;inequality&quot;</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="p">[</span><span class="n">Tokens</span><span class="o">.</span><span class="n">EQ</span><span class="p">,</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">NEQ</span><span class="p">]):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%-15s</span><span class="se">\t</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>  <span class="n">pair</span><span class="p">)</span></div>

<div class="viewcode-block" id="binding_ops"><a class="viewcode-back" href="../../../generated/generated/nltk.binding_ops.html#nltk.binding_ops">[docs]</a><span class="k">def</span> <span class="nf">binding_ops</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Binding operators</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">names</span> <span class="o">=</span>  <span class="p">[</span><span class="s2">&quot;existential&quot;</span><span class="p">,</span> <span class="s2">&quot;universal&quot;</span><span class="p">,</span> <span class="s2">&quot;lambda&quot;</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="p">[</span><span class="n">Tokens</span><span class="o">.</span><span class="n">EXISTS</span><span class="p">,</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">ALL</span><span class="p">,</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">LAMBDA</span><span class="p">]):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%-15s</span><span class="se">\t</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>  <span class="n">pair</span><span class="p">)</span></div>


<span class="nd">@python_2_unicode_compatible</span>
<span class="k">class</span> <span class="nc">LogicParser</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A lambda calculus expression parser.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type_check</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param type_check: bool should type checking be performed?</span>
<span class="sd">        to their types.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">type_check</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type_check</span> <span class="o">=</span> <span class="n">type_check</span>

        <span class="sd">&quot;&quot;&quot;A list of tuples of quote characters.  The 4-tuple is comprised</span>
<span class="sd">        of the start character, the end character, the escape character, and</span>
<span class="sd">        a boolean indicating whether the quotes should be included in the</span>
<span class="sd">        result. Quotes are used to signify that a token should be treated as</span>
<span class="sd">        atomic, ignoring any special characters within the token.  The escape</span>
<span class="sd">        character allows the quote end character to be used within the quote.</span>
<span class="sd">        If True, the boolean indicates that the final token should contain the</span>
<span class="sd">        quote and escape characters.</span>
<span class="sd">        This method exists to be overridden&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quote_chars</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">operator_precedence</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                           <span class="p">[(</span><span class="n">x</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">LAMBDA_LIST</span><span class="p">]</span>             <span class="o">+</span> \
                           <span class="p">[(</span><span class="n">x</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">NOT_LIST</span><span class="p">]</span>                <span class="o">+</span> \
                           <span class="p">[(</span><span class="n">APP</span><span class="p">,</span><span class="mi">3</span><span class="p">)]</span>                                       <span class="o">+</span> \
                           <span class="p">[(</span><span class="n">x</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">EQ_LIST</span><span class="o">+</span><span class="n">Tokens</span><span class="o">.</span><span class="n">NEQ_LIST</span><span class="p">]</span> <span class="o">+</span> \
                           <span class="p">[(</span><span class="n">x</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">QUANTS</span><span class="p">]</span>                  <span class="o">+</span> \
                           <span class="p">[(</span><span class="n">x</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">AND_LIST</span><span class="p">]</span>                <span class="o">+</span> \
                           <span class="p">[(</span><span class="n">x</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">OR_LIST</span><span class="p">]</span>                 <span class="o">+</span> \
                           <span class="p">[(</span><span class="n">x</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">IMP_LIST</span><span class="p">]</span>                <span class="o">+</span> \
                           <span class="p">[(</span><span class="n">x</span><span class="p">,</span><span class="mi">9</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">IFF_LIST</span><span class="p">]</span>                <span class="o">+</span> \
                           <span class="p">[(</span><span class="bp">None</span><span class="p">,</span><span class="mi">10</span><span class="p">)])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right_associated_operations</span> <span class="o">=</span> <span class="p">[</span><span class="n">APP</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parse the expression.</span>

<span class="sd">        :param data: str for the input to be parsed</span>
<span class="sd">        :param signature: ``dict&lt;str, str&gt;`` that maps variable names to type</span>
<span class="sd">        strings</span>
<span class="sd">        :returns: a parsed Expression</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">,</span> <span class="n">mapping</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_next_expression</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inRange</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">UnexpectedTokenException</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">except</span> <span class="n">LogicalExpressionException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="si">%s</span><span class="s1">^&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="o">*</span><span class="n">mapping</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">raise</span> <span class="n">LogicalExpressionException</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_check</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">typecheck</span><span class="p">(</span><span class="n">signature</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Split the data into tokens&quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mapping</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">tokenTrie</span> <span class="o">=</span> <span class="n">Trie</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_all_symbols</span><span class="p">())</span>
        <span class="n">token</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">data_idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">token_start_idx</span> <span class="o">=</span> <span class="n">data_idx</span>
        <span class="k">while</span> <span class="n">data_idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="n">cur_data_idx</span> <span class="o">=</span> <span class="n">data_idx</span>
            <span class="n">quoted_token</span><span class="p">,</span> <span class="n">data_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_quoted_token</span><span class="p">(</span><span class="n">data_idx</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">quoted_token</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">token</span><span class="p">:</span>
                    <span class="n">token_start_idx</span> <span class="o">=</span> <span class="n">cur_data_idx</span>
                <span class="n">token</span> <span class="o">+=</span> <span class="n">quoted_token</span>
                <span class="k">continue</span>

            <span class="n">st</span> <span class="o">=</span> <span class="n">tokenTrie</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data_idx</span><span class="p">]</span>
            <span class="n">symbol</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="k">while</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">st</span><span class="p">:</span>
                <span class="n">symbol</span> <span class="o">+=</span> <span class="n">c</span>
                <span class="n">st</span> <span class="o">=</span> <span class="n">st</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">-</span><span class="n">data_idx</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbol</span><span class="p">):</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data_idx</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">symbol</span><span class="p">)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">Trie</span><span class="o">.</span><span class="n">LEAF</span> <span class="ow">in</span> <span class="n">st</span><span class="p">:</span>
                <span class="c1">#token is a complete symbol</span>
                <span class="k">if</span> <span class="n">token</span><span class="p">:</span>
                    <span class="n">mapping</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)]</span> <span class="o">=</span> <span class="n">token_start_idx</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
                    <span class="n">token</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                <span class="n">mapping</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)]</span> <span class="o">=</span> <span class="n">data_idx</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
                <span class="n">data_idx</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">data_idx</span><span class="p">]</span> <span class="ow">in</span> <span class="s1">&#39; </span><span class="se">\t\n</span><span class="s1">&#39;</span><span class="p">:</span> <span class="c1">#any whitespace</span>
                    <span class="k">if</span> <span class="n">token</span><span class="p">:</span>
                        <span class="n">mapping</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)]</span> <span class="o">=</span> <span class="n">token_start_idx</span>
                        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
                        <span class="n">token</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">token</span><span class="p">:</span>
                        <span class="n">token_start_idx</span> <span class="o">=</span> <span class="n">data_idx</span>
                    <span class="n">token</span> <span class="o">+=</span> <span class="n">data</span><span class="p">[</span><span class="n">data_idx</span><span class="p">]</span>
                <span class="n">data_idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">token</span><span class="p">:</span>
            <span class="n">mapping</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)]</span> <span class="o">=</span> <span class="n">token_start_idx</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
        <span class="n">mapping</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">mapping</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
        <span class="k">return</span> <span class="n">out</span><span class="p">,</span> <span class="n">mapping</span>

    <span class="k">def</span> <span class="nf">process_quoted_token</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_idx</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">token</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data_idx</span><span class="p">]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">data_idx</span>
        <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">escape</span><span class="p">,</span> <span class="n">incl_quotes</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">quote_chars</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="n">start</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">incl_quotes</span><span class="p">:</span>
                    <span class="n">token</span> <span class="o">+=</span> <span class="n">c</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">while</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">end</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">escape</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">incl_quotes</span><span class="p">:</span>
                            <span class="n">token</span> <span class="o">+=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span> <span class="c1">#if there are no more chars</span>
                            <span class="k">raise</span> <span class="n">LogicalExpressionException</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="s2">&quot;End of input reached.  &quot;</span>
                                    <span class="s2">&quot;Escape character [</span><span class="si">%s</span><span class="s2">] found at end.&quot;</span>
                                    <span class="o">%</span> <span class="n">escape</span><span class="p">)</span>
                        <span class="n">token</span> <span class="o">+=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">token</span> <span class="o">+=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">LogicalExpressionException</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="s2">&quot;End of input reached.  &quot;</span>
                                             <span class="s2">&quot;Expected: [</span><span class="si">%s</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="n">end</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">incl_quotes</span><span class="p">:</span>
                    <span class="n">token</span> <span class="o">+=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">token</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">LogicalExpressionException</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="s1">&#39;Empty quoted token found&#39;</span><span class="p">)</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">token</span><span class="p">,</span> <span class="n">i</span>

    <span class="k">def</span> <span class="nf">get_all_symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This method exists to be overridden&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">SYMBOLS</span>

    <span class="k">def</span> <span class="nf">inRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">location</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return TRUE if the given location is within the buffer&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span><span class="o">+</span><span class="n">location</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">token</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">location</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the next waiting token.  If a location is given, then</span>
<span class="sd">        return the token at currentIndex+location without advancing</span>
<span class="sd">        currentIndex; setting it gives lookahead/lookback capability.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">location</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">tok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span><span class="o">+</span><span class="n">location</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">tok</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ExpectedMoreTokensException</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">isvariable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tok</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tok</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">TOKENS</span>

    <span class="k">def</span> <span class="nf">process_next_expression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parse the next complete expression from the stream and return it.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">tok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">ExpectedMoreTokensException</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ExpectedMoreTokensException</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s1">&#39;Expression expected.&#39;</span><span class="p">)</span>

        <span class="n">accum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">accum</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">UnexpectedTokenException</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s1">&#39;Expression expected.&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">attempt_adjuncts</span><span class="p">(</span><span class="n">accum</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">handle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This method is intended to be overridden for logics that</span>
<span class="sd">        use different operators or expressions&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isvariable</span><span class="p">(</span><span class="n">tok</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_variable</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">NOT_LIST</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_negation</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">LAMBDA_LIST</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_lambda</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">QUANTS</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_quant</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">tok</span> <span class="o">==</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">OPEN</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_open</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">attempt_adjuncts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="n">cur_idx</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">while</span> <span class="n">cur_idx</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span><span class="p">:</span> <span class="c1">#while adjuncts are added</span>
            <span class="n">cur_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span>
            <span class="n">expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attempt_EqualityExpression</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
            <span class="n">expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attempt_ApplicationExpression</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
            <span class="n">expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attempt_BooleanExpression</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">expression</span>

    <span class="k">def</span> <span class="nf">handle_negation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_NegatedExpression</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">process_next_expression</span><span class="p">(</span><span class="n">Tokens</span><span class="o">.</span><span class="n">NOT</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">make_NegatedExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">NegatedExpression</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">handle_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="c1">#It&#39;s either: 1) a predicate expression: sees(x,y)</span>
        <span class="c1">#             2) an application expression: P(x)</span>
        <span class="c1">#             3) a solo variable: john OR x</span>
        <span class="n">accum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_VariableExpression</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inRange</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">OPEN</span><span class="p">:</span>
            <span class="c1">#The predicate has arguments</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">accum</span><span class="p">,</span> <span class="n">FunctionVariableExpression</span><span class="p">)</span> <span class="ow">and</span> \
               <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">accum</span><span class="p">,</span> <span class="n">ConstantExpression</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">LogicalExpressionException</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span><span class="p">,</span>
                                     <span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; is an illegal predicate name.  &quot;</span>
                                     <span class="s2">&quot;Individual variables may not be used as &quot;</span>
                                     <span class="s2">&quot;predicates.&quot;</span> <span class="o">%</span> <span class="n">tok</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">()</span> <span class="c1">#swallow the Open Paren</span>

            <span class="c1">#curry the arguments</span>
            <span class="n">accum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_ApplicationExpression</span><span class="p">(</span><span class="n">accum</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_next_expression</span><span class="p">(</span><span class="n">APP</span><span class="p">))</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">inRange</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">COMMA</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">()</span> <span class="c1">#swallow the comma</span>
                <span class="n">accum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_ApplicationExpression</span><span class="p">(</span><span class="n">accum</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_next_expression</span><span class="p">(</span><span class="n">APP</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertNextToken</span><span class="p">(</span><span class="n">Tokens</span><span class="o">.</span><span class="n">CLOSE</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">accum</span>

    <span class="k">def</span> <span class="nf">get_next_token_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">description</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">tok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">ExpectedMoreTokensException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ExpectedMoreTokensException</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;Variable expected.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">make_VariableExpression</span><span class="p">(</span><span class="n">tok</span><span class="p">),</span> <span class="n">ConstantExpression</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">LogicalExpressionException</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span><span class="p">,</span>
                                 <span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; is an illegal variable name.  &quot;</span>
                                 <span class="s2">&quot;Constants may not be </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">description</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">Variable</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">handle_lambda</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="c1"># Expression is a lambda expression</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">inRange</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ExpectedMoreTokensException</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span>
                                              <span class="n">message</span><span class="o">=</span><span class="s2">&quot;Variable and Expression expected following lambda operator.&quot;</span><span class="p">)</span>
        <span class="nb">vars</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_next_token_variable</span><span class="p">(</span><span class="s1">&#39;abstracted&#39;</span><span class="p">)]</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">inRange</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">DOT</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">inRange</span><span class="p">(</span><span class="mi">1</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="n">ExpectedMoreTokensException</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;Expression expected.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isvariable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>
                <span class="k">break</span>
            <span class="c1"># Support expressions like: \x y.M == \x.\y.M</span>
            <span class="nb">vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_next_token_variable</span><span class="p">(</span><span class="s1">&#39;abstracted&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inRange</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">DOT</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">()</span> <span class="c1">#swallow the dot</span>

        <span class="n">accum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_next_expression</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span>
        <span class="k">while</span> <span class="nb">vars</span><span class="p">:</span>
            <span class="n">accum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_LambdaExpression</span><span class="p">(</span><span class="nb">vars</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="n">accum</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">accum</span>

    <span class="k">def</span> <span class="nf">handle_quant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="c1"># Expression is a quantified expression: some x.M</span>
        <span class="n">factory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_QuantifiedExpression_factory</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">inRange</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ExpectedMoreTokensException</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span>
                                              <span class="n">message</span><span class="o">=</span><span class="s2">&quot;Variable and Expression expected following quantifier &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span> <span class="o">%</span> <span class="n">tok</span><span class="p">)</span>
        <span class="nb">vars</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_next_token_variable</span><span class="p">(</span><span class="s1">&#39;quantified&#39;</span><span class="p">)]</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">inRange</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">DOT</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">inRange</span><span class="p">(</span><span class="mi">1</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="n">ExpectedMoreTokensException</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;Expression expected.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isvariable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>
                <span class="k">break</span>
            <span class="c1"># Support expressions like: some x y.M == some x.some y.M</span>
            <span class="nb">vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_next_token_variable</span><span class="p">(</span><span class="s1">&#39;quantified&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inRange</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">DOT</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">()</span> <span class="c1">#swallow the dot</span>

        <span class="n">accum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_next_expression</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span>
        <span class="k">while</span> <span class="nb">vars</span><span class="p">:</span>
            <span class="n">accum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_QuanifiedExpression</span><span class="p">(</span><span class="n">factory</span><span class="p">,</span> <span class="nb">vars</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="n">accum</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">accum</span>

    <span class="k">def</span> <span class="nf">get_QuantifiedExpression_factory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tok</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This method serves as a hook for other logic parsers that</span>
<span class="sd">        have different quantifiers&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">EXISTS_LIST</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ExistsExpression</span>
        <span class="k">elif</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">ALL_LIST</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">AllExpression</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertToken</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">QUANTS</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">make_QuanifiedExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factory</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">term</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">factory</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">term</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">handle_open</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="c1">#Expression is in parens</span>
        <span class="n">accum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_next_expression</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertNextToken</span><span class="p">(</span><span class="n">Tokens</span><span class="o">.</span><span class="n">CLOSE</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">accum</span>

    <span class="k">def</span> <span class="nf">attempt_EqualityExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Attempt to make an equality expression.  If the next token is an</span>
<span class="sd">        equality operator, then an EqualityExpression will be returned.</span>
<span class="sd">        Otherwise, the parameter will be returned.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inRange</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">tok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">EQ_LIST</span> <span class="o">+</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">NEQ_LIST</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_priority</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">()</span> <span class="c1">#swallow the &quot;=&quot; or &quot;!=&quot;</span>
                <span class="n">expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_EqualityExpression</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_next_expression</span><span class="p">(</span><span class="n">tok</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">NEQ_LIST</span><span class="p">:</span>
                    <span class="n">expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_NegatedExpression</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">expression</span>

    <span class="k">def</span> <span class="nf">make_EqualityExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This method serves as a hook for other logic parsers that</span>
<span class="sd">        have different equality expression classes&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">EqualityExpression</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">attempt_BooleanExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Attempt to make a boolean expression.  If the next token is a boolean</span>
<span class="sd">        operator, then a BooleanExpression will be returned.  Otherwise, the</span>
<span class="sd">        parameter will be returned.&quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">inRange</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">tok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">factory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_BooleanExpression_factory</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">factory</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_priority</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">()</span> <span class="c1">#swallow the operator</span>
                <span class="n">expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_BooleanExpression</span><span class="p">(</span><span class="n">factory</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span>
                                                         <span class="bp">self</span><span class="o">.</span><span class="n">process_next_expression</span><span class="p">(</span><span class="n">tok</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">expression</span>

    <span class="k">def</span> <span class="nf">get_BooleanExpression_factory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tok</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This method serves as a hook for other logic parsers that</span>
<span class="sd">        have different boolean operators&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">AND_LIST</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">AndExpression</span>
        <span class="k">elif</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">OR_LIST</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">OrExpression</span>
        <span class="k">elif</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">IMP_LIST</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ImpExpression</span>
        <span class="k">elif</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">IFF_LIST</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">IffExpression</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">make_BooleanExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factory</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">factory</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">attempt_ApplicationExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Attempt to make an application expression.  The next tokens are</span>
<span class="sd">        a list of arguments in parens, then the argument expression is a</span>
<span class="sd">        function being applied to the arguments.  Otherwise, return the</span>
<span class="sd">        argument expression.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_priority</span><span class="p">(</span><span class="n">APP</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inRange</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">OPEN</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">LambdaExpression</span><span class="p">)</span> <span class="ow">and</span> \
                   <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">ApplicationExpression</span><span class="p">)</span> <span class="ow">and</span> \
                   <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">FunctionVariableExpression</span><span class="p">)</span> <span class="ow">and</span> \
                   <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">ConstantExpression</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">LogicalExpressionException</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span><span class="p">,</span>
                                         <span class="p">(</span><span class="s2">&quot;The function &#39;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">expression</span><span class="p">)</span> <span class="o">+</span>
                                         <span class="s2">&quot;&#39; is not a Lambda Expression, an &quot;</span>
                                         <span class="s2">&quot;Application Expression, or a &quot;</span>
                                         <span class="s2">&quot;functional predicate, so it may &quot;</span>
                                         <span class="s2">&quot;not take arguments.&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">()</span> <span class="c1">#swallow then open paren</span>
                <span class="c1">#curry the arguments</span>
                <span class="n">accum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_ApplicationExpression</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_next_expression</span><span class="p">(</span><span class="n">APP</span><span class="p">))</span>
                <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">inRange</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">COMMA</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">()</span> <span class="c1">#swallow the comma</span>
                    <span class="n">accum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_ApplicationExpression</span><span class="p">(</span><span class="n">accum</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_next_expression</span><span class="p">(</span><span class="n">APP</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">assertNextToken</span><span class="p">(</span><span class="n">Tokens</span><span class="o">.</span><span class="n">CLOSE</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">accum</span>
        <span class="k">return</span> <span class="n">expression</span>

    <span class="k">def</span> <span class="nf">make_ApplicationExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">argument</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ApplicationExpression</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">argument</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">make_VariableExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">VariableExpression</span><span class="p">(</span><span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">make_LambdaExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">term</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">LambdaExpression</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">term</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">has_priority</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operation</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator_precedence</span><span class="p">[</span><span class="n">operation</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator_precedence</span><span class="p">[</span><span class="n">context</span><span class="p">]</span> <span class="ow">or</span> \
               <span class="p">(</span><span class="n">operation</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">right_associated_operations</span> <span class="ow">and</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">operator_precedence</span><span class="p">[</span><span class="n">operation</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator_precedence</span><span class="p">[</span><span class="n">context</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">assertNextToken</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expected</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">tok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">ExpectedMoreTokensException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ExpectedMoreTokensException</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;Expected token &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span> <span class="o">%</span> <span class="n">expected</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expected</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">tok</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">expected</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">UnexpectedTokenException</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="n">expected</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tok</span> <span class="o">!=</span> <span class="n">expected</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">UnexpectedTokenException</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="n">expected</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">assertToken</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="n">expected</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expected</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">tok</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">expected</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">UnexpectedTokenException</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="n">expected</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tok</span> <span class="o">!=</span> <span class="n">expected</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">UnexpectedTokenException</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_currentIndex</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="n">expected</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inRange</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Next token: &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;No more tokens&#39;</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span> <span class="o">+</span> <span class="s1">&#39;: &#39;</span> <span class="o">+</span> <span class="n">msg</span> <span class="o">+</span> <span class="s1">&#39;&gt;&#39;</span>


<div class="viewcode-block" id="read_logic"><a class="viewcode-back" href="../../../generated/generated/nltk.read_logic.html#nltk.read_logic">[docs]</a><span class="k">def</span> <span class="nf">read_logic</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">logic_parser</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a file of First Order Formulas into a list of {Expression}s.</span>

<span class="sd">    :param s: the contents of the file</span>
<span class="sd">    :type s: str</span>
<span class="sd">    :param logic_parser: The parser to be used to parse the logical expression</span>
<span class="sd">    :type logic_parser: LogicParser</span>
<span class="sd">    :param encoding: the encoding of the input string, if it is binary</span>
<span class="sd">    :type encoding: str</span>
<span class="sd">    :return: a list of parsed formulas.</span>
<span class="sd">    :rtype: list(Expression)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">encoding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">logic_parser</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">logic_parser</span> <span class="o">=</span> <span class="n">LogicParser</span><span class="p">()</span>

    <span class="n">statements</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">linenum</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()):</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;#&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">line</span><span class="o">==</span><span class="s1">&#39;&#39;</span><span class="p">:</span> <span class="k">continue</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">statements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">logic_parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">line</span><span class="p">))</span>
        <span class="k">except</span> <span class="n">LogicalExpressionException</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unable to parse line </span><span class="si">%s</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">linenum</span><span class="p">,</span> <span class="n">line</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">statements</span></div>


<span class="nd">@total_ordering</span>
<span class="nd">@python_2_unicode_compatible</span>
<div class="viewcode-block" id="Variable"><a class="viewcode-back" href="../../../generated/generated/nltk.Variable.html#nltk.Variable">[docs]</a><span class="k">class</span> <span class="nc">Variable</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<div class="viewcode-block" id="Variable.__init__"><a class="viewcode-back" href="../../../generated/generated/nltk.Variable.__init__.html#nltk.Variable.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param name: the name of the variable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">string_types</span><span class="p">),</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not a string&quot;</span> <span class="o">%</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span></div>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span>

<div class="viewcode-block" id="Variable.substitute_bindings"><a class="viewcode-back" href="../../../generated/generated/nltk.Variable.substitute_bindings.html#nltk.Variable.substitute_bindings">[docs]</a>    <span class="k">def</span> <span class="nf">substitute_bindings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bindings</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">bindings</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Variable(&#39;</span><span class="si">%s</span><span class="s2">&#39;)&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span></div>


<span class="k">def</span> <span class="nf">unique_variable</span><span class="p">(</span><span class="n">pattern</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a new, unique variable.</span>

<span class="sd">    :param pattern: ``Variable`` that is being replaced.  The new variable must</span>
<span class="sd">        be the same type.</span>
<span class="sd">    :param term: a set of ``Variable`` objects that should not be returned from</span>
<span class="sd">        this function.</span>
<span class="sd">    :rtype: Variable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">pattern</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">is_indvar</span><span class="p">(</span><span class="n">pattern</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="s1">&#39;z&#39;</span>
        <span class="k">elif</span> <span class="n">is_funcvar</span><span class="p">(</span><span class="n">pattern</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span>
        <span class="k">elif</span> <span class="n">is_eventvar</span><span class="p">(</span><span class="n">pattern</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="s1">&#39;e0&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">False</span><span class="p">,</span> <span class="s2">&quot;Cannot generate a unique constant&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="s1">&#39;z&#39;</span>

    <span class="n">v</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">_counter</span><span class="o">.</span><span class="n">get</span><span class="p">()))</span>
    <span class="k">while</span> <span class="n">ignore</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ignore</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">_counter</span><span class="o">.</span><span class="n">get</span><span class="p">()))</span>
    <span class="k">return</span> <span class="n">v</span>

<span class="k">def</span> <span class="nf">skolem_function</span><span class="p">(</span><span class="n">univ_scope</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a skolem function over the variables in univ_scope</span>
<span class="sd">    param univ_scope</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">skolem</span> <span class="o">=</span> <span class="n">VariableExpression</span><span class="p">(</span><span class="n">Variable</span><span class="p">(</span><span class="s1">&#39;F</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">_counter</span><span class="o">.</span><span class="n">get</span><span class="p">()))</span>
    <span class="k">if</span> <span class="n">univ_scope</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">univ_scope</span><span class="p">):</span>
            <span class="n">skolem</span> <span class="o">=</span> <span class="n">skolem</span><span class="p">(</span><span class="n">VariableExpression</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">skolem</span>


<span class="nd">@python_2_unicode_compatible</span>
<span class="k">class</span> <span class="nc">Type</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">fromstring</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">read_type</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

<span class="nd">@python_2_unicode_compatible</span>
<span class="k">class</span> <span class="nc">ComplexType</span><span class="p">(</span><span class="n">Type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">):</span>
        <span class="k">assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">Type</span><span class="p">)),</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not a Type&quot;</span> <span class="o">%</span> <span class="n">first</span>
        <span class="k">assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">second</span><span class="p">,</span> <span class="n">Type</span><span class="p">)),</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not a Type&quot;</span> <span class="o">%</span> <span class="n">second</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first</span> <span class="o">=</span> <span class="n">first</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">second</span> <span class="o">=</span> <span class="n">second</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ComplexType</span><span class="p">)</span> <span class="ow">and</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">first</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">first</span> <span class="ow">and</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">second</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">second</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="n">__hash__</span> <span class="o">=</span> <span class="n">Type</span><span class="o">.</span><span class="n">__hash__</span>

    <span class="k">def</span> <span class="nf">matches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ComplexType</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">first</span><span class="p">)</span> <span class="ow">and</span> \
                   <span class="bp">self</span><span class="o">.</span><span class="n">second</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">second</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">ANY_TYPE</span>

    <span class="k">def</span> <span class="nf">resolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">other</span> <span class="o">==</span> <span class="n">ANY_TYPE</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ComplexType</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">first</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">second</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">second</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">f</span> <span class="ow">and</span> <span class="n">s</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ComplexType</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>
        <span class="k">elif</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">ANY_TYPE</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">other</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">ANY_TYPE</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">ANY_TYPE</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;&lt;</span><span class="si">%s</span><span class="s1">,</span><span class="si">%s</span><span class="s1">&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">second</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">ANY_TYPE</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ANY_TYPE</span><span class="o">.</span><span class="n">str</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;(</span><span class="si">%s</span><span class="s1"> -&gt; </span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">str</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">second</span><span class="o">.</span><span class="n">str</span><span class="p">())</span>

<span class="k">class</span> <span class="nc">BasicType</span><span class="p">(</span><span class="n">Type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">BasicType</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="n">__hash__</span> <span class="o">=</span> <span class="n">Type</span><span class="o">.</span><span class="n">__hash__</span>

    <span class="k">def</span> <span class="nf">matches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">other</span> <span class="o">==</span> <span class="n">ANY_TYPE</span> <span class="ow">or</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">resolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

<span class="nd">@python_2_unicode_compatible</span>
<span class="k">class</span> <span class="nc">EntityType</span><span class="p">(</span><span class="n">BasicType</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;e&#39;</span>

    <span class="k">def</span> <span class="nf">str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;IND&#39;</span>

<span class="nd">@python_2_unicode_compatible</span>
<span class="k">class</span> <span class="nc">TruthValueType</span><span class="p">(</span><span class="n">BasicType</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;t&#39;</span>

    <span class="k">def</span> <span class="nf">str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;BOOL&#39;</span>

<span class="nd">@python_2_unicode_compatible</span>
<span class="k">class</span> <span class="nc">EventType</span><span class="p">(</span><span class="n">BasicType</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;v&#39;</span>

    <span class="k">def</span> <span class="nf">str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;EVENT&#39;</span>

<span class="nd">@python_2_unicode_compatible</span>
<span class="k">class</span> <span class="nc">AnyType</span><span class="p">(</span><span class="n">BasicType</span><span class="p">,</span> <span class="n">ComplexType</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">second</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">AnyType</span><span class="p">)</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="n">__hash__</span> <span class="o">=</span> <span class="n">Type</span><span class="o">.</span><span class="n">__hash__</span>

    <span class="k">def</span> <span class="nf">matches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">resolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;?&#39;</span>

    <span class="k">def</span> <span class="nf">str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;ANY&#39;</span>


<span class="n">TRUTH_TYPE</span> <span class="o">=</span> <span class="n">TruthValueType</span><span class="p">()</span>
<span class="n">ENTITY_TYPE</span> <span class="o">=</span> <span class="n">EntityType</span><span class="p">()</span>
<span class="n">EVENT_TYPE</span> <span class="o">=</span> <span class="n">EventType</span><span class="p">()</span>
<span class="n">ANY_TYPE</span> <span class="o">=</span> <span class="n">AnyType</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">read_type</span><span class="p">(</span><span class="n">type_string</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">type_string</span><span class="p">,</span> <span class="n">string_types</span><span class="p">)</span>
    <span class="n">type_string</span> <span class="o">=</span> <span class="n">type_string</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="c1">#remove spaces</span>

    <span class="k">if</span> <span class="n">type_string</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&lt;&#39;</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">type_string</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&gt;&#39;</span>
        <span class="n">paren_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">char</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">type_string</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">char</span> <span class="o">==</span> <span class="s1">&#39;&lt;&#39;</span><span class="p">:</span>
                <span class="n">paren_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">char</span> <span class="o">==</span> <span class="s1">&#39;&gt;&#39;</span><span class="p">:</span>
                <span class="n">paren_count</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">assert</span> <span class="n">paren_count</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">char</span> <span class="o">==</span> <span class="s1">&#39;,&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">paren_count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">break</span>
        <span class="k">return</span> <span class="n">ComplexType</span><span class="p">(</span><span class="n">read_type</span><span class="p">(</span><span class="n">type_string</span><span class="p">[</span><span class="mi">1</span>  <span class="p">:</span><span class="n">i</span> <span class="p">]),</span>
                           <span class="n">read_type</span><span class="p">(</span><span class="n">type_string</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">elif</span> <span class="n">type_string</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">ENTITY_TYPE</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ENTITY_TYPE</span>
    <span class="k">elif</span> <span class="n">type_string</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">TRUTH_TYPE</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">TRUTH_TYPE</span>
    <span class="k">elif</span> <span class="n">type_string</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">ANY_TYPE</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ANY_TYPE</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">LogicalExpressionException</span><span class="p">(</span><span class="s2">&quot;Unexpected character: &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span> <span class="o">%</span> <span class="n">type_string</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>


<span class="k">class</span> <span class="nc">TypeException</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="ne">Exception</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">InconsistentTypeHierarchyException</span><span class="p">(</span><span class="n">TypeException</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">expression</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">expression</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;The variable &#39;</span><span class="si">%s</span><span class="s2">&#39; was found in multiple places with different&quot;</span>\
                <span class="s2">&quot; types in &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">expression</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;The variable &#39;</span><span class="si">%s</span><span class="s2">&#39; was found in multiple places with different&quot;</span>\
                <span class="s2">&quot; types.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">variable</span><span class="p">)</span>
        <span class="ne">Exception</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">TypeResolutionException</span><span class="p">(</span><span class="n">TypeException</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">other_type</span><span class="p">):</span>
        <span class="ne">Exception</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;The type of &#39;</span><span class="si">%s</span><span class="s2">&#39;, &#39;</span><span class="si">%s</span><span class="s2">&#39;, cannot be &quot;</span>
                           <span class="s2">&quot;resolved with type &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> \
                           <span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">expression</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">other_type</span><span class="p">))</span>

<span class="k">class</span> <span class="nc">IllegalTypeException</span><span class="p">(</span><span class="n">TypeException</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">other_type</span><span class="p">,</span> <span class="n">allowed_type</span><span class="p">):</span>
        <span class="ne">Exception</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;Cannot set type of </span><span class="si">%s</span><span class="s2"> &#39;</span><span class="si">%s</span><span class="s2">&#39; to &#39;</span><span class="si">%s</span><span class="s2">&#39;; &quot;</span>
                           <span class="s2">&quot;must match type &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span> <span class="o">%</span>
                           <span class="p">(</span><span class="n">expression</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span>
                            <span class="n">other_type</span><span class="p">,</span> <span class="n">allowed_type</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">typecheck</span><span class="p">(</span><span class="n">expressions</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ensure correct typing across a collection of ``Expression`` objects.</span>
<span class="sd">    :param expressions: a collection of expressions</span>
<span class="sd">    :param signature: dict that maps variable names to types (or string</span>
<span class="sd">    representations of types)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#typecheck and create master signature</span>
    <span class="k">for</span> <span class="n">expression</span> <span class="ow">in</span> <span class="n">expressions</span><span class="p">:</span>
        <span class="n">signature</span> <span class="o">=</span> <span class="n">expression</span><span class="o">.</span><span class="n">typecheck</span><span class="p">(</span><span class="n">signature</span><span class="p">)</span>
    <span class="c1">#apply master signature to all expressions</span>
    <span class="k">for</span> <span class="n">expression</span> <span class="ow">in</span> <span class="n">expressions</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">expression</span><span class="o">.</span><span class="n">typecheck</span><span class="p">(</span><span class="n">signature</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">signature</span>


<span class="k">class</span> <span class="nc">SubstituteBindingsI</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An interface for classes that can perform substitutions for</span>
<span class="sd">    variables.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">substitute_bindings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bindings</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: The object that is obtained by replacing</span>
<span class="sd">            each variable bound by ``bindings`` with its values.</span>
<span class="sd">            Aliases are already resolved. (maybe?)</span>
<span class="sd">        :rtype: (any)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">variables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: A list of all variables in this object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>


<span class="nd">@python_2_unicode_compatible</span>
<div class="viewcode-block" id="Expression"><a class="viewcode-back" href="../../../generated/generated/nltk.Expression.html#nltk.Expression">[docs]</a><span class="k">class</span> <span class="nc">Expression</span><span class="p">(</span><span class="n">SubstituteBindingsI</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This is the base abstract object for all logical expressions&quot;&quot;&quot;</span>

    <span class="n">_logic_parser</span> <span class="o">=</span> <span class="n">LogicParser</span><span class="p">()</span>
    <span class="n">_type_checking_logic_parser</span> <span class="o">=</span> <span class="n">LogicParser</span><span class="p">(</span><span class="n">type_check</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Expression.fromstring"><a class="viewcode-back" href="../../../generated/generated/nltk.Expression.fromstring.html#nltk.Expression.fromstring">[docs]</a>    <span class="k">def</span> <span class="nf">fromstring</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">type_check</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">type_check</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">_type_checking_logic_parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">signature</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">_logic_parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">signature</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">*</span><span class="n">additional</span><span class="p">):</span>
        <span class="n">accum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">applyto</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">additional</span><span class="p">:</span>
            <span class="n">accum</span> <span class="o">=</span> <span class="n">accum</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">accum</span>

<div class="viewcode-block" id="Expression.applyto"><a class="viewcode-back" href="../../../generated/generated/nltk.Expression.applyto.html#nltk.Expression.applyto">[docs]</a>    <span class="k">def</span> <span class="nf">applyto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Expression</span><span class="p">),</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not an Expression&quot;</span> <span class="o">%</span> <span class="n">other</span>
        <span class="k">return</span> <span class="n">ApplicationExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">NegatedExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="Expression.negate"><a class="viewcode-back" href="../../../generated/generated/nltk.Expression.negate.html#nltk.Expression.negate">[docs]</a>    <span class="k">def</span> <span class="nf">negate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;If this is a negated expression, remove the negation.</span>
<span class="sd">        Otherwise add a negation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="o">-</span><span class="bp">self</span></div>

    <span class="k">def</span> <span class="nf">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Expression</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not an Expression&quot;</span> <span class="o">%</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">AndExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Expression</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not an Expression&quot;</span> <span class="o">%</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">OrExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Expression</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not an Expression&quot;</span> <span class="o">%</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ImpExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Expression</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not an Expression&quot;</span> <span class="o">%</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">IffExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

<div class="viewcode-block" id="Expression.equiv"><a class="viewcode-back" href="../../../generated/generated/nltk.Expression.equiv.html#nltk.Expression.equiv">[docs]</a>    <span class="k">def</span> <span class="nf">equiv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">prover</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check for logical equivalence.</span>
<span class="sd">        Pass the expression (self &lt;-&gt; other) to the theorem prover.</span>
<span class="sd">        If the prover says it is valid, then the self and other are equal.</span>

<span class="sd">        :param other: an ``Expression`` to check equality against</span>
<span class="sd">        :param prover: a ``nltk.inference.api.Prover``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Expression</span><span class="p">),</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not an Expression&quot;</span> <span class="o">%</span> <span class="n">other</span>

        <span class="k">if</span> <span class="n">prover</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">nltk.inference</span> <span class="kn">import</span> <span class="n">Prover9</span>
            <span class="n">prover</span> <span class="o">=</span> <span class="n">Prover9</span><span class="p">()</span>
        <span class="n">bicond</span> <span class="o">=</span> <span class="n">IffExpression</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">simplify</span><span class="p">(),</span> <span class="n">other</span><span class="o">.</span><span class="n">simplify</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">prover</span><span class="o">.</span><span class="n">prove</span><span class="p">(</span><span class="n">bicond</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

<div class="viewcode-block" id="Expression.substitute_bindings"><a class="viewcode-back" href="../../../generated/generated/nltk.Expression.substitute_bindings.html#nltk.Expression.substitute_bindings">[docs]</a>    <span class="k">def</span> <span class="nf">substitute_bindings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bindings</span><span class="p">):</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">variables</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">bindings</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">bindings</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_VariableExpression</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Expression</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Can not substitute a non-expression &#39;</span>
                                     <span class="s1">&#39;value into an expression: </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">val</span><span class="p">,))</span>
                <span class="c1"># Substitute bindings in the target value.</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">substitute_bindings</span><span class="p">(</span><span class="n">bindings</span><span class="p">)</span>
                <span class="c1"># Replace var w/ the target value.</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span></div>

<div class="viewcode-block" id="Expression.typecheck"><a class="viewcode-back" href="../../../generated/generated/nltk.Expression.typecheck.html#nltk.Expression.typecheck">[docs]</a>    <span class="k">def</span> <span class="nf">typecheck</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Infer and check types.  Raise exceptions if necessary.</span>

<span class="sd">        :param signature: dict that maps variable names to types (or string</span>
<span class="sd">            representations of types)</span>
<span class="sd">        :return: the signature, plus any additional type mappings</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">signature</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">signature</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">signature</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="n">varEx</span> <span class="o">=</span> <span class="n">VariableExpression</span><span class="p">(</span><span class="n">Variable</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Type</span><span class="p">):</span>
                    <span class="n">varEx</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">val</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">varEx</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">read_type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="n">sig</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">varEx</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_type</span><span class="p">(</span><span class="n">signature</span><span class="o">=</span><span class="n">sig</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">dict</span><span class="p">((</span><span class="n">key</span><span class="p">,</span> <span class="n">sig</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">type</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">sig</span><span class="p">)</span></div>

<div class="viewcode-block" id="Expression.findtype"><a class="viewcode-back" href="../../../generated/generated/nltk.Expression.findtype.html#nltk.Expression.findtype">[docs]</a>    <span class="k">def</span> <span class="nf">findtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the type of the given variable as it is used in this expression.</span>
<span class="sd">        For example, finding the type of &quot;P&quot; in &quot;P(x) &amp; Q(x,y)&quot; yields &quot;&lt;e,t&gt;&quot;</span>

<span class="sd">        :param variable: Variable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_set_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_type</span><span class="o">=</span><span class="n">ANY_TYPE</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the type of this expression to be the given type.  Raise type</span>
<span class="sd">        exceptions where applicable.</span>

<span class="sd">        :param other_type: Type</span>
<span class="sd">        :param signature: dict(str -&gt; list(AbstractVariableExpression))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

<div class="viewcode-block" id="Expression.replace"><a class="viewcode-back" href="../../../generated/generated/nltk.Expression.replace.html#nltk.Expression.replace">[docs]</a>    <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">replace_bound</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">alpha_convert</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace every instance of &#39;variable&#39; with &#39;expression&#39;</span>
<span class="sd">        :param variable: ``Variable`` The variable to replace</span>
<span class="sd">        :param expression: ``Expression`` The expression with which to replace it</span>
<span class="sd">        :param replace_bound: bool Should bound variables be replaced?</span>
<span class="sd">        :param alpha_convert: bool Alpha convert automatically to avoid name clashes?</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">),</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not a Variable&quot;</span> <span class="o">%</span> <span class="n">variable</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">Expression</span><span class="p">),</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not an Expression&quot;</span> <span class="o">%</span> <span class="n">expression</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_structured</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span>
                                                         <span class="n">replace_bound</span><span class="p">,</span> <span class="n">alpha_convert</span><span class="p">),</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">)</span></div>

<div class="viewcode-block" id="Expression.normalize"><a class="viewcode-back" href="../../../generated/generated/nltk.Expression.normalize.html#nltk.Expression.normalize">[docs]</a>    <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newvars</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rename auto-generated unique variables&quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">get_indiv_vars</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">IndividualVariableExpression</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">set</span><span class="p">([</span><span class="n">e</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">AbstractVariableExpression</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">e</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">get_indiv_vars</span><span class="p">,</span>
                               <span class="k">lambda</span> <span class="n">parts</span><span class="p">:</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">or_</span><span class="p">,</span> <span class="n">parts</span><span class="p">,</span> <span class="nb">set</span><span class="p">()))</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">get_indiv_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="o">.</span><span class="n">variable</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">EventVariableExpression</span><span class="p">):</span>
                <span class="n">newVar</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">Variable</span><span class="p">(</span><span class="s1">&#39;e0</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">IndividualVariableExpression</span><span class="p">):</span>
                <span class="n">newVar</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">Variable</span><span class="p">(</span><span class="s1">&#39;z</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newVar</span> <span class="o">=</span> <span class="n">e</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span> <span class="n">newVar</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="Expression.visit"><a class="viewcode-back" href="../../../generated/generated/nltk.Expression.visit.html#nltk.Expression.visit">[docs]</a>    <span class="k">def</span> <span class="nf">visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">combinator</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recursively visit subexpressions.  Apply &#39;function&#39; to each</span>
<span class="sd">        subexpression and pass the result of each function application</span>
<span class="sd">        to the &#39;combinator&#39; for aggregation:</span>

<span class="sd">            return combinator(map(function, self.subexpressions))</span>

<span class="sd">        Bound variables are neither applied upon by the function nor given to</span>
<span class="sd">        the combinator.</span>
<span class="sd">        :param function: ``Function&lt;Expression,T&gt;`` to call on each subexpression</span>
<span class="sd">        :param combinator: ``Function&lt;list&lt;T&gt;,R&gt;`` to combine the results of the</span>
<span class="sd">        function calls</span>
<span class="sd">        :return: result of combination ``R``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Expression.visit_structured"><a class="viewcode-back" href="../../../generated/generated/nltk.Expression.visit_structured.html#nltk.Expression.visit_structured">[docs]</a>    <span class="k">def</span> <span class="nf">visit_structured</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">combinator</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recursively visit subexpressions.  Apply &#39;function&#39; to each</span>
<span class="sd">        subexpression and pass the result of each function application</span>
<span class="sd">        to the &#39;combinator&#39; for aggregation.  The combinator must have</span>
<span class="sd">        the same signature as the constructor.  The function is not</span>
<span class="sd">        applied to bound variables, but they are passed to the</span>
<span class="sd">        combinator.</span>
<span class="sd">        :param function: ``Function`` to call on each subexpression</span>
<span class="sd">        :param combinator: ``Function`` with the same signature as the</span>
<span class="sd">        constructor, to combine the results of the function calls</span>
<span class="sd">        :return: result of combination</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">parts</span><span class="p">:</span> <span class="n">combinator</span><span class="p">(</span><span class="o">*</span><span class="n">parts</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;</span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1">&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">str</span><span class="p">()</span>

<div class="viewcode-block" id="Expression.variables"><a class="viewcode-back" href="../../../generated/generated/nltk.Expression.variables.html#nltk.Expression.variables">[docs]</a>    <span class="k">def</span> <span class="nf">variables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a set of all the variables for binding substitution.</span>
<span class="sd">        The variables returned include all free (non-bound) individual</span>
<span class="sd">        variables and any variable starting with &#39;?&#39; or &#39;@&#39;.</span>
<span class="sd">        :return: set of ``Variable`` objects</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">free</span><span class="p">()</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicates</span><span class="p">()</span><span class="o">|</span><span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">()</span>
                                 <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;^[?@]&#39;</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">))</span></div>

<div class="viewcode-block" id="Expression.free"><a class="viewcode-back" href="../../../generated/generated/nltk.Expression.free.html#nltk.Expression.free">[docs]</a>    <span class="k">def</span> <span class="nf">free</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a set of all the free (non-bound) variables.  This includes</span>
<span class="sd">        both individual and predicate variables, but not constants.</span>
<span class="sd">        :return: set of ``Variable`` objects</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="o">.</span><span class="n">free</span><span class="p">(),</span>
                          <span class="k">lambda</span> <span class="n">parts</span><span class="p">:</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">or_</span><span class="p">,</span> <span class="n">parts</span><span class="p">,</span> <span class="nb">set</span><span class="p">()))</span></div>

<div class="viewcode-block" id="Expression.constants"><a class="viewcode-back" href="../../../generated/generated/nltk.Expression.constants.html#nltk.Expression.constants">[docs]</a>    <span class="k">def</span> <span class="nf">constants</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a set of individual constants (non-predicates).</span>
<span class="sd">        :return: set of ``Variable`` objects</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="o">.</span><span class="n">constants</span><span class="p">(),</span>
                          <span class="k">lambda</span> <span class="n">parts</span><span class="p">:</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">or_</span><span class="p">,</span> <span class="n">parts</span><span class="p">,</span> <span class="nb">set</span><span class="p">()))</span></div>

<div class="viewcode-block" id="Expression.predicates"><a class="viewcode-back" href="../../../generated/generated/nltk.Expression.predicates.html#nltk.Expression.predicates">[docs]</a>    <span class="k">def</span> <span class="nf">predicates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a set of predicates (constants, not variables).</span>
<span class="sd">        :return: set of ``Variable`` objects</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="o">.</span><span class="n">predicates</span><span class="p">(),</span>
                          <span class="k">lambda</span> <span class="n">parts</span><span class="p">:</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">or_</span><span class="p">,</span> <span class="n">parts</span><span class="p">,</span> <span class="nb">set</span><span class="p">()))</span></div>

<div class="viewcode-block" id="Expression.simplify"><a class="viewcode-back" href="../../../generated/generated/nltk.Expression.simplify.html#nltk.Expression.simplify">[docs]</a>    <span class="k">def</span> <span class="nf">simplify</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: beta-converted version of this expression</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_structured</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="o">.</span><span class="n">simplify</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">)</span></div>

<div class="viewcode-block" id="Expression.make_VariableExpression"><a class="viewcode-back" href="../../../generated/generated/nltk.Expression.make_VariableExpression.html#nltk.Expression.make_VariableExpression">[docs]</a>    <span class="k">def</span> <span class="nf">make_VariableExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">VariableExpression</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span></div></div>


<span class="nd">@python_2_unicode_compatible</span>
<div class="viewcode-block" id="ApplicationExpression"><a class="viewcode-back" href="../../../generated/generated/nltk.ApplicationExpression.html#nltk.ApplicationExpression">[docs]</a><span class="k">class</span> <span class="nc">ApplicationExpression</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    This class is used to represent two related types of logical expressions.</span>

<span class="sd">    The first is a Predicate Expression, such as &quot;P(x,y)&quot;.  A predicate</span>
<span class="sd">    expression is comprised of a ``FunctionVariableExpression`` or</span>
<span class="sd">    ``ConstantExpression`` as the predicate and a list of Expressions as the</span>
<span class="sd">    arguments.</span>

<span class="sd">    The second is a an application of one expression to another, such as</span>
<span class="sd">    &quot;(\x.dog(x))(fido)&quot;.</span>

<span class="sd">    The reason Predicate Expressions are treated as Application Expressions is</span>
<span class="sd">    that the Variable Expression predicate of the expression may be replaced</span>
<span class="sd">    with another Expression, such as a LambdaExpression, which would mean that</span>
<span class="sd">    the Predicate should be thought of as being applied to the arguments.</span>

<span class="sd">    The logical expression reader will always curry arguments in a application expression.</span>
<span class="sd">    So, &quot;\x y.see(x,y)(john,mary)&quot; will be represented internally as</span>
<span class="sd">    &quot;((\x y.(see(x))(y))(john))(mary)&quot;.  This simplifies the internals since</span>
<span class="sd">    there will always be exactly one argument in an application.</span>

<span class="sd">    The str() method will usually print the curried forms of application</span>
<span class="sd">    expressions.  The one exception is when the the application expression is</span>
<span class="sd">    really a predicate expression (ie, underlying function is an</span>
<span class="sd">    ``AbstractVariableExpression``).  This means that the example from above</span>
<span class="sd">    will be returned as &quot;(\x y.see(x,y)(john))(mary)&quot;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="ApplicationExpression.__init__"><a class="viewcode-back" href="../../../generated/generated/nltk.ApplicationExpression.__init__.html#nltk.ApplicationExpression.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">argument</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param function: ``Expression``, for the function expression</span>
<span class="sd">        :param argument: ``Expression``, for the argument</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">Expression</span><span class="p">),</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not an Expression&quot;</span> <span class="o">%</span> <span class="n">function</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">argument</span><span class="p">,</span> <span class="n">Expression</span><span class="p">),</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not an Expression&quot;</span> <span class="o">%</span> <span class="n">argument</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">argument</span> <span class="o">=</span> <span class="n">argument</span></div>

<div class="viewcode-block" id="ApplicationExpression.simplify"><a class="viewcode-back" href="../../../generated/generated/nltk.ApplicationExpression.simplify.html#nltk.ApplicationExpression.simplify">[docs]</a>    <span class="k">def</span> <span class="nf">simplify</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
        <span class="n">argument</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">argument</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">LambdaExpression</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">function</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span> <span class="n">argument</span><span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">argument</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">ComplexType</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">second</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ANY_TYPE</span>

    <span class="k">def</span> <span class="nf">_set_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_type</span><span class="o">=</span><span class="n">ANY_TYPE</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see Expression._set_type()&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other_type</span><span class="p">,</span> <span class="n">Type</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">signature</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">signature</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">argument</span><span class="o">.</span><span class="n">_set_type</span><span class="p">(</span><span class="n">ANY_TYPE</span><span class="p">,</span> <span class="n">signature</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">_set_type</span><span class="p">(</span><span class="n">ComplexType</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">argument</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">other_type</span><span class="p">),</span> <span class="n">signature</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">TypeResolutionException</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TypeException</span><span class="p">(</span>
                    <span class="s2">&quot;The function &#39;</span><span class="si">%s</span><span class="s2">&#39; is of type &#39;</span><span class="si">%s</span><span class="s2">&#39; and cannot be applied &quot;</span>
                    <span class="s2">&quot;to &#39;</span><span class="si">%s</span><span class="s2">&#39; of type &#39;</span><span class="si">%s</span><span class="s2">&#39;.  Its argument must match type &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">argument</span><span class="p">,</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">argument</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">first</span><span class="p">))</span>

<div class="viewcode-block" id="ApplicationExpression.findtype"><a class="viewcode-back" href="../../../generated/generated/nltk.ApplicationExpression.findtype.html#nltk.ApplicationExpression.findtype">[docs]</a>    <span class="k">def</span> <span class="nf">findtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see Expression.findtype()&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">),</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not a Variable&quot;</span> <span class="o">%</span> <span class="n">variable</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_atom</span><span class="p">():</span>
            <span class="n">function</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">uncurry</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#It&#39;s not a predicate expression (&quot;P(x,y)&quot;), so leave args curried</span>
            <span class="n">function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">argument</span><span class="p">]</span>

        <span class="n">found</span> <span class="o">=</span> <span class="p">[</span><span class="n">arg</span><span class="o">.</span><span class="n">findtype</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="p">[</span><span class="n">function</span><span class="p">]</span><span class="o">+</span><span class="n">args</span><span class="p">]</span>

        <span class="n">unique</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">found</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">f</span> <span class="o">!=</span> <span class="n">ANY_TYPE</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">unique</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">unique</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
                            <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">unique</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">unique</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ANY_TYPE</span></div>

<div class="viewcode-block" id="ApplicationExpression.constants"><a class="viewcode-back" href="../../../generated/generated/nltk.ApplicationExpression.constants.html#nltk.ApplicationExpression.constants">[docs]</a>    <span class="k">def</span> <span class="nf">constants</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: Expression.constants()&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">,</span> <span class="n">AbstractVariableExpression</span><span class="p">):</span>
            <span class="n">function_constants</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">function_constants</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">constants</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">function_constants</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">argument</span><span class="o">.</span><span class="n">constants</span><span class="p">()</span></div>

<div class="viewcode-block" id="ApplicationExpression.predicates"><a class="viewcode-back" href="../../../generated/generated/nltk.ApplicationExpression.predicates.html#nltk.ApplicationExpression.predicates">[docs]</a>    <span class="k">def</span> <span class="nf">predicates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: Expression.predicates()&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">,</span> <span class="n">ConstantExpression</span><span class="p">):</span>
            <span class="n">function_preds</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">variable</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">function_preds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">predicates</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">function_preds</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">argument</span><span class="o">.</span><span class="n">predicates</span><span class="p">()</span></div>

<div class="viewcode-block" id="ApplicationExpression.visit"><a class="viewcode-back" href="../../../generated/generated/nltk.ApplicationExpression.visit.html#nltk.ApplicationExpression.visit">[docs]</a>    <span class="k">def</span> <span class="nf">visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">combinator</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: Expression.visit()&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">combinator</span><span class="p">([</span><span class="n">function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">),</span> <span class="n">function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">argument</span><span class="p">)])</span></div>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ApplicationExpression</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">function</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">function</span> <span class="ow">and</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">argument</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">argument</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="n">__hash__</span> <span class="o">=</span> <span class="n">Expression</span><span class="o">.</span><span class="n">__hash__</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># uncurry the arguments and find the base function</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_atom</span><span class="p">():</span>
            <span class="n">function</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">uncurry</span><span class="p">()</span>
            <span class="n">arg_str</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">arg</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#Leave arguments curried</span>
            <span class="n">function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span>
            <span class="n">arg_str</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">argument</span>

        <span class="n">function_str</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">function</span>
        <span class="n">parenthesize_function</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">LambdaExpression</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">term</span><span class="p">,</span> <span class="n">ApplicationExpression</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">function</span><span class="p">,</span>
                                  <span class="n">AbstractVariableExpression</span><span class="p">):</span>
                    <span class="n">parenthesize_function</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">term</span><span class="p">,</span> <span class="n">BooleanExpression</span><span class="p">):</span>
                <span class="n">parenthesize_function</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">ApplicationExpression</span><span class="p">):</span>
            <span class="n">parenthesize_function</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="k">if</span> <span class="n">parenthesize_function</span><span class="p">:</span>
            <span class="n">function_str</span> <span class="o">=</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">OPEN</span> <span class="o">+</span> <span class="n">function_str</span> <span class="o">+</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">CLOSE</span>

        <span class="k">return</span> <span class="n">function_str</span> <span class="o">+</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">OPEN</span> <span class="o">+</span> <span class="n">arg_str</span> <span class="o">+</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">CLOSE</span>

<div class="viewcode-block" id="ApplicationExpression.uncurry"><a class="viewcode-back" href="../../../generated/generated/nltk.ApplicationExpression.uncurry.html#nltk.ApplicationExpression.uncurry">[docs]</a>    <span class="k">def</span> <span class="nf">uncurry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Uncurry this application expression</span>

<span class="sd">        return: A tuple (base-function, arg-list)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">argument</span><span class="p">]</span>
        <span class="k">while</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">ApplicationExpression</span><span class="p">):</span>
            <span class="c1">#(\x.\y.sees(x,y)(john))(mary)</span>
            <span class="n">args</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">function</span><span class="o">.</span><span class="n">argument</span><span class="p">)</span>
            <span class="n">function</span> <span class="o">=</span> <span class="n">function</span><span class="o">.</span><span class="n">function</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pred</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return uncurried base-function.</span>
<span class="sd">        If this is an atom, then the result will be a variable expression.</span>
<span class="sd">        Otherwise, it will be a lambda expression.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">uncurry</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return uncurried arg-list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">uncurry</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>

<div class="viewcode-block" id="ApplicationExpression.is_atom"><a class="viewcode-back" href="../../../generated/generated/nltk.ApplicationExpression.is_atom.html#nltk.ApplicationExpression.is_atom">[docs]</a>    <span class="k">def</span> <span class="nf">is_atom</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Is this expression an atom (as opposed to a lambda expression applied</span>
<span class="sd">        to a term)?</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pred</span><span class="p">,</span> <span class="n">AbstractVariableExpression</span><span class="p">)</span></div></div>


<span class="nd">@total_ordering</span>
<span class="nd">@python_2_unicode_compatible</span>
<span class="k">class</span> <span class="nc">AbstractVariableExpression</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class represents a variable to be used as a predicate or entity&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param variable: ``Variable``, for the variable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">),</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not a Variable&quot;</span> <span class="o">%</span> <span class="n">variable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variable</span> <span class="o">=</span> <span class="n">variable</span>

    <span class="k">def</span> <span class="nf">simplify</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">replace_bound</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">alpha_convert</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: Expression.replace()&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">),</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not an Variable&quot;</span> <span class="o">%</span> <span class="n">variable</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">Expression</span><span class="p">),</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not an Expression&quot;</span> <span class="o">%</span> <span class="n">expression</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span> <span class="o">==</span> <span class="n">variable</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">expression</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_set_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_type</span><span class="o">=</span><span class="n">ANY_TYPE</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see Expression._set_type()&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other_type</span><span class="p">,</span> <span class="n">Type</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">signature</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">signature</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="n">resolution</span> <span class="o">=</span> <span class="n">other_type</span>
        <span class="k">for</span> <span class="n">varEx</span> <span class="ow">in</span> <span class="n">signature</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">name</span><span class="p">]:</span>
            <span class="n">resolution</span> <span class="o">=</span> <span class="n">varEx</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">resolution</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">resolution</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">InconsistentTypeHierarchyException</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">signature</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">varEx</span> <span class="ow">in</span> <span class="n">signature</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">name</span><span class="p">]:</span>
            <span class="n">varEx</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">resolution</span>

    <span class="k">def</span> <span class="nf">findtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see Expression.findtype()&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">),</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not a Variable&quot;</span> <span class="o">%</span> <span class="n">variable</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span> <span class="o">==</span> <span class="n">variable</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ANY_TYPE</span>

    <span class="k">def</span> <span class="nf">predicates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: Expression.predicates()&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Allow equality between instances of ``AbstractVariableExpression``</span>
<span class="sd">        subtypes.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">AbstractVariableExpression</span><span class="p">)</span> <span class="ow">and</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">variable</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">variable</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">AbstractVariableExpression</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">variable</span>

    <span class="n">__hash__</span> <span class="o">=</span> <span class="n">Expression</span><span class="o">.</span><span class="n">__hash__</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span>

<span class="k">class</span> <span class="nc">IndividualVariableExpression</span><span class="p">(</span><span class="n">AbstractVariableExpression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class represents variables that take the form of a single lowercase</span>
<span class="sd">    character (other than &#39;e&#39;) followed by zero or more digits.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_set_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_type</span><span class="o">=</span><span class="n">ANY_TYPE</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see Expression._set_type()&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other_type</span><span class="p">,</span> <span class="n">Type</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">signature</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">signature</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">other_type</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">ENTITY_TYPE</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">IllegalTypeException</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_type</span><span class="p">,</span> <span class="n">ENTITY_TYPE</span><span class="p">)</span>

        <span class="n">signature</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="n">ENTITY_TYPE</span>
    <span class="nb">type</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_type</span><span class="p">,</span> <span class="n">_set_type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">free</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: Expression.free()&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">constants</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: Expression.constants()&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">FunctionVariableExpression</span><span class="p">(</span><span class="n">AbstractVariableExpression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class represents variables that take the form of a single uppercase</span>
<span class="sd">    character followed by zero or more digits.&quot;&quot;&quot;</span>
    <span class="nb">type</span> <span class="o">=</span> <span class="n">ANY_TYPE</span>

    <span class="k">def</span> <span class="nf">free</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: Expression.free()&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">constants</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: Expression.constants()&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">EventVariableExpression</span><span class="p">(</span><span class="n">IndividualVariableExpression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class represents variables that take the form of a single lowercase</span>
<span class="sd">    &#39;e&#39; character followed by zero or more digits.&quot;&quot;&quot;</span>
    <span class="nb">type</span> <span class="o">=</span> <span class="n">EVENT_TYPE</span>

<span class="k">class</span> <span class="nc">ConstantExpression</span><span class="p">(</span><span class="n">AbstractVariableExpression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class represents variables that do not take the form of a single</span>
<span class="sd">    character followed by zero or more digits.&quot;&quot;&quot;</span>
    <span class="nb">type</span> <span class="o">=</span> <span class="n">ENTITY_TYPE</span>

    <span class="k">def</span> <span class="nf">_set_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_type</span><span class="o">=</span><span class="n">ANY_TYPE</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see Expression._set_type()&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other_type</span><span class="p">,</span> <span class="n">Type</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">signature</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">signature</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">other_type</span> <span class="o">==</span> <span class="n">ANY_TYPE</span><span class="p">:</span>
            <span class="c1">#entity type by default, for individuals</span>
            <span class="n">resolution</span> <span class="o">=</span> <span class="n">ENTITY_TYPE</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">resolution</span> <span class="o">=</span> <span class="n">other_type</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ENTITY_TYPE</span><span class="p">:</span>
                <span class="n">resolution</span> <span class="o">=</span> <span class="n">resolution</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">varEx</span> <span class="ow">in</span> <span class="n">signature</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">name</span><span class="p">]:</span>
            <span class="n">resolution</span> <span class="o">=</span> <span class="n">varEx</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">resolution</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">resolution</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">InconsistentTypeHierarchyException</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">signature</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">varEx</span> <span class="ow">in</span> <span class="n">signature</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">.</span><span class="n">name</span><span class="p">]:</span>
            <span class="n">varEx</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">resolution</span>

    <span class="k">def</span> <span class="nf">free</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: Expression.free()&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">constants</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: Expression.constants()&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">VariableExpression</span><span class="p">(</span><span class="n">variable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a factory method that instantiates and returns a subtype of</span>
<span class="sd">    ``AbstractVariableExpression`` appropriate for the given variable.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">),</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not a Variable&quot;</span> <span class="o">%</span> <span class="n">variable</span>
    <span class="k">if</span> <span class="n">is_indvar</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">IndividualVariableExpression</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">is_funcvar</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">FunctionVariableExpression</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">is_eventvar</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">EventVariableExpression</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ConstantExpression</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">VariableBinderExpression</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This an abstract class for any Expression that binds a variable in an</span>
<span class="sd">    Expression.  This includes LambdaExpressions and Quantified Expressions&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">term</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param variable: ``Variable``, for the variable</span>
<span class="sd">        :param term: ``Expression``, for the term</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">),</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not a Variable&quot;</span> <span class="o">%</span> <span class="n">variable</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">Expression</span><span class="p">),</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not an Expression&quot;</span> <span class="o">%</span> <span class="n">term</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variable</span> <span class="o">=</span> <span class="n">variable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">term</span> <span class="o">=</span> <span class="n">term</span>

    <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">replace_bound</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">alpha_convert</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: Expression.replace()&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">),</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not a Variable&quot;</span> <span class="o">%</span> <span class="n">variable</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">Expression</span><span class="p">),</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not an Expression&quot;</span> <span class="o">%</span> <span class="n">expression</span>
        <span class="c1">#if the bound variable is the thing being replaced</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span> <span class="o">==</span> <span class="n">variable</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">replace_bound</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">AbstractVariableExpression</span><span class="p">),</span>\
                       <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not a AbstractVariableExpression&quot;</span> <span class="o">%</span> <span class="n">expression</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">expression</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="n">alpha_convert</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># if the bound variable appears in the expression, then it must</span>
            <span class="c1"># be alpha converted to avoid a conflict</span>
            <span class="k">if</span> <span class="n">alpha_convert</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span> <span class="ow">in</span> <span class="n">expression</span><span class="o">.</span><span class="n">free</span><span class="p">():</span>
                <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_convert</span><span class="p">(</span><span class="n">unique_variable</span><span class="p">(</span><span class="n">pattern</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">))</span>

            <span class="c1">#replace in the term</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">replace_bound</span><span class="p">,</span> <span class="n">alpha_convert</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">alpha_convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newvar</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rename all occurrences of the variable introduced by this variable</span>
<span class="sd">        binder in the expression to ``newvar``.</span>
<span class="sd">        :param newvar: ``Variable``, for the new variable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">newvar</span><span class="p">,</span> <span class="n">Variable</span><span class="p">),</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not a Variable&quot;</span> <span class="o">%</span> <span class="n">newvar</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">newvar</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span>
                                                <span class="n">VariableExpression</span><span class="p">(</span><span class="n">newvar</span><span class="p">),</span>
                                                <span class="bp">True</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">free</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: Expression.free()&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">free</span><span class="p">()</span> <span class="o">-</span> <span class="nb">set</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">findtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see Expression.findtype()&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">),</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not a Variable&quot;</span> <span class="o">%</span> <span class="n">variable</span>
        <span class="k">if</span> <span class="n">variable</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ANY_TYPE</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">findtype</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">combinator</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: Expression.visit()&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">combinator</span><span class="p">([</span><span class="n">function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="p">)])</span>

    <span class="k">def</span> <span class="nf">visit_structured</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">combinator</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: Expression.visit_structured()&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">combinator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span> <span class="n">function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Defines equality modulo alphabetic variance.  If we are comparing</span>
<span class="sd">        \x.M  and \y.N, then check equality of M and N[x/y].&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">__class__</span><span class="p">)</span> <span class="ow">or</span> \
           <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">variable</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">term</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">term</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Comparing \x.M  and \y.N.  Relabel y in N with x and continue.</span>
                <span class="n">varex</span> <span class="o">=</span> <span class="n">VariableExpression</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">term</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span> <span class="n">varex</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="n">__hash__</span> <span class="o">=</span> <span class="n">Expression</span><span class="o">.</span><span class="n">__hash__</span>


<span class="nd">@python_2_unicode_compatible</span>
<span class="k">class</span> <span class="nc">LambdaExpression</span><span class="p">(</span><span class="n">VariableBinderExpression</span><span class="p">):</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ComplexType</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">findtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">),</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_type</span><span class="o">=</span><span class="n">ANY_TYPE</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see Expression._set_type()&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other_type</span><span class="p">,</span> <span class="n">Type</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">signature</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">signature</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">_set_type</span><span class="p">(</span><span class="n">other_type</span><span class="o">.</span><span class="n">second</span><span class="p">,</span> <span class="n">signature</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">other_type</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">TypeResolutionException</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">]</span>
        <span class="n">term</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">term</span>
        <span class="k">while</span> <span class="n">term</span><span class="o">.</span><span class="n">__class__</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">:</span>
            <span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">variable</span><span class="p">)</span>
            <span class="n">term</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">term</span>
        <span class="k">return</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">LAMBDA</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">)</span> <span class="o">+</span> \
               <span class="n">Tokens</span><span class="o">.</span><span class="n">DOT</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">term</span>


<span class="nd">@python_2_unicode_compatible</span>
<span class="k">class</span> <span class="nc">QuantifiedExpression</span><span class="p">(</span><span class="n">VariableBinderExpression</span><span class="p">):</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="n">TRUTH_TYPE</span>

    <span class="k">def</span> <span class="nf">_set_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_type</span><span class="o">=</span><span class="n">ANY_TYPE</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see Expression._set_type()&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other_type</span><span class="p">,</span> <span class="n">Type</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">signature</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">signature</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">other_type</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">TRUTH_TYPE</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">IllegalTypeException</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_type</span><span class="p">,</span> <span class="n">TRUTH_TYPE</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">_set_type</span><span class="p">(</span><span class="n">TRUTH_TYPE</span><span class="p">,</span> <span class="n">signature</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">]</span>
        <span class="n">term</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">term</span>
        <span class="k">while</span> <span class="n">term</span><span class="o">.</span><span class="n">__class__</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">:</span>
            <span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">variable</span><span class="p">)</span>
            <span class="n">term</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">term</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getQuantifier</span><span class="p">()</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">)</span> <span class="o">+</span> \
               <span class="n">Tokens</span><span class="o">.</span><span class="n">DOT</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">term</span>

<span class="k">class</span> <span class="nc">ExistsExpression</span><span class="p">(</span><span class="n">QuantifiedExpression</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">getQuantifier</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">EXISTS</span>

<span class="k">class</span> <span class="nc">AllExpression</span><span class="p">(</span><span class="n">QuantifiedExpression</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">getQuantifier</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">ALL</span>


<span class="nd">@python_2_unicode_compatible</span>
<span class="k">class</span> <span class="nc">NegatedExpression</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">term</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">Expression</span><span class="p">),</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not an Expression&quot;</span> <span class="o">%</span> <span class="n">term</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">term</span> <span class="o">=</span> <span class="n">term</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="n">TRUTH_TYPE</span>

    <span class="k">def</span> <span class="nf">_set_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_type</span><span class="o">=</span><span class="n">ANY_TYPE</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see Expression._set_type()&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other_type</span><span class="p">,</span> <span class="n">Type</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">signature</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">signature</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">other_type</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">TRUTH_TYPE</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">IllegalTypeException</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_type</span><span class="p">,</span> <span class="n">TRUTH_TYPE</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">_set_type</span><span class="p">(</span><span class="n">TRUTH_TYPE</span><span class="p">,</span> <span class="n">signature</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">findtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">),</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not a Variable&quot;</span> <span class="o">%</span> <span class="n">variable</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">findtype</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">combinator</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: Expression.visit()&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">combinator</span><span class="p">([</span><span class="n">function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="p">)])</span>

    <span class="k">def</span> <span class="nf">negate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: Expression.negate()&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">term</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">NegatedExpression</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">term</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">term</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="n">__hash__</span> <span class="o">=</span> <span class="n">Expression</span><span class="o">.</span><span class="n">__hash__</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">NOT</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">term</span>


<span class="nd">@python_2_unicode_compatible</span>
<span class="k">class</span> <span class="nc">BinaryExpression</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">Expression</span><span class="p">),</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not an Expression&quot;</span> <span class="o">%</span> <span class="n">first</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">second</span><span class="p">,</span> <span class="n">Expression</span><span class="p">),</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not an Expression&quot;</span> <span class="o">%</span> <span class="n">second</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first</span> <span class="o">=</span> <span class="n">first</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">second</span> <span class="o">=</span> <span class="n">second</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="n">TRUTH_TYPE</span>

    <span class="k">def</span> <span class="nf">findtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see Expression.findtype()&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">),</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not a Variable&quot;</span> <span class="o">%</span> <span class="n">variable</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">findtype</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">second</span><span class="o">.</span><span class="n">findtype</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">f</span> <span class="o">==</span> <span class="n">s</span> <span class="ow">or</span> <span class="n">s</span> <span class="o">==</span> <span class="n">ANY_TYPE</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">f</span>
        <span class="k">elif</span> <span class="n">f</span> <span class="o">==</span> <span class="n">ANY_TYPE</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">s</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ANY_TYPE</span>

    <span class="k">def</span> <span class="nf">visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">combinator</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: Expression.visit()&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">combinator</span><span class="p">([</span><span class="n">function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="p">),</span> <span class="n">function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">second</span><span class="p">)])</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">__class__</span><span class="p">)</span> <span class="ow">or</span> \
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">))</span> <span class="ow">and</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">first</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">first</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">second</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">second</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="n">__hash__</span> <span class="o">=</span> <span class="n">Expression</span><span class="o">.</span><span class="n">__hash__</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">first</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_str_subex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="p">)</span>
        <span class="n">second</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_str_subex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">second</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">OPEN</span> <span class="o">+</span> <span class="n">first</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOp</span><span class="p">()</span> \
                <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">second</span> <span class="o">+</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">CLOSE</span>

    <span class="k">def</span> <span class="nf">_str_subex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subex</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">subex</span>


<span class="k">class</span> <span class="nc">BooleanExpression</span><span class="p">(</span><span class="n">BinaryExpression</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_set_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_type</span><span class="o">=</span><span class="n">ANY_TYPE</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see Expression._set_type()&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other_type</span><span class="p">,</span> <span class="n">Type</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">signature</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">signature</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">other_type</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">TRUTH_TYPE</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">IllegalTypeException</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_type</span><span class="p">,</span> <span class="n">TRUTH_TYPE</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">_set_type</span><span class="p">(</span><span class="n">TRUTH_TYPE</span><span class="p">,</span> <span class="n">signature</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">second</span><span class="o">.</span><span class="n">_set_type</span><span class="p">(</span><span class="n">TRUTH_TYPE</span><span class="p">,</span> <span class="n">signature</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">AndExpression</span><span class="p">(</span><span class="n">BooleanExpression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class represents conjunctions&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">getOp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">AND</span>

    <span class="k">def</span> <span class="nf">_str_subex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subex</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">subex</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subex</span><span class="p">,</span> <span class="n">AndExpression</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">s</span>

<span class="k">class</span> <span class="nc">OrExpression</span><span class="p">(</span><span class="n">BooleanExpression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class represents disjunctions&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">getOp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">OR</span>

    <span class="k">def</span> <span class="nf">_str_subex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subex</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">subex</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subex</span><span class="p">,</span> <span class="n">OrExpression</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">s</span>

<span class="k">class</span> <span class="nc">ImpExpression</span><span class="p">(</span><span class="n">BooleanExpression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class represents implications&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">getOp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">IMP</span>

<span class="k">class</span> <span class="nc">IffExpression</span><span class="p">(</span><span class="n">BooleanExpression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class represents biconditionals&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">getOp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">IFF</span>


<span class="k">class</span> <span class="nc">EqualityExpression</span><span class="p">(</span><span class="n">BinaryExpression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class represents equality expressions like &quot;(x = y)&quot;.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_set_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_type</span><span class="o">=</span><span class="n">ANY_TYPE</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see Expression._set_type()&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other_type</span><span class="p">,</span> <span class="n">Type</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">signature</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">signature</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">other_type</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">TRUTH_TYPE</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">IllegalTypeException</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_type</span><span class="p">,</span> <span class="n">TRUTH_TYPE</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">_set_type</span><span class="p">(</span><span class="n">ENTITY_TYPE</span><span class="p">,</span> <span class="n">signature</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">second</span><span class="o">.</span><span class="n">_set_type</span><span class="p">(</span><span class="n">ENTITY_TYPE</span><span class="p">,</span> <span class="n">signature</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getOp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">EQ</span>


<span class="c1">### Utilities</span>

<div class="viewcode-block" id="LogicalExpressionException"><a class="viewcode-back" href="../../../generated/nltk.LogicalExpressionException.html#nltk.LogicalExpressionException">[docs]</a><span class="k">class</span> <span class="nc">LogicalExpressionException</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span>
        <span class="ne">Exception</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span></div>

<span class="k">class</span> <span class="nc">UnexpectedTokenException</span><span class="p">(</span><span class="n">LogicalExpressionException</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">unexpected</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">expected</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">unexpected</span> <span class="ow">and</span> <span class="n">expected</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Unexpected token: &#39;</span><span class="si">%s</span><span class="s2">&#39;.  &quot;</span> \
                  <span class="s2">&quot;Expected token &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">unexpected</span><span class="p">,</span> <span class="n">expected</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">unexpected</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Unexpected token: &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span> <span class="o">%</span> <span class="n">unexpected</span>
            <span class="k">if</span> <span class="n">message</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;  &#39;</span><span class="o">+</span><span class="n">message</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Expected token &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span> <span class="o">%</span> <span class="n">expected</span>
        <span class="n">LogicalExpressionException</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">ExpectedMoreTokensException</span><span class="p">(</span><span class="n">LogicalExpressionException</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">message</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s1">&#39;More tokens expected.&#39;</span>
        <span class="n">LogicalExpressionException</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="s1">&#39;End of input found.  &#39;</span> <span class="o">+</span> <span class="n">message</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_indvar</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An individual variable must be a single lowercase character other than &#39;e&#39;,</span>
<span class="sd">    followed by zero or more digits.</span>

<span class="sd">    :param expr: str</span>
<span class="sd">    :return: bool True if expr is of the correct form</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">string_types</span><span class="p">),</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not a string&quot;</span> <span class="o">%</span> <span class="n">expr</span>
    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">r&#39;^[a-df-z]\d*$&#39;</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>

<span class="k">def</span> <span class="nf">is_funcvar</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A function variable must be a single uppercase character followed by</span>
<span class="sd">    zero or more digits.</span>

<span class="sd">    :param expr: str</span>
<span class="sd">    :return: bool True if expr is of the correct form</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">string_types</span><span class="p">),</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not a string&quot;</span> <span class="o">%</span> <span class="n">expr</span>
    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">r&#39;^[A-Z]\d*$&#39;</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>

<span class="k">def</span> <span class="nf">is_eventvar</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An event variable must be a single lowercase &#39;e&#39; character followed by</span>
<span class="sd">    zero or more digits.</span>

<span class="sd">    :param expr: str</span>
<span class="sd">    :return: bool True if expr is of the correct form</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">string_types</span><span class="p">),</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not a string&quot;</span> <span class="o">%</span> <span class="n">expr</span>
    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">r&#39;^e\d*$&#39;</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>


<span class="k">def</span> <span class="nf">demo</span><span class="p">():</span>
    <span class="n">lexpr</span> <span class="o">=</span> <span class="n">Expression</span><span class="o">.</span><span class="n">fromstring</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">20</span> <span class="o">+</span> <span class="s1">&#39;Test reader&#39;</span> <span class="o">+</span> <span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">20</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">lexpr</span><span class="p">(</span><span class="s1">r&#39;john&#39;</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">lexpr</span><span class="p">(</span><span class="s1">r&#39;man(x)&#39;</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">lexpr</span><span class="p">(</span><span class="s1">r&#39;-man(x)&#39;</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">lexpr</span><span class="p">(</span><span class="s1">r&#39;(man(x) &amp; tall(x) &amp; walks(x))&#39;</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">lexpr</span><span class="p">(</span><span class="s1">r&#39;exists x.(man(x) &amp; tall(x) &amp; walks(x))&#39;</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">lexpr</span><span class="p">(</span><span class="s1">r&#39;\x.man(x)&#39;</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">lexpr</span><span class="p">(</span><span class="s1">r&#39;\x.man(x)(john)&#39;</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">lexpr</span><span class="p">(</span><span class="s1">r&#39;\x y.sees(x,y)&#39;</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">lexpr</span><span class="p">(</span><span class="s1">r&#39;\x y.sees(x,y)(a,b)&#39;</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">lexpr</span><span class="p">(</span><span class="s1">r&#39;(\x.exists y.walks(x,y))(x)&#39;</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">lexpr</span><span class="p">(</span><span class="s1">r&#39;exists x.x = y&#39;</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">lexpr</span><span class="p">(</span><span class="s1">r&#39;exists x.(x = y)&#39;</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">lexpr</span><span class="p">(</span><span class="s1">&#39;P(x) &amp; x=y &amp; P(y)&#39;</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">lexpr</span><span class="p">(</span><span class="s1">r&#39;\P Q.exists x.(P(x) &amp; Q(x))&#39;</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">lexpr</span><span class="p">(</span><span class="s1">r&#39;man(x) &lt;-&gt; tall(x)&#39;</span><span class="p">))</span>

    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">20</span> <span class="o">+</span> <span class="s1">&#39;Test simplify&#39;</span> <span class="o">+</span> <span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">20</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">lexpr</span><span class="p">(</span><span class="s1">r&#39;\x.\y.sees(x,y)(john)(mary)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">())</span>
    <span class="k">print</span><span class="p">(</span><span class="n">lexpr</span><span class="p">(</span><span class="s1">r&#39;\x.\y.sees(x,y)(john, mary)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">())</span>
    <span class="k">print</span><span class="p">(</span><span class="n">lexpr</span><span class="p">(</span><span class="s1">r&#39;all x.(man(x) &amp; (\x.exists y.walks(x,y))(x))&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">())</span>
    <span class="k">print</span><span class="p">(</span><span class="n">lexpr</span><span class="p">(</span><span class="s1">r&#39;(\P.\Q.exists x.(P(x) &amp; Q(x)))(\x.dog(x))(\x.bark(x))&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">())</span>

    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">20</span> <span class="o">+</span> <span class="s1">&#39;Test alpha conversion and binder expression equality&#39;</span> <span class="o">+</span> <span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">20</span><span class="p">)</span>
    <span class="n">e1</span> <span class="o">=</span> <span class="n">lexpr</span><span class="p">(</span><span class="s1">&#39;exists x.P(x)&#39;</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">e1</span><span class="p">)</span>
    <span class="n">e2</span> <span class="o">=</span> <span class="n">e1</span><span class="o">.</span><span class="n">alpha_convert</span><span class="p">(</span><span class="n">Variable</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">e2</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">e1</span> <span class="o">==</span> <span class="n">e2</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">demo_errors</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">20</span> <span class="o">+</span> <span class="s1">&#39;Test reader errors&#39;</span> <span class="o">+</span> <span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">20</span><span class="p">)</span>
    <span class="n">demoException</span><span class="p">(</span><span class="s1">&#39;(P(x) &amp; Q(x)&#39;</span><span class="p">)</span>
    <span class="n">demoException</span><span class="p">(</span><span class="s1">&#39;((P(x) &amp;) &amp; Q(x))&#39;</span><span class="p">)</span>
    <span class="n">demoException</span><span class="p">(</span><span class="s1">&#39;P(x) -&gt; &#39;</span><span class="p">)</span>
    <span class="n">demoException</span><span class="p">(</span><span class="s1">&#39;P(x&#39;</span><span class="p">)</span>
    <span class="n">demoException</span><span class="p">(</span><span class="s1">&#39;P(x,&#39;</span><span class="p">)</span>
    <span class="n">demoException</span><span class="p">(</span><span class="s1">&#39;P(x,)&#39;</span><span class="p">)</span>
    <span class="n">demoException</span><span class="p">(</span><span class="s1">&#39;exists&#39;</span><span class="p">)</span>
    <span class="n">demoException</span><span class="p">(</span><span class="s1">&#39;exists x.&#39;</span><span class="p">)</span>
    <span class="n">demoException</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">demoException</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1"> x y.&#39;</span><span class="p">)</span>
    <span class="n">demoException</span><span class="p">(</span><span class="s1">&#39;P(x)Q(x)&#39;</span><span class="p">)</span>
    <span class="n">demoException</span><span class="p">(</span><span class="s1">&#39;(P(x)Q(x)&#39;</span><span class="p">)</span>
    <span class="n">demoException</span><span class="p">(</span><span class="s1">&#39;exists x -&gt; y&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">demoException</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">Expression</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">LogicalExpressionException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">printtype</span><span class="p">(</span><span class="n">ex</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> : </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ex</span><span class="o">.</span><span class="n">str</span><span class="p">(),</span> <span class="n">ex</span><span class="o">.</span><span class="n">type</span><span class="p">))</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">demo</span><span class="p">()</span>
<span class="c1">#    demo_errors()</span>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../../_static/copybutton.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>