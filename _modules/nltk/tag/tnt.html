

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>nltk.tag.tnt</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="" href="../../../index.html"/>
        <link rel="up" title="nltk.tag" href="../tag.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> NLP APIs
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../gensim_tutorial/tutorial.html">Gensim Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../nltk_intro.html">Natural Language Toolkit</a></li>
</ul>
<p class="caption"><span class="caption-text">Autogenerated API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/nltk.html"><code class="docutils literal"><span class="pre">nltk</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.html"><code class="docutils literal"><span class="pre">gensim</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.interfaces.html"><code class="docutils literal"><span class="pre">gensim.interfaces</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.matutils.html"><code class="docutils literal"><span class="pre">gensim.matutils</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.utils.html"><code class="docutils literal"><span class="pre">gensim.utils</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.corpora.html"><code class="docutils literal"><span class="pre">gensim.corpora</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.models.html"><code class="docutils literal"><span class="pre">gensim.models</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.parsing.html"><code class="docutils literal"><span class="pre">gensim.parsing</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.scripts.html"><code class="docutils literal"><span class="pre">gensim.scripts</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.similarities.html"><code class="docutils literal"><span class="pre">gensim.similarities</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.summarization.html"><code class="docutils literal"><span class="pre">gensim.summarization</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.topic_coherence.html"><code class="docutils literal"><span class="pre">gensim.topic_coherence</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/simserver.html"><code class="docutils literal"><span class="pre">simserver</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/word2vec.html"><code class="docutils literal"><span class="pre">word2vec</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/stop_words.html"><code class="docutils literal"><span class="pre">stop_words</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/nltk.classify.html"><code class="docutils literal"><span class="pre">nltk.classify</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/nltk.cluster.html"><code class="docutils literal"><span class="pre">nltk.cluster</span></code></a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">NLP APIs</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          













<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../nltk.html">nltk</a> &raquo;</li>
        
          <li><a href="../tag.html">nltk.tag</a> &raquo;</li>
        
      <li>nltk.tag.tnt</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for nltk.tag.tnt</h1><div class="highlight"><pre>
<span></span><span class="c1"># Natural Language Toolkit: TnT Tagger</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2001-2015 NLTK Project</span>
<span class="c1"># Author: Sam Huston &lt;sjh900@gmail.com&gt;</span>
<span class="c1">#</span>
<span class="c1"># URL: &lt;http://nltk.org/&gt;</span>
<span class="c1"># For license information, see LICENSE.TXT</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Implementation of &#39;TnT - A Statisical Part of Speech Tagger&#39;</span>
<span class="sd">by Thorsten Brants</span>

<span class="sd">http://acl.ldc.upenn.edu/A/A00/A00-1031.pdf</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log</span>

<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">itemgetter</span>

<span class="kn">from</span> <span class="nn">nltk.probability</span> <span class="kn">import</span> <span class="n">FreqDist</span><span class="p">,</span> <span class="n">ConditionalFreqDist</span>
<span class="kn">from</span> <span class="nn">nltk.tag.api</span> <span class="kn">import</span> <span class="n">TaggerI</span>

<div class="viewcode-block" id="TnT"><a class="viewcode-back" href="../../../generated/generated/nltk.TnT.html#nltk.TnT">[docs]</a><span class="k">class</span> <span class="nc">TnT</span><span class="p">(</span><span class="n">TaggerI</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    TnT - Statistical POS tagger</span>

<span class="sd">    IMPORTANT NOTES:</span>

<span class="sd">    * DOES NOT AUTOMATICALLY DEAL WITH UNSEEN WORDS</span>

<span class="sd">      - It is possible to provide an untrained POS tagger to</span>
<span class="sd">        create tags for unknown words, see __init__ function</span>

<span class="sd">    * SHOULD BE USED WITH SENTENCE-DELIMITED INPUT</span>

<span class="sd">      - Due to the nature of this tagger, it works best when</span>
<span class="sd">        trained over sentence delimited input.</span>
<span class="sd">      - However it still produces good results if the training</span>
<span class="sd">        data and testing data are separated on all punctuation eg: [,.?!]</span>
<span class="sd">      - Input for training is expected to be a list of sentences</span>
<span class="sd">        where each sentence is a list of (word, tag) tuples</span>
<span class="sd">      - Input for tag function is a single sentence</span>
<span class="sd">        Input for tagdata function is a list of sentences</span>
<span class="sd">        Output is of a similar form</span>

<span class="sd">    * Function provided to process text that is unsegmented</span>

<span class="sd">      - Please see basic_sent_chop()</span>


<span class="sd">    TnT uses a second order Markov model to produce tags for</span>
<span class="sd">    a sequence of input, specifically:</span>

<span class="sd">      argmax [Proj(P(t_i|t_i-1,t_i-2)P(w_i|t_i))] P(t_T+1 | t_T)</span>

<span class="sd">    IE: the maximum projection of a set of probabilities</span>

<span class="sd">    The set of possible tags for a given word is derived</span>
<span class="sd">    from the training data. It is the set of all tags</span>
<span class="sd">    that exact word has been assigned.</span>

<span class="sd">    To speed up and get more precision, we can use log addition</span>
<span class="sd">    to instead multiplication, specifically:</span>

<span class="sd">      argmax [Sigma(log(P(t_i|t_i-1,t_i-2))+log(P(w_i|t_i)))] +</span>
<span class="sd">             log(P(t_T+1|t_T))</span>

<span class="sd">    The probability of a tag for a given word is the linear</span>
<span class="sd">    interpolation of 3 markov models; a zero-order, first-order,</span>
<span class="sd">    and a second order model.</span>

<span class="sd">      P(t_i| t_i-1, t_i-2) = l1*P(t_i) + l2*P(t_i| t_i-1) +</span>
<span class="sd">                             l3*P(t_i| t_i-1, t_i-2)</span>

<span class="sd">    A beam search is used to limit the memory usage of the algorithm.</span>
<span class="sd">    The degree of the beam can be changed using N in the initialization.</span>
<span class="sd">    N represents the maximum number of possible solutions to maintain</span>
<span class="sd">    while tagging.</span>

<span class="sd">    It is possible to differentiate the tags which are assigned to</span>
<span class="sd">    capitalized words. However this does not result in a significant</span>
<span class="sd">    gain in the accuracy of the results.</span>
<span class="sd">    &#39;&#39;&#39;</span>

<div class="viewcode-block" id="TnT.__init__"><a class="viewcode-back" href="../../../generated/generated/nltk.TnT.__init__.html#nltk.TnT.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unk</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">Trained</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Construct a TnT statistical tagger. Tagger must be trained</span>
<span class="sd">        before being used to tag input.</span>

<span class="sd">        :param unk: instance of a POS tagger, conforms to TaggerI</span>
<span class="sd">        :type  unk:(TaggerI)</span>
<span class="sd">        :param Trained: Indication that the POS tagger is trained or not</span>
<span class="sd">        :type  Trained: boolean</span>
<span class="sd">        :param N: Beam search degree (see above)</span>
<span class="sd">        :type  N:(int)</span>
<span class="sd">        :param C: Capitalization flag</span>
<span class="sd">        :type  C: boolean</span>

<span class="sd">        Initializer, creates frequency distributions to be used</span>
<span class="sd">        for tagging</span>

<span class="sd">        _lx values represent the portion of the tri/bi/uni taggers</span>
<span class="sd">        to be used to calculate the probability</span>

<span class="sd">        N value is the number of possible solutions to maintain</span>
<span class="sd">        while tagging. A good value for this is 1000</span>

<span class="sd">        C is a boolean value which specifies to use or</span>
<span class="sd">        not use the Capitalization of the word as additional</span>
<span class="sd">        information for tagging.</span>
<span class="sd">        NOTE: using capitalization may not increase the accuracy</span>
<span class="sd">        of the tagger</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_uni</span>  <span class="o">=</span> <span class="n">FreqDist</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bi</span>   <span class="o">=</span> <span class="n">ConditionalFreqDist</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tri</span>  <span class="o">=</span> <span class="n">ConditionalFreqDist</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wd</span>   <span class="o">=</span> <span class="n">ConditionalFreqDist</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_eos</span>  <span class="o">=</span> <span class="n">ConditionalFreqDist</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_l1</span>   <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_l2</span>   <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_l3</span>   <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_N</span>    <span class="o">=</span> <span class="n">N</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_C</span>    <span class="o">=</span> <span class="n">C</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_T</span>    <span class="o">=</span> <span class="n">Trained</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_unk</span> <span class="o">=</span> <span class="n">unk</span>

        <span class="c1"># statistical tools (ignore or delete me)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unknown</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">known</span> <span class="o">=</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="TnT.train"><a class="viewcode-back" href="../../../generated/generated/nltk.TnT.train.html#nltk.TnT.train">[docs]</a>    <span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Uses a set of tagged data to train the tagger.</span>
<span class="sd">        If an unknown word tagger is specified,</span>
<span class="sd">        it is trained on the same data.</span>

<span class="sd">        :param data: List of lists of (word, tag) tuples</span>
<span class="sd">        :type data: tuple(str)</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># Ensure that local C flag is initialized before use</span>
        <span class="n">C</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unk</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_T</span> <span class="o">==</span> <span class="bp">False</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_unk</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">sent</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">history</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;BOS&#39;</span><span class="p">,</span><span class="bp">False</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;BOS&#39;</span><span class="p">,</span><span class="bp">False</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">sent</span><span class="p">:</span>

                <span class="c1"># if capitalization is requested,</span>
                <span class="c1"># and the word begins with a capital</span>
                <span class="c1"># set local flag C to True</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_C</span> <span class="ow">and</span> <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isupper</span><span class="p">():</span> <span class="n">C</span><span class="o">=</span><span class="bp">True</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_wd</span><span class="p">[</span><span class="n">w</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_uni</span><span class="p">[(</span><span class="n">t</span><span class="p">,</span><span class="n">C</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_bi</span><span class="p">[</span><span class="n">history</span><span class="p">[</span><span class="mi">1</span><span class="p">]][(</span><span class="n">t</span><span class="p">,</span><span class="n">C</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_tri</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">history</span><span class="p">)][(</span><span class="n">t</span><span class="p">,</span><span class="n">C</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="n">history</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">t</span><span class="p">,</span><span class="n">C</span><span class="p">))</span>
                <span class="n">history</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

                <span class="c1"># set local flag C to false for the next word</span>
                <span class="n">C</span> <span class="o">=</span> <span class="bp">False</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_eos</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="s1">&#39;EOS&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>


        <span class="c1"># compute lambda values from the trained frequency distributions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_lambda</span><span class="p">()</span></div>

        <span class="c1">#(debugging -- ignore or delete me)</span>
        <span class="c1">#print &quot;lambdas&quot;</span>
        <span class="c1">#print i, self._l1, i, self._l2, i, self._l3</span>


    <span class="k">def</span> <span class="nf">_compute_lambda</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        creates lambda values based upon training data</span>

<span class="sd">        NOTE: no need to explicitly reference C,</span>
<span class="sd">        it is contained within the tag variable :: tag == (tag,C)</span>

<span class="sd">        for each tag trigram (t1, t2, t3)</span>
<span class="sd">        depending on the maximum value of</span>
<span class="sd">        - f(t1,t2,t3)-1 / f(t1,t2)-1</span>
<span class="sd">        - f(t2,t3)-1 / f(t2)-1</span>
<span class="sd">        - f(t3)-1 / N-1</span>

<span class="sd">        increment l3,l2, or l1 by f(t1,t2,t3)</span>

<span class="sd">        ISSUES -- Resolutions:</span>
<span class="sd">        if 2 values are equal, increment both lambda values</span>
<span class="sd">        by (f(t1,t2,t3) / 2)</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># temporary lambda variables</span>
        <span class="n">tl1</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">tl2</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">tl3</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># for each t1,t2 in system</span>
        <span class="k">for</span> <span class="n">history</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tri</span><span class="o">.</span><span class="n">conditions</span><span class="p">():</span>
            <span class="p">(</span><span class="n">h1</span><span class="p">,</span> <span class="n">h2</span><span class="p">)</span> <span class="o">=</span> <span class="n">history</span>

            <span class="c1"># for each t3 given t1,t2 in system</span>
            <span class="c1"># (NOTE: tag actually represents (tag,C))</span>
            <span class="c1"># However no effect within this function</span>
            <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tri</span><span class="p">[</span><span class="n">history</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

                <span class="c1"># if there has only been 1 occurrence of this tag in the data</span>
                <span class="c1"># then ignore this trigram.</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uni</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># safe_div provides a safe floating point division</span>
                <span class="c1"># it returns -1 if the denominator is 0</span>
                <span class="n">c3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_safe_div</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_tri</span><span class="p">[</span><span class="n">history</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tri</span><span class="p">[</span><span class="n">history</span><span class="p">]</span><span class="o">.</span><span class="n">N</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">c2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_safe_div</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_bi</span><span class="p">[</span><span class="n">h2</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bi</span><span class="p">[</span><span class="n">h2</span><span class="p">]</span><span class="o">.</span><span class="n">N</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">c1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_safe_div</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_uni</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_uni</span><span class="o">.</span><span class="n">N</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>


                <span class="c1"># if c1 is the maximum value:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">c1</span> <span class="o">&gt;</span> <span class="n">c3</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">c1</span> <span class="o">&gt;</span> <span class="n">c2</span><span class="p">):</span>
                    <span class="n">tl1</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tri</span><span class="p">[</span><span class="n">history</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span>

                <span class="c1"># if c2 is the maximum value</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">c2</span> <span class="o">&gt;</span> <span class="n">c3</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">c2</span> <span class="o">&gt;</span> <span class="n">c1</span><span class="p">):</span>
                    <span class="n">tl2</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tri</span><span class="p">[</span><span class="n">history</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span>

                <span class="c1"># if c3 is the maximum value</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">c3</span> <span class="o">&gt;</span> <span class="n">c2</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">c3</span> <span class="o">&gt;</span> <span class="n">c1</span><span class="p">):</span>
                    <span class="n">tl3</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tri</span><span class="p">[</span><span class="n">history</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span>

                <span class="c1"># if c3, and c2 are equal and larger than c1</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">c3</span> <span class="o">==</span> <span class="n">c2</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">c3</span> <span class="o">&gt;</span> <span class="n">c1</span><span class="p">):</span>
                    <span class="n">tl2</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tri</span><span class="p">[</span><span class="n">history</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.0</span>
                    <span class="n">tl3</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tri</span><span class="p">[</span><span class="n">history</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.0</span>

                <span class="c1"># if c1, and c2 are equal and larger than c3</span>
                <span class="c1"># this might be a dumb thing to do....(not sure yet)</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">c2</span> <span class="o">==</span> <span class="n">c1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">c1</span> <span class="o">&gt;</span> <span class="n">c3</span><span class="p">):</span>
                    <span class="n">tl1</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tri</span><span class="p">[</span><span class="n">history</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.0</span>
                    <span class="n">tl2</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tri</span><span class="p">[</span><span class="n">history</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.0</span>

                <span class="c1"># otherwise there might be a problem</span>
                <span class="c1"># eg: all values = 0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">#print &quot;Problem&quot;, c1, c2 ,c3</span>
                    <span class="k">pass</span>

        <span class="c1"># Lambda normalisation:</span>
        <span class="c1"># ensures that l1+l2+l3 = 1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_l1</span> <span class="o">=</span> <span class="n">tl1</span> <span class="o">/</span> <span class="p">(</span><span class="n">tl1</span><span class="o">+</span><span class="n">tl2</span><span class="o">+</span><span class="n">tl3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_l2</span> <span class="o">=</span> <span class="n">tl2</span> <span class="o">/</span> <span class="p">(</span><span class="n">tl1</span><span class="o">+</span><span class="n">tl2</span><span class="o">+</span><span class="n">tl3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_l3</span> <span class="o">=</span> <span class="n">tl3</span> <span class="o">/</span> <span class="p">(</span><span class="n">tl1</span><span class="o">+</span><span class="n">tl2</span><span class="o">+</span><span class="n">tl3</span><span class="p">)</span>



    <span class="k">def</span> <span class="nf">_safe_div</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Safe floating point division function, does not allow division by 0</span>
<span class="sd">        returns -1 if the denominator is 0</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">v2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">v1</span> <span class="o">/</span> <span class="n">v2</span>

<div class="viewcode-block" id="TnT.tagdata"><a class="viewcode-back" href="../../../generated/generated/nltk.TnT.tagdata.html#nltk.TnT.tagdata">[docs]</a>    <span class="k">def</span> <span class="nf">tagdata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Tags each sentence in a list of sentences</span>

<span class="sd">        :param data:list of list of words</span>
<span class="sd">        :type data: [[string,],]</span>
<span class="sd">        :return: list of list of (word, tag) tuples</span>

<span class="sd">        Invokes tag(sent) function for each sentence</span>
<span class="sd">        compiles the results into a list of tagged sentences</span>
<span class="sd">        each tagged sentence is a list of (word, tag) tuples</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sent</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">res1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tag</span><span class="p">(</span><span class="n">sent</span><span class="p">)</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="TnT.tag"><a class="viewcode-back" href="../../../generated/generated/nltk.TnT.tag.html#nltk.TnT.tag">[docs]</a>    <span class="k">def</span> <span class="nf">tag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Tags a single sentence</span>

<span class="sd">        :param data: list of words</span>
<span class="sd">        :type data: [string,]</span>

<span class="sd">        :return: [(word, tag),]</span>

<span class="sd">        Calls recursive function &#39;_tagword&#39;</span>
<span class="sd">        to produce a list of tags</span>

<span class="sd">        Associates the sequence of returned tags</span>
<span class="sd">        with the correct words in the input sequence</span>

<span class="sd">        returns a list of (word, tag) tuples</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">current_state</span> <span class="o">=</span> <span class="p">[([</span><span class="s1">&#39;BOS&#39;</span><span class="p">,</span> <span class="s1">&#39;BOS&#39;</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">)]</span>

        <span class="n">sent</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="n">tags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tagword</span><span class="p">(</span><span class="n">sent</span><span class="p">,</span> <span class="n">current_state</span><span class="p">)</span>

        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sent</span><span class="p">)):</span>
            <span class="c1"># unpack and discard the C flags</span>
            <span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">C</span><span class="p">)</span> <span class="o">=</span> <span class="n">tags</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">sent</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">res</span></div>


    <span class="k">def</span> <span class="nf">_tagword</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sent</span><span class="p">,</span> <span class="n">current_states</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :param sent : List of words remaining in the sentence</span>
<span class="sd">        :type sent  : [word,]</span>
<span class="sd">        :param current_states : List of possible tag combinations for</span>
<span class="sd">                                the sentence so far, and the log probability</span>
<span class="sd">                                associated with each tag combination</span>
<span class="sd">        :type current_states  : [([tag, ], logprob), ]</span>

<span class="sd">        Tags the first word in the sentence and</span>
<span class="sd">        recursively tags the reminder of sentence</span>

<span class="sd">        Uses formula specified above to calculate the probability</span>
<span class="sd">        of a particular tag</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># if this word marks the end of the sentance,</span>
        <span class="c1"># return the most probable tag</span>
        <span class="k">if</span> <span class="n">sent</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">logp</span><span class="p">)</span> <span class="o">=</span> <span class="n">current_states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">h</span>

        <span class="c1"># otherwise there are more words to be tagged</span>
        <span class="n">word</span> <span class="o">=</span> <span class="n">sent</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">sent</span> <span class="o">=</span> <span class="n">sent</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">new_states</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># if the Capitalisation is requested,</span>
        <span class="c1"># initalise the flag for this word</span>
        <span class="n">C</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_C</span> <span class="ow">and</span> <span class="n">word</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isupper</span><span class="p">():</span> <span class="n">C</span><span class="o">=</span><span class="bp">True</span>

        <span class="c1"># if word is known</span>
        <span class="c1"># compute the set of possible tags</span>
        <span class="c1"># and their associated log probabilities</span>
        <span class="k">if</span> <span class="n">word</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wd</span><span class="o">.</span><span class="n">conditions</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">known</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">for</span> <span class="p">(</span><span class="n">history</span><span class="p">,</span> <span class="n">curr_sent_logprob</span><span class="p">)</span> <span class="ow">in</span> <span class="n">current_states</span><span class="p">:</span>
                <span class="n">logprobs</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wd</span><span class="p">[</span><span class="n">word</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">p_uni</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uni</span><span class="o">.</span><span class="n">freq</span><span class="p">((</span><span class="n">t</span><span class="p">,</span><span class="n">C</span><span class="p">))</span>
                    <span class="n">p_bi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bi</span><span class="p">[</span><span class="n">history</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">freq</span><span class="p">((</span><span class="n">t</span><span class="p">,</span><span class="n">C</span><span class="p">))</span>
                    <span class="n">p_tri</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tri</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">history</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:])]</span><span class="o">.</span><span class="n">freq</span><span class="p">((</span><span class="n">t</span><span class="p">,</span><span class="n">C</span><span class="p">))</span>
                    <span class="n">p_wd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wd</span><span class="p">[</span><span class="n">word</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uni</span><span class="p">[(</span><span class="n">t</span><span class="p">,</span><span class="n">C</span><span class="p">)]</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_l1</span> <span class="o">*</span><span class="n">p_uni</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_l2</span> <span class="o">*</span><span class="n">p_bi</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_l3</span> <span class="o">*</span><span class="n">p_tri</span>
                    <span class="n">p2</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">log</span><span class="p">(</span><span class="n">p_wd</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

                    <span class="n">logprobs</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">t</span><span class="p">,</span><span class="n">C</span><span class="p">),</span> <span class="n">p2</span><span class="p">))</span>


                <span class="c1"># compute the result of appending each tag to this history</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">logprob</span><span class="p">)</span> <span class="ow">in</span> <span class="n">logprobs</span><span class="p">:</span>
                    <span class="n">new_states</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">history</span> <span class="o">+</span> <span class="p">[</span><span class="n">tag</span><span class="p">],</span>
                                       <span class="n">curr_sent_logprob</span> <span class="o">+</span> <span class="n">logprob</span><span class="p">))</span>




        <span class="c1"># otherwise a new word, set of possible tags is unknown</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unknown</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># since a set of possible tags,</span>
            <span class="c1"># and the probability of each specific tag</span>
            <span class="c1"># can not be returned from most classifiers:</span>
            <span class="c1"># specify that any unknown words are tagged with certainty</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="c1"># if no unknown word tagger has been specified</span>
            <span class="c1"># then use the tag &#39;Unk&#39;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unk</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">tag</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Unk&#39;</span><span class="p">,</span><span class="n">C</span><span class="p">)</span>

            <span class="c1"># otherwise apply the unknown word tagger</span>
            <span class="k">else</span> <span class="p">:</span>
                <span class="p">[(</span><span class="n">_w</span><span class="p">,</span> <span class="n">t</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_unk</span><span class="o">.</span><span class="n">tag</span><span class="p">([</span><span class="n">word</span><span class="p">]))</span>
                <span class="n">tag</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">C</span><span class="p">)</span>

            <span class="k">for</span> <span class="p">(</span><span class="n">history</span><span class="p">,</span> <span class="n">logprob</span><span class="p">)</span> <span class="ow">in</span> <span class="n">current_states</span><span class="p">:</span>
                <span class="n">history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>

            <span class="n">new_states</span> <span class="o">=</span> <span class="n">current_states</span>



        <span class="c1"># now have computed a set of possible new_states</span>

        <span class="c1"># sort states by log prob</span>
        <span class="c1"># set is now ordered greatest to least log probability</span>
        <span class="n">new_states</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

        <span class="c1"># del everything after N (threshold)</span>
        <span class="c1"># this is the beam search cut</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_states</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">:</span>
            <span class="n">new_states</span> <span class="o">=</span> <span class="n">new_states</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">]</span>


        <span class="c1"># compute the tags for the rest of the sentence</span>
        <span class="c1"># return the best list of tags for the sentence</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tagword</span><span class="p">(</span><span class="n">sent</span><span class="p">,</span> <span class="n">new_states</span><span class="p">)</span></div>


<span class="c1">########################################</span>
<span class="c1"># helper function -- basic sentence tokenizer</span>
<span class="c1">########################################</span>

<span class="k">def</span> <span class="nf">basic_sent_chop</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">raw</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Basic method for tokenizing input into sentences</span>
<span class="sd">    for this tagger:</span>

<span class="sd">    :param data: list of tokens (words or (word, tag) tuples)</span>
<span class="sd">    :type data: str or tuple(str, str)</span>
<span class="sd">    :param raw: boolean flag marking the input data</span>
<span class="sd">                as a list of words or a list of tagged words</span>
<span class="sd">    :type raw: bool</span>
<span class="sd">    :return: list of sentences</span>
<span class="sd">             sentences are a list of tokens</span>
<span class="sd">             tokens are the same as the input</span>

<span class="sd">    Function takes a list of tokens and separates the tokens into lists</span>
<span class="sd">    where each list represents a sentence fragment</span>
<span class="sd">    This function can separate both tagged and raw sequences into</span>
<span class="sd">    basic sentences.</span>

<span class="sd">    Sentence markers are the set of [,.!?]</span>

<span class="sd">    This is a simple method which enhances the performance of the TnT</span>
<span class="sd">    tagger. Better sentence tokenization will further enhance the results.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">new_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">curr_sent</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sent_mark</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;,&#39;</span><span class="p">,</span><span class="s1">&#39;.&#39;</span><span class="p">,</span><span class="s1">&#39;?&#39;</span><span class="p">,</span><span class="s1">&#39;!&#39;</span><span class="p">]</span>


    <span class="k">if</span> <span class="n">raw</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">sent_mark</span><span class="p">:</span>
                <span class="n">curr_sent</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
                <span class="n">new_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_sent</span><span class="p">)</span>
                <span class="n">curr_sent</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">curr_sent</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">word</span><span class="p">,</span><span class="n">tag</span><span class="p">)</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">sent_mark</span><span class="p">:</span>
                <span class="n">curr_sent</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">word</span><span class="p">,</span><span class="n">tag</span><span class="p">))</span>
                <span class="n">new_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_sent</span><span class="p">)</span>
                <span class="n">curr_sent</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">curr_sent</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">word</span><span class="p">,</span><span class="n">tag</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">new_data</span>



<span class="k">def</span> <span class="nf">demo</span><span class="p">():</span>
    <span class="kn">from</span> <span class="nn">nltk.corpus</span> <span class="kn">import</span> <span class="n">brown</span>
    <span class="n">sents</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">brown</span><span class="o">.</span><span class="n">tagged_sents</span><span class="p">())</span>
    <span class="n">test</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">brown</span><span class="o">.</span><span class="n">sents</span><span class="p">())</span>

    <span class="c1"># create and train the tagger</span>
    <span class="n">tagger</span> <span class="o">=</span> <span class="n">TnT</span><span class="p">()</span>
    <span class="n">tagger</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">sents</span><span class="p">[</span><span class="mi">200</span><span class="p">:</span><span class="mi">1000</span><span class="p">])</span>

    <span class="c1"># tag some data</span>
    <span class="n">tagged_data</span> <span class="o">=</span> <span class="n">tagger</span><span class="o">.</span><span class="n">tagdata</span><span class="p">(</span><span class="n">test</span><span class="p">[</span><span class="mi">100</span><span class="p">:</span><span class="mi">120</span><span class="p">])</span>

    <span class="c1"># print results</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tagged_data</span><span class="p">)):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">tagged_data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">sents</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">100</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
            <span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">print</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">demo2</span><span class="p">():</span>
    <span class="kn">from</span> <span class="nn">nltk.corpus</span> <span class="kn">import</span> <span class="n">treebank</span>

    <span class="n">d</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">treebank</span><span class="o">.</span><span class="n">tagged_sents</span><span class="p">())</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">TnT</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">TnT</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">t</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">d</span><span class="p">[(</span><span class="mi">11</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="p">:])</span>
    <span class="n">s</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">d</span><span class="p">[(</span><span class="mi">11</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="p">:])</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="n">tacc</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">100</span><span class="p">:((</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="p">)])</span>
        <span class="n">tp_un</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">unknown</span> <span class="o">/</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">known</span> <span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="n">unknown</span><span class="p">)</span>
        <span class="n">tp_kn</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">known</span> <span class="o">/</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">known</span> <span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="n">unknown</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">unknown</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">t</span><span class="o">.</span><span class="n">known</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Capitalization off:&#39;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Accuracy:&#39;</span><span class="p">,</span> <span class="n">tacc</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Percentage known:&#39;</span><span class="p">,</span> <span class="n">tp_kn</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Percentage unknown:&#39;</span><span class="p">,</span> <span class="n">tp_un</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Accuracy over known words:&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">tacc</span> <span class="o">/</span> <span class="n">tp_kn</span><span class="p">))</span>

        <span class="n">sacc</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">100</span><span class="p">:((</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="p">)])</span>
        <span class="n">sp_un</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">unknown</span> <span class="o">/</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">known</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="n">unknown</span><span class="p">)</span>
        <span class="n">sp_kn</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">known</span> <span class="o">/</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">known</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="n">unknown</span><span class="p">)</span>
        <span class="n">s</span><span class="o">.</span><span class="n">unknown</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">s</span><span class="o">.</span><span class="n">known</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Capitalization on:&#39;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Accuracy:&#39;</span><span class="p">,</span> <span class="n">sacc</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Percentage known:&#39;</span><span class="p">,</span> <span class="n">sp_kn</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Percentage unknown:&#39;</span><span class="p">,</span> <span class="n">sp_un</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Accuracy over known words:&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">sacc</span> <span class="o">/</span> <span class="n">sp_kn</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">demo3</span><span class="p">():</span>
    <span class="kn">from</span> <span class="nn">nltk.corpus</span> <span class="kn">import</span> <span class="n">treebank</span><span class="p">,</span> <span class="n">brown</span>

    <span class="n">d</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">treebank</span><span class="o">.</span><span class="n">tagged_sents</span><span class="p">())</span>
    <span class="n">e</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">brown</span><span class="o">.</span><span class="n">tagged_sents</span><span class="p">())</span>

    <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="p">[:</span><span class="mi">1000</span><span class="p">]</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="p">[:</span><span class="mi">1000</span><span class="p">]</span>

    <span class="n">d10</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">*</span><span class="mf">0.1</span><span class="p">)</span>
    <span class="n">e10</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">*</span><span class="mf">0.1</span><span class="p">)</span>

    <span class="n">tknacc</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">sknacc</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">tallacc</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">sallacc</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">tknown</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">sknown</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>

        <span class="n">t</span> <span class="o">=</span> <span class="n">TnT</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">TnT</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

        <span class="n">dtest</span> <span class="o">=</span> <span class="n">d</span><span class="p">[(</span><span class="n">i</span><span class="o">*</span><span class="n">d10</span><span class="p">):((</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">d10</span><span class="p">)]</span>
        <span class="n">etest</span> <span class="o">=</span> <span class="n">e</span><span class="p">[(</span><span class="n">i</span><span class="o">*</span><span class="n">e10</span><span class="p">):((</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">e10</span><span class="p">)]</span>

        <span class="n">dtrain</span> <span class="o">=</span> <span class="n">d</span><span class="p">[:(</span><span class="n">i</span><span class="o">*</span><span class="n">d10</span><span class="p">)]</span> <span class="o">+</span> <span class="n">d</span><span class="p">[((</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">d10</span><span class="p">):]</span>
        <span class="n">etrain</span> <span class="o">=</span> <span class="n">e</span><span class="p">[:(</span><span class="n">i</span><span class="o">*</span><span class="n">e10</span><span class="p">)]</span> <span class="o">+</span> <span class="n">e</span><span class="p">[((</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">e10</span><span class="p">):]</span>

        <span class="n">t</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">dtrain</span><span class="p">)</span>
        <span class="n">s</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">etrain</span><span class="p">)</span>

        <span class="n">tacc</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">dtest</span><span class="p">)</span>
        <span class="n">tp_un</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">unknown</span> <span class="o">/</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">known</span> <span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="n">unknown</span><span class="p">)</span>
        <span class="n">tp_kn</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">known</span> <span class="o">/</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">known</span> <span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="n">unknown</span><span class="p">)</span>
        <span class="n">tknown</span> <span class="o">+=</span> <span class="n">tp_kn</span>
        <span class="n">t</span><span class="o">.</span><span class="n">unknown</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">t</span><span class="o">.</span><span class="n">known</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">sacc</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">etest</span><span class="p">)</span>
        <span class="n">sp_un</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">unknown</span> <span class="o">/</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">known</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="n">unknown</span><span class="p">)</span>
        <span class="n">sp_kn</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">known</span> <span class="o">/</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">known</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="n">unknown</span><span class="p">)</span>
        <span class="n">sknown</span> <span class="o">+=</span> <span class="n">sp_kn</span>
        <span class="n">s</span><span class="o">.</span><span class="n">unknown</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">s</span><span class="o">.</span><span class="n">known</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">tknacc</span> <span class="o">+=</span> <span class="p">(</span><span class="n">tacc</span> <span class="o">/</span> <span class="n">tp_kn</span><span class="p">)</span>
        <span class="n">sknacc</span> <span class="o">+=</span> <span class="p">(</span><span class="n">sacc</span> <span class="o">/</span> <span class="n">tp_kn</span><span class="p">)</span>
        <span class="n">tallacc</span> <span class="o">+=</span> <span class="n">tacc</span>
        <span class="n">sallacc</span> <span class="o">+=</span> <span class="n">sacc</span>

        <span class="c1">#print i+1, (tacc / tp_kn), i+1, (sacc / tp_kn), i+1, tacc, i+1, sacc</span>


    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;brown: acc over words known:&quot;</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">tknacc</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;     : overall accuracy:&quot;</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">tallacc</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;     : words known:&quot;</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">tknown</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;treebank: acc over words known:&quot;</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">sknacc</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;        : overall accuracy:&quot;</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">sallacc</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;        : words known:&quot;</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">sknown</span><span class="p">)</span>




</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../../_static/copybutton.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>