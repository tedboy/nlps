

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>nltk.tokenize.punkt</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="" href="../../../index.html"/>
        <link rel="up" title="nltk.tokenize" href="../tokenize.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> NLP APIs
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../gensim_tutorial/tutorial.html">Gensim Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../nltk_intro.html">Natural Language Toolkit</a></li>
</ul>
<p class="caption"><span class="caption-text">Autogenerated API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/nltk.html"><code class="docutils literal"><span class="pre">nltk</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.html"><code class="docutils literal"><span class="pre">gensim</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.interfaces.html"><code class="docutils literal"><span class="pre">gensim.interfaces</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.matutils.html"><code class="docutils literal"><span class="pre">gensim.matutils</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.utils.html"><code class="docutils literal"><span class="pre">gensim.utils</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.corpora.html"><code class="docutils literal"><span class="pre">gensim.corpora</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.models.html"><code class="docutils literal"><span class="pre">gensim.models</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.parsing.html"><code class="docutils literal"><span class="pre">gensim.parsing</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.scripts.html"><code class="docutils literal"><span class="pre">gensim.scripts</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.similarities.html"><code class="docutils literal"><span class="pre">gensim.similarities</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.summarization.html"><code class="docutils literal"><span class="pre">gensim.summarization</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gensim.topic_coherence.html"><code class="docutils literal"><span class="pre">gensim.topic_coherence</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/simserver.html"><code class="docutils literal"><span class="pre">simserver</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/word2vec.html"><code class="docutils literal"><span class="pre">word2vec</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/stop_words.html"><code class="docutils literal"><span class="pre">stop_words</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/nltk.classify.html"><code class="docutils literal"><span class="pre">nltk.classify</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/nltk.cluster.html"><code class="docutils literal"><span class="pre">nltk.cluster</span></code></a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">NLP APIs</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          













<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../nltk.html">nltk</a> &raquo;</li>
        
          <li><a href="../tokenize.html">nltk.tokenize</a> &raquo;</li>
        
      <li>nltk.tokenize.punkt</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for nltk.tokenize.punkt</h1><div class="highlight"><pre>
<span></span><span class="c1"># Natural Language Toolkit: Punkt sentence tokenizer</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2001-2015 NLTK Project</span>
<span class="c1"># Algorithm: Kiss &amp; Strunk (2006)</span>
<span class="c1"># Author: Willy &lt;willy@csse.unimelb.edu.au&gt; (original Python port)</span>
<span class="c1">#         Steven Bird &lt;stevenbird1@gmail.com&gt; (additions)</span>
<span class="c1">#         Edward Loper &lt;edloper@gmail.com&gt; (rewrite)</span>
<span class="c1">#         Joel Nothman &lt;jnothman@student.usyd.edu.au&gt; (almost rewrite)</span>
<span class="c1">#         Arthur Darcet &lt;arthur@darcet.fr&gt; (fixes)</span>
<span class="c1"># URL: &lt;http://nltk.org/&gt;</span>
<span class="c1"># For license information, see LICENSE.TXT</span>

<span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">Punkt Sentence Tokenizer</span>

<span class="sd">This tokenizer divides a text into a list of sentences,</span>
<span class="sd">by using an unsupervised algorithm to build a model for abbreviation</span>
<span class="sd">words, collocations, and words that start sentences.  It must be</span>
<span class="sd">trained on a large collection of plaintext in the target language</span>
<span class="sd">before it can be used.</span>

<span class="sd">The NLTK data package includes a pre-trained Punkt tokenizer for</span>
<span class="sd">English.</span>

<span class="sd">    &gt;&gt;&gt; import nltk.data</span>
<span class="sd">    &gt;&gt;&gt; text = &#39;&#39;&#39;</span>
<span class="sd">    ... Punkt knows that the periods in Mr. Smith and Johann S. Bach</span>
<span class="sd">    ... do not mark sentence boundaries.  And sometimes sentences</span>
<span class="sd">    ... can start with non-capitalized words.  i is a good variable</span>
<span class="sd">    ... name.</span>
<span class="sd">    ... &#39;&#39;&#39;</span>
<span class="sd">    &gt;&gt;&gt; sent_detector = nltk.data.load(&#39;tokenizers/punkt/english.pickle&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;\n-----\n&#39;.join(sent_detector.tokenize(text.strip())))</span>
<span class="sd">    Punkt knows that the periods in Mr. Smith and Johann S. Bach</span>
<span class="sd">    do not mark sentence boundaries.</span>
<span class="sd">    -----</span>
<span class="sd">    And sometimes sentences</span>
<span class="sd">    can start with non-capitalized words.</span>
<span class="sd">    -----</span>
<span class="sd">    i is a good variable</span>
<span class="sd">    name.</span>

<span class="sd">(Note that whitespace from the original text, including newlines, is</span>
<span class="sd">retained in the output.)</span>

<span class="sd">Punctuation following sentences is also included by default</span>
<span class="sd">(from NLTK 3.0 onwards). It can be excluded with the realign_boundaries</span>
<span class="sd">flag.</span>

<span class="sd">    &gt;&gt;&gt; text = &#39;&#39;&#39;</span>
<span class="sd">    ... (How does it deal with this parenthesis?)  &quot;It should be part of the</span>
<span class="sd">    ... previous sentence.&quot; &quot;(And the same with this one.)&quot; (&#39;And this one!&#39;)</span>
<span class="sd">    ... &quot;(&#39;(And (this)) &#39;?)&quot; [(and this. )]</span>
<span class="sd">    ... &#39;&#39;&#39;</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;\n-----\n&#39;.join(</span>
<span class="sd">    ...     sent_detector.tokenize(text.strip())))</span>
<span class="sd">    (How does it deal with this parenthesis?)</span>
<span class="sd">    -----</span>
<span class="sd">    &quot;It should be part of the</span>
<span class="sd">    previous sentence.&quot;</span>
<span class="sd">    -----</span>
<span class="sd">    &quot;(And the same with this one.)&quot;</span>
<span class="sd">    -----</span>
<span class="sd">    (&#39;And this one!&#39;)</span>
<span class="sd">    -----</span>
<span class="sd">    &quot;(&#39;(And (this)) &#39;?)&quot;</span>
<span class="sd">    -----</span>
<span class="sd">    [(and this. )]</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;\n-----\n&#39;.join(</span>
<span class="sd">    ...     sent_detector.tokenize(text.strip(), realign_boundaries=False)))</span>
<span class="sd">    (How does it deal with this parenthesis?</span>
<span class="sd">    -----</span>
<span class="sd">    )  &quot;It should be part of the</span>
<span class="sd">    previous sentence.</span>
<span class="sd">    -----</span>
<span class="sd">    &quot; &quot;(And the same with this one.</span>
<span class="sd">    -----</span>
<span class="sd">    )&quot; (&#39;And this one!</span>
<span class="sd">    -----</span>
<span class="sd">    &#39;)</span>
<span class="sd">    &quot;(&#39;(And (this)) &#39;?</span>
<span class="sd">    -----</span>
<span class="sd">    )&quot; [(and this.</span>
<span class="sd">    -----</span>
<span class="sd">    )]</span>

<span class="sd">However, Punkt is designed to learn parameters (a list of abbreviations, etc.)</span>
<span class="sd">unsupervised from a corpus similar to the target domain. The pre-packaged models</span>
<span class="sd">may therefore be unsuitable: use ``PunktSentenceTokenizer(text)`` to learn</span>
<span class="sd">parameters from the given text.</span>

<span class="sd">:class:`.PunktTrainer` learns parameters such as a list of abbreviations</span>
<span class="sd">(without supervision) from portions of text. Using a ``PunktTrainer`` directly</span>
<span class="sd">allows for incremental training and modification of the hyper-parameters used</span>
<span class="sd">to decide what is considered an abbreviation, etc.</span>

<span class="sd">The algorithm for this tokenizer is described in::</span>

<span class="sd">  Kiss, Tibor and Strunk, Jan (2006): Unsupervised Multilingual Sentence</span>
<span class="sd">    Boundary Detection.  Computational Linguistics 32: 485-525.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">unicode_literals</span><span class="p">,</span> <span class="n">division</span>

<span class="c1"># TODO: Make orthographic heuristic less susceptible to overtraining</span>
<span class="c1"># TODO: Frequent sentence starters optionally exclude always-capitalised words</span>
<span class="c1"># FIXME: Problem with ending string with e.g. &#39;!!!&#39; -&gt; &#39;!! !&#39;</span>

<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="kn">from</span> <span class="nn">nltk.compat</span> <span class="kn">import</span> <span class="n">unicode_repr</span><span class="p">,</span> <span class="n">python_2_unicode_compatible</span><span class="p">,</span> <span class="n">string_types</span>
<span class="kn">from</span> <span class="nn">nltk.probability</span> <span class="kn">import</span> <span class="n">FreqDist</span>
<span class="kn">from</span> <span class="nn">nltk.tokenize.api</span> <span class="kn">import</span> <span class="n">TokenizerI</span>

<span class="c1">######################################################################</span>
<span class="c1">#{ Orthographic Context Constants</span>
<span class="c1">######################################################################</span>
<span class="c1"># The following constants are used to describe the orthographic</span>
<span class="c1"># contexts in which a word can occur.  BEG=beginning, MID=middle,</span>
<span class="c1"># UNK=unknown, UC=uppercase, LC=lowercase, NC=no case.</span>

<span class="n">_ORTHO_BEG_UC</span>    <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
<span class="sd">&quot;&quot;&quot;Orthographic context: beginning of a sentence with upper case.&quot;&quot;&quot;</span>

<span class="n">_ORTHO_MID_UC</span>    <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span>
<span class="sd">&quot;&quot;&quot;Orthographic context: middle of a sentence with upper case.&quot;&quot;&quot;</span>

<span class="n">_ORTHO_UNK_UC</span>    <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span>
<span class="sd">&quot;&quot;&quot;Orthographic context: unknown position in a sentence with upper case.&quot;&quot;&quot;</span>

<span class="n">_ORTHO_BEG_LC</span>    <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span>
<span class="sd">&quot;&quot;&quot;Orthographic context: beginning of a sentence with lower case.&quot;&quot;&quot;</span>

<span class="n">_ORTHO_MID_LC</span>    <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span>
<span class="sd">&quot;&quot;&quot;Orthographic context: middle of a sentence with lower case.&quot;&quot;&quot;</span>

<span class="n">_ORTHO_UNK_LC</span>    <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span>
<span class="sd">&quot;&quot;&quot;Orthographic context: unknown position in a sentence with lower case.&quot;&quot;&quot;</span>

<span class="n">_ORTHO_UC</span> <span class="o">=</span> <span class="n">_ORTHO_BEG_UC</span> <span class="o">+</span> <span class="n">_ORTHO_MID_UC</span> <span class="o">+</span> <span class="n">_ORTHO_UNK_UC</span>
<span class="sd">&quot;&quot;&quot;Orthographic context: occurs with upper case.&quot;&quot;&quot;</span>

<span class="n">_ORTHO_LC</span> <span class="o">=</span> <span class="n">_ORTHO_BEG_LC</span> <span class="o">+</span> <span class="n">_ORTHO_MID_LC</span> <span class="o">+</span> <span class="n">_ORTHO_UNK_LC</span>
<span class="sd">&quot;&quot;&quot;Orthographic context: occurs with lower case.&quot;&quot;&quot;</span>

<span class="n">_ORTHO_MAP</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">(</span><span class="s1">&#39;initial&#39;</span><span class="p">,</span>  <span class="s1">&#39;upper&#39;</span><span class="p">):</span> <span class="n">_ORTHO_BEG_UC</span><span class="p">,</span>
        <span class="p">(</span><span class="s1">&#39;internal&#39;</span><span class="p">,</span> <span class="s1">&#39;upper&#39;</span><span class="p">):</span> <span class="n">_ORTHO_MID_UC</span><span class="p">,</span>
        <span class="p">(</span><span class="s1">&#39;unknown&#39;</span><span class="p">,</span>  <span class="s1">&#39;upper&#39;</span><span class="p">):</span> <span class="n">_ORTHO_UNK_UC</span><span class="p">,</span>
        <span class="p">(</span><span class="s1">&#39;initial&#39;</span><span class="p">,</span>  <span class="s1">&#39;lower&#39;</span><span class="p">):</span> <span class="n">_ORTHO_BEG_LC</span><span class="p">,</span>
        <span class="p">(</span><span class="s1">&#39;internal&#39;</span><span class="p">,</span> <span class="s1">&#39;lower&#39;</span><span class="p">):</span> <span class="n">_ORTHO_MID_LC</span><span class="p">,</span>
        <span class="p">(</span><span class="s1">&#39;unknown&#39;</span><span class="p">,</span>  <span class="s1">&#39;lower&#39;</span><span class="p">):</span> <span class="n">_ORTHO_UNK_LC</span><span class="p">,</span>
<span class="p">}</span>
<span class="sd">&quot;&quot;&quot;A map from context position and first-letter case to the</span>
<span class="sd">appropriate orthographic context flag.&quot;&quot;&quot;</span>

<span class="c1">#} (end orthographic context constants)</span>
<span class="c1">######################################################################</span>

<span class="c1">######################################################################</span>
<span class="c1">#{ Decision reasons for debugging</span>
<span class="c1">######################################################################</span>

<span class="n">REASON_DEFAULT_DECISION</span> <span class="o">=</span> <span class="s1">&#39;default decision&#39;</span>
<span class="n">REASON_KNOWN_COLLOCATION</span> <span class="o">=</span> <span class="s1">&#39;known collocation (both words)&#39;</span>
<span class="n">REASON_ABBR_WITH_ORTHOGRAPHIC_HEURISTIC</span> <span class="o">=</span> <span class="s1">&#39;abbreviation + orthographic heuristic&#39;</span>
<span class="n">REASON_ABBR_WITH_SENTENCE_STARTER</span> <span class="o">=</span> <span class="s1">&#39;abbreviation + frequent sentence starter&#39;</span>
<span class="n">REASON_INITIAL_WITH_ORTHOGRAPHIC_HEURISTIC</span> <span class="o">=</span> <span class="s1">&#39;initial + orthographic heuristic&#39;</span>
<span class="n">REASON_NUMBER_WITH_ORTHOGRAPHIC_HEURISTIC</span> <span class="o">=</span> <span class="s1">&#39;initial + orthographic heuristic&#39;</span>
<span class="n">REASON_INITIAL_WITH_SPECIAL_ORTHOGRAPHIC_HEURISTIC</span> <span class="o">=</span> <span class="s1">&#39;initial + special orthographic heuristic&#39;</span>

<span class="c1">#} (end decision reasons for debugging)</span>
<span class="c1">######################################################################</span>

<span class="c1">######################################################################</span>
<span class="c1">#{ Language-dependent variables</span>
<span class="c1">######################################################################</span>

<span class="k">class</span> <span class="nc">PunktLanguageVars</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Stores variables, mostly regular expressions, which may be</span>
<span class="sd">    language-dependent for correct application of the algorithm.</span>
<span class="sd">    An extension of this class may modify its properties to suit</span>
<span class="sd">    a language other than English; an instance can then be passed</span>
<span class="sd">    as an argument to PunktSentenceTokenizer and PunktTrainer</span>
<span class="sd">    constructors.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;_re_period_context&#39;</span><span class="p">,</span> <span class="s1">&#39;_re_word_tokenizer&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># All modifications to the class are performed by inheritance.</span>
        <span class="c1"># Non-default parameters to be pickled must be defined in the inherited</span>
        <span class="c1"># class.</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="n">sent_end_chars</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="s1">&#39;?&#39;</span><span class="p">,</span> <span class="s1">&#39;!&#39;</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;Characters which are candidates for sentence boundaries&quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_re_sent_end_chars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;[</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sent_end_chars</span><span class="p">))</span>

    <span class="n">internal_punctuation</span> <span class="o">=</span> <span class="s1">&#39;,:;&#39;</span> <span class="c1"># might want to extend this..</span>
    <span class="sd">&quot;&quot;&quot;sentence internal punctuation, which indicates an abbreviation if</span>
<span class="sd">    preceded by a period-final token.&quot;&quot;&quot;</span>

    <span class="n">re_boundary_realignment</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">r&#39;[&quot;</span><span class="se">\&#39;</span><span class="s1">)\]}]+?(?:\s+|(?=--)|$)&#39;</span><span class="p">,</span>
            <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;Used to realign punctuation that should be included in a sentence</span>
<span class="sd">    although it follows the period (or ?, !).&quot;&quot;&quot;</span>

    <span class="n">_re_word_start</span>    <span class="o">=</span> <span class="s2">r&quot;[^\(</span><span class="se">\&quot;</span><span class="s2">\`{\[:;&amp;\#\*@\)}\]\-,]&quot;</span>
    <span class="sd">&quot;&quot;&quot;Excludes some characters from starting word tokens&quot;&quot;&quot;</span>

    <span class="n">_re_non_word_chars</span>   <span class="o">=</span> <span class="s2">r&quot;(?:[?!)</span><span class="se">\&quot;</span><span class="s2">;}\]\*:@\&#39;\({\[])&quot;</span>
    <span class="sd">&quot;&quot;&quot;Characters that cannot appear within words&quot;&quot;&quot;</span>

    <span class="n">_re_multi_char_punct</span> <span class="o">=</span> <span class="s2">r&quot;(?:\-{2,}|\.{2,}|(?:\.\s){2,}\.)&quot;</span>
    <span class="sd">&quot;&quot;&quot;Hyphen and ellipsis are multi-character punctuation&quot;&quot;&quot;</span>

    <span class="n">_word_tokenize_fmt</span> <span class="o">=</span> <span class="s1">r&#39;&#39;&#39;(</span>
<span class="s1">        </span><span class="si">%(MultiChar)s</span><span class="s1"></span>
<span class="s1">        |</span>
<span class="s1">        (?=</span><span class="si">%(WordStart)s</span><span class="s1">)\S+?  # Accept word characters until end is found</span>
<span class="s1">        (?= # Sequences marking a word&#39;s end</span>
<span class="s1">            \s|                                 # White-space</span>
<span class="s1">            $|                                  # End-of-string</span>
<span class="s1">            </span><span class="si">%(NonWord)s</span><span class="s1">|</span><span class="si">%(MultiChar)s</span><span class="s1">|          # Punctuation</span>
<span class="s1">            ,(?=$|\s|</span><span class="si">%(NonWord)s</span><span class="s1">|</span><span class="si">%(MultiChar)s</span><span class="s1">) # Comma if at end of word</span>
<span class="s1">        )</span>
<span class="s1">        |</span>
<span class="s1">        \S</span>
<span class="s1">    )&#39;&#39;&#39;</span>
    <span class="sd">&quot;&quot;&quot;Format of a regular expression to split punctuation from words,</span>
<span class="sd">    excluding period.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_word_tokenizer_re</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compiles and returns a regular expression for word tokenization&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_re_word_tokenizer</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_re_word_tokenizer</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_word_tokenize_fmt</span> <span class="o">%</span>
                <span class="p">{</span>
                    <span class="s1">&#39;NonWord&#39;</span><span class="p">:</span>   <span class="bp">self</span><span class="o">.</span><span class="n">_re_non_word_chars</span><span class="p">,</span>
                    <span class="s1">&#39;MultiChar&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_re_multi_char_punct</span><span class="p">,</span>
                    <span class="s1">&#39;WordStart&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_re_word_start</span><span class="p">,</span>
                <span class="p">},</span>
                <span class="n">re</span><span class="o">.</span><span class="n">UNICODE</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_re_word_tokenizer</span>

    <span class="k">def</span> <span class="nf">word_tokenize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tokenize a string to split off punctuation other than periods&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_word_tokenizer_re</span><span class="p">()</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

    <span class="n">_period_context_fmt</span> <span class="o">=</span> <span class="s2">r&quot;&quot;&quot;</span>
<span class="s2">        \S*                          # some word material</span>
<span class="s2">        </span><span class="si">%(SentEndChars)s</span><span class="s2">             # a potential sentence ending</span>
<span class="s2">        (?=(?P&lt;after_tok&gt;</span>
<span class="s2">            </span><span class="si">%(NonWord)s</span><span class="s2">              # either other punctuation</span>
<span class="s2">            |</span>
<span class="s2">            \s+(?P&lt;next_tok&gt;\S+)     # or whitespace and some other token</span>
<span class="s2">        ))&quot;&quot;&quot;</span>
    <span class="sd">&quot;&quot;&quot;Format of a regular expression to find contexts including possible</span>
<span class="sd">    sentence boundaries. Matches token which the possible sentence boundary</span>
<span class="sd">    ends, and matches the following token within a lookahead expression.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">period_context_re</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compiles and returns a regular expression to find contexts</span>
<span class="sd">        including possible sentence boundaries.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_re_period_context</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_re_period_context</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_period_context_fmt</span> <span class="o">%</span>
                <span class="p">{</span>
                    <span class="s1">&#39;NonWord&#39;</span><span class="p">:</span>      <span class="bp">self</span><span class="o">.</span><span class="n">_re_non_word_chars</span><span class="p">,</span>
                    <span class="s1">&#39;SentEndChars&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_re_sent_end_chars</span><span class="p">,</span>
                <span class="p">},</span>
                <span class="n">re</span><span class="o">.</span><span class="n">UNICODE</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_re_period_context</span>


<span class="n">_re_non_punct</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">r&#39;[^\W\d]&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">UNICODE</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;Matches token types that are not merely punctuation. (Types for</span>
<span class="sd">numeric tokens are changed to ##number## and hence contain alpha.)&quot;&quot;&quot;</span>

<span class="c1">#}</span>
<span class="c1">######################################################################</span>



<span class="c1">#////////////////////////////////////////////////////////////</span>
<span class="c1">#{ Helper Functions</span>
<span class="c1">#////////////////////////////////////////////////////////////</span>

<span class="k">def</span> <span class="nf">_pair_iter</span><span class="p">(</span><span class="n">it</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Yields pairs of tokens from the given iterator such that each input</span>
<span class="sd">    token will appear as the first element in a yielded tuple. The last</span>
<span class="sd">    pair will have None as its second element.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
    <span class="n">prev</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
        <span class="k">yield</span> <span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">el</span><span class="p">)</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">el</span>
    <span class="k">yield</span> <span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

<span class="c1">######################################################################</span>
<span class="c1">#{ Punkt Parameters</span>
<span class="c1">######################################################################</span>

<span class="k">class</span> <span class="nc">PunktParameters</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Stores data used to perform sentence boundary detection with Punkt.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">abbrev_types</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="sd">&quot;&quot;&quot;A set of word types for known abbreviations.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">collocations</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="sd">&quot;&quot;&quot;A set of word type tuples for known common collocations</span>
<span class="sd">        where the first word ends in a period.  E.g., (&#39;S.&#39;, &#39;Bach&#39;)</span>
<span class="sd">        is a common collocation in a text that discusses &#39;Johann</span>
<span class="sd">        S. Bach&#39;.  These count as negative evidence for sentence</span>
<span class="sd">        boundaries.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sent_starters</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="sd">&quot;&quot;&quot;A set of word types for words that often appear at the</span>
<span class="sd">        beginning of sentences.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ortho_context</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;A dictionary mapping word types to the set of orthographic</span>
<span class="sd">        contexts that word type appears in.  Contexts are represented</span>
<span class="sd">        by adding orthographic context flags: ...&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">clear_abbrevs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">abbrev_types</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">clear_collocations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collocations</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">clear_sent_starters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sent_starters</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">clear_ortho_context</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ortho_context</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_ortho_context</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typ</span><span class="p">,</span> <span class="n">flag</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ortho_context</span><span class="p">[</span><span class="n">typ</span><span class="p">]</span> <span class="o">|=</span> <span class="n">flag</span>

    <span class="k">def</span> <span class="nf">_debug_ortho_context</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typ</span><span class="p">):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ortho_context</span><span class="p">[</span><span class="n">typ</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">c</span> <span class="o">&amp;</span> <span class="n">_ORTHO_BEG_UC</span><span class="p">:</span>
            <span class="k">yield</span> <span class="s1">&#39;BEG-UC&#39;</span>
        <span class="k">if</span> <span class="n">c</span> <span class="o">&amp;</span> <span class="n">_ORTHO_MID_UC</span><span class="p">:</span>
            <span class="k">yield</span> <span class="s1">&#39;MID-UC&#39;</span>
        <span class="k">if</span> <span class="n">c</span> <span class="o">&amp;</span> <span class="n">_ORTHO_UNK_UC</span><span class="p">:</span>
            <span class="k">yield</span> <span class="s1">&#39;UNK-UC&#39;</span>
        <span class="k">if</span> <span class="n">c</span> <span class="o">&amp;</span> <span class="n">_ORTHO_BEG_LC</span><span class="p">:</span>
            <span class="k">yield</span> <span class="s1">&#39;BEG-LC&#39;</span>
        <span class="k">if</span> <span class="n">c</span> <span class="o">&amp;</span> <span class="n">_ORTHO_MID_LC</span><span class="p">:</span>
            <span class="k">yield</span> <span class="s1">&#39;MID-LC&#39;</span>
        <span class="k">if</span> <span class="n">c</span> <span class="o">&amp;</span> <span class="n">_ORTHO_UNK_LC</span><span class="p">:</span>
            <span class="k">yield</span> <span class="s1">&#39;UNK-LC&#39;</span>

<span class="c1">######################################################################</span>
<span class="c1">#{ PunktToken</span>
<span class="c1">######################################################################</span>

<span class="nd">@python_2_unicode_compatible</span>
<span class="k">class</span> <span class="nc">PunktToken</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Stores a token of text with annotations produced during</span>
<span class="sd">    sentence boundary detection.&quot;&quot;&quot;</span>

    <span class="n">_properties</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;parastart&#39;</span><span class="p">,</span> <span class="s1">&#39;linestart&#39;</span><span class="p">,</span>
        <span class="s1">&#39;sentbreak&#39;</span><span class="p">,</span> <span class="s1">&#39;abbr&#39;</span><span class="p">,</span> <span class="s1">&#39;ellipsis&#39;</span>
    <span class="p">]</span>
    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;tok&#39;</span><span class="p">,</span> <span class="s1">&#39;type&#39;</span><span class="p">,</span> <span class="s1">&#39;period_final&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">_properties</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tok</span> <span class="o">=</span> <span class="n">tok</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_type</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">period_final</span> <span class="o">=</span> <span class="n">tok</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_properties</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>

    <span class="c1">#////////////////////////////////////////////////////////////</span>
    <span class="c1">#{ Regular expressions for properties</span>
    <span class="c1">#////////////////////////////////////////////////////////////</span>
    <span class="c1"># Note: [A-Za-z] is approximated by [^\W\d] in the general case.</span>
    <span class="n">_RE_ELLIPSIS</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">r&#39;\.\.+$&#39;</span><span class="p">)</span>
    <span class="n">_RE_NUMERIC</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">r&#39;^-?[\.,]?\d[\d,\.-]*\.?$&#39;</span><span class="p">)</span>
    <span class="n">_RE_INITIAL</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">r&#39;[^\W\d]\.$&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">UNICODE</span><span class="p">)</span>
    <span class="n">_RE_ALPHA</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">r&#39;[^\W\d]+$&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">UNICODE</span><span class="p">)</span>

    <span class="c1">#////////////////////////////////////////////////////////////</span>
    <span class="c1">#{ Derived properties</span>
    <span class="c1">#////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">_get_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tok</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a case-normalized representation of the token.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RE_NUMERIC</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;##number##&#39;</span><span class="p">,</span> <span class="n">tok</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">type_no_period</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The type with its final period removed if it has one.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;.&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">type_no_sentperiod</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The type with its final period removed if it is marked as a</span>
<span class="sd">        sentence break.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sentbreak</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_no_period</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">first_upper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if the token&#39;s first character is uppercase.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tok</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isupper</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">first_lower</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if the token&#39;s first character is lowercase.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tok</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">islower</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">first_case</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_lower</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;lower&#39;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_upper</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;upper&#39;</span>
        <span class="k">return</span> <span class="s1">&#39;none&#39;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_ellipsis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if the token text is that of an ellipsis.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RE_ELLIPSIS</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tok</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if the token text is that of a number.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;##number##&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_initial</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if the token text is that of an initial.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RE_INITIAL</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tok</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if the token text is all alphabetic.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RE_ALPHA</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tok</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_non_punct</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if the token is either a number or is alphabetic.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_re_non_punct</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>

    <span class="c1">#////////////////////////////////////////////////////////////</span>
    <span class="c1">#{ String representation</span>
    <span class="c1">#////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A string representation of the token that can reproduce it</span>
<span class="sd">        with eval(), which lists all the token&#39;s non-default</span>
<span class="sd">        annotations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typestr</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39; type=</span><span class="si">%s</span><span class="s1">,&#39;</span> <span class="o">%</span> <span class="n">unicode_repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
                   <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tok</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="n">propvals</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">=</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">unicode_repr</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_properties</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">(</span><span class="si">%s</span><span class="s1">,</span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span>
            <span class="n">unicode_repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tok</span><span class="p">),</span> <span class="n">typestr</span><span class="p">,</span> <span class="n">propvals</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A string representation akin to that used by Kiss and Strunk.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tok</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">abbr</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="s1">&#39;&lt;A&gt;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ellipsis</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="s1">&#39;&lt;E&gt;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sentbreak</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="s1">&#39;&lt;S&gt;&#39;</span>
        <span class="k">return</span> <span class="n">res</span>

<span class="c1">######################################################################</span>
<span class="c1">#{ Punkt base class</span>
<span class="c1">######################################################################</span>

<span class="k">class</span> <span class="nc">PunktBaseClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Includes common components of PunktTrainer and PunktSentenceTokenizer.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lang_vars</span><span class="o">=</span><span class="n">PunktLanguageVars</span><span class="p">(),</span> <span class="n">token_cls</span><span class="o">=</span><span class="n">PunktToken</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="n">PunktParameters</span><span class="p">()):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_params</span> <span class="o">=</span> <span class="n">params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lang_vars</span> <span class="o">=</span> <span class="n">lang_vars</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Token</span> <span class="o">=</span> <span class="n">token_cls</span>
        <span class="sd">&quot;&quot;&quot;The collection of parameters that determines the behavior</span>
<span class="sd">        of the punkt tokenizer.&quot;&quot;&quot;</span>

    <span class="c1">#////////////////////////////////////////////////////////////</span>
    <span class="c1">#{ Word tokenization</span>
    <span class="c1">#////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">_tokenize_words</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plaintext</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Divide the given text into tokens, using the punkt word</span>
<span class="sd">        segmentation regular expression, and generate the resulting list</span>
<span class="sd">        of tokens augmented as three-tuples with two boolean values for whether</span>
<span class="sd">        the given token occurs at the start of a paragraph or a new line,</span>
<span class="sd">        respectively.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parastart</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">plaintext</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>
                <span class="n">line_toks</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lang_vars</span><span class="o">.</span><span class="n">word_tokenize</span><span class="p">(</span><span class="n">line</span><span class="p">))</span>

                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Token</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">line_toks</span><span class="p">),</span>
                        <span class="n">parastart</span><span class="o">=</span><span class="n">parastart</span><span class="p">,</span> <span class="n">linestart</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="n">parastart</span> <span class="o">=</span> <span class="bp">False</span>

                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">line_toks</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Token</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">parastart</span> <span class="o">=</span> <span class="bp">True</span>


    <span class="c1">#////////////////////////////////////////////////////////////</span>
    <span class="c1">#{ Annotation Procedures</span>
    <span class="c1">#////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">_annotate_first_pass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform the first pass of annotation, which makes decisions</span>
<span class="sd">        based purely based on the word type of each word:</span>

<span class="sd">          - &#39;?&#39;, &#39;!&#39;, and &#39;.&#39; are marked as sentence breaks.</span>
<span class="sd">          - sequences of two or more periods are marked as ellipsis.</span>
<span class="sd">          - any word ending in &#39;.&#39; that&#39;s a known abbreviation is</span>
<span class="sd">            marked as an abbreviation.</span>
<span class="sd">          - any other word ending in &#39;.&#39; is marked as a sentence break.</span>

<span class="sd">        Return these annotations as a tuple of three sets:</span>

<span class="sd">          - sentbreak_toks: The indices of all sentence breaks.</span>
<span class="sd">          - abbrev_toks: The indices of all abbreviations.</span>
<span class="sd">          - ellipsis_toks: The indices of all ellipsis marks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">aug_tok</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_first_pass_annotation</span><span class="p">(</span><span class="n">aug_tok</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">aug_tok</span>

    <span class="k">def</span> <span class="nf">_first_pass_annotation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aug_tok</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs type-based annotation on a single token.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">tok</span> <span class="o">=</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">tok</span>

        <span class="k">if</span> <span class="n">tok</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lang_vars</span><span class="o">.</span><span class="n">sent_end_chars</span><span class="p">:</span>
            <span class="n">aug_tok</span><span class="o">.</span><span class="n">sentbreak</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">is_ellipsis</span><span class="p">:</span>
            <span class="n">aug_tok</span><span class="o">.</span><span class="n">ellipsis</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">period_final</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">tok</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;..&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">tok</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">abbrev_types</span> <span class="ow">or</span>
                <span class="n">tok</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">abbrev_types</span><span class="p">):</span>

                <span class="n">aug_tok</span><span class="o">.</span><span class="n">abbr</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">aug_tok</span><span class="o">.</span><span class="n">sentbreak</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="k">return</span>

<span class="c1">######################################################################</span>
<span class="c1">#{ Punkt Trainer</span>
<span class="c1">######################################################################</span>


<span class="k">class</span> <span class="nc">PunktTrainer</span><span class="p">(</span><span class="n">PunktBaseClass</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Learns parameters used in Punkt sentence boundary detection.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_text</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
            <span class="n">lang_vars</span><span class="o">=</span><span class="n">PunktLanguageVars</span><span class="p">(),</span> <span class="n">token_cls</span><span class="o">=</span><span class="n">PunktToken</span><span class="p">):</span>

        <span class="n">PunktBaseClass</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lang_vars</span><span class="o">=</span><span class="n">lang_vars</span><span class="p">,</span>
                <span class="n">token_cls</span><span class="o">=</span><span class="n">token_cls</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span> <span class="o">=</span> <span class="n">FreqDist</span><span class="p">()</span>
        <span class="sd">&quot;&quot;&quot;A frequency distribution giving the frequency of each</span>
<span class="sd">        case-normalized token type in the training data.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_num_period_toks</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="sd">&quot;&quot;&quot;The number of words ending in period in the training data.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_collocation_fdist</span> <span class="o">=</span> <span class="n">FreqDist</span><span class="p">()</span>
        <span class="sd">&quot;&quot;&quot;A frequency distribution giving the frequency of all</span>
<span class="sd">        bigrams in the training data where the first word ends in a</span>
<span class="sd">        period.  Bigrams are encoded as tuples of word types.</span>
<span class="sd">        Especially common collocations are extracted from this</span>
<span class="sd">        frequency distribution, and stored in</span>
<span class="sd">        ``_params``.``collocations &lt;PunktParameters.collocations&gt;``.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_sent_starter_fdist</span> <span class="o">=</span> <span class="n">FreqDist</span><span class="p">()</span>
        <span class="sd">&quot;&quot;&quot;A frequency distribution giving the frequency of all words</span>
<span class="sd">        that occur at the training data at the beginning of a sentence</span>
<span class="sd">        (after the first pass of annotation).  Especially common</span>
<span class="sd">        sentence starters are extracted from this frequency</span>
<span class="sd">        distribution, and stored in ``_params.sent_starters``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_sentbreak_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="sd">&quot;&quot;&quot;The total number of sentence breaks identified in training, used for</span>
<span class="sd">        calculating the frequent sentence starter heuristic.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_finalized</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="sd">&quot;&quot;&quot;A flag as to whether the training has been finalized by finding</span>
<span class="sd">        collocations and sentence starters, or whether finalize_training()</span>
<span class="sd">        still needs to be called.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">train_text</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">train_text</span><span class="p">,</span> <span class="n">verbose</span><span class="p">,</span> <span class="n">finalize</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates and returns parameters for sentence boundary detection as</span>
<span class="sd">        derived from training.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finalized</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">finalize_training</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span>

    <span class="c1">#////////////////////////////////////////////////////////////</span>
    <span class="c1">#{ Customization Variables</span>
    <span class="c1">#////////////////////////////////////////////////////////////</span>

    <span class="n">ABBREV</span> <span class="o">=</span> <span class="mf">0.3</span>
    <span class="sd">&quot;&quot;&quot;cut-off value whether a &#39;token&#39; is an abbreviation&quot;&quot;&quot;</span>

    <span class="n">IGNORE_ABBREV_PENALTY</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="sd">&quot;&quot;&quot;allows the disabling of the abbreviation penalty heuristic, which</span>
<span class="sd">    exponentially disadvantages words that are found at times without a</span>
<span class="sd">    final period.&quot;&quot;&quot;</span>

    <span class="n">ABBREV_BACKOFF</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="sd">&quot;&quot;&quot;upper cut-off for Mikheev&#39;s(2002) abbreviation detection algorithm&quot;&quot;&quot;</span>

    <span class="n">COLLOCATION</span> <span class="o">=</span> <span class="mf">7.88</span>
    <span class="sd">&quot;&quot;&quot;minimal log-likelihood value that two tokens need to be considered</span>
<span class="sd">    as a collocation&quot;&quot;&quot;</span>

    <span class="n">SENT_STARTER</span> <span class="o">=</span> <span class="mi">30</span>
    <span class="sd">&quot;&quot;&quot;minimal log-likelihood value that a token requires to be considered</span>
<span class="sd">    as a frequent sentence starter&quot;&quot;&quot;</span>

    <span class="n">INCLUDE_ALL_COLLOCS</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="sd">&quot;&quot;&quot;this includes as potential collocations all word pairs where the first</span>
<span class="sd">    word ends in a period. It may be useful in corpora where there is a lot</span>
<span class="sd">    of variation that makes abbreviations like Mr difficult to identify.&quot;&quot;&quot;</span>

    <span class="n">INCLUDE_ABBREV_COLLOCS</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="sd">&quot;&quot;&quot;this includes as potential collocations all word pairs where the first</span>
<span class="sd">    word is an abbreviation. Such collocations override the orthographic</span>
<span class="sd">    heuristic, but not the sentence starter heuristic. This is overridden by</span>
<span class="sd">    INCLUDE_ALL_COLLOCS, and if both are false, only collocations with initials</span>
<span class="sd">    and ordinals are considered.&quot;&quot;&quot;</span>
    <span class="sd">&quot;&quot;&quot;&quot;&quot;&quot;</span>

    <span class="n">MIN_COLLOC_FREQ</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="sd">&quot;&quot;&quot;this sets a minimum bound on the number of times a bigram needs to</span>
<span class="sd">    appear before it can be considered a collocation, in addition to log</span>
<span class="sd">    likelihood statistics. This is useful when INCLUDE_ALL_COLLOCS is True.&quot;&quot;&quot;</span>

    <span class="c1">#////////////////////////////////////////////////////////////</span>
    <span class="c1">#{ Training..</span>
    <span class="c1">#////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">finalize</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collects training data from a given text. If finalize is True, it</span>
<span class="sd">        will determine all the parameters for sentence boundary detection. If</span>
<span class="sd">        not, this will be delayed until get_params() or finalize_training() is</span>
<span class="sd">        called. If verbose is True, abbreviations found will be listed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Break the text into tokens; record which token indices correspond to</span>
        <span class="c1"># line starts and paragraph starts; and determine their types.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_train_tokens</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tokenize_words</span><span class="p">(</span><span class="n">text</span><span class="p">),</span> <span class="n">verbose</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">finalize</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">finalize_training</span><span class="p">(</span><span class="n">verbose</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">train_tokens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">finalize</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collects training data from a given list of tokens.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_train_tokens</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_Token</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">),</span> <span class="n">verbose</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">finalize</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">finalize_training</span><span class="p">(</span><span class="n">verbose</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_train_tokens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">,</span> <span class="n">verbose</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_finalized</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="c1"># Ensure tokens are a list</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>

        <span class="c1"># Find the frequency of each case-normalized type.  (Don&#39;t</span>
        <span class="c1"># strip off final periods.)  Also keep track of the number of</span>
        <span class="c1"># tokens that end in periods.</span>
        <span class="k">for</span> <span class="n">aug_tok</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="p">[</span><span class="n">aug_tok</span><span class="o">.</span><span class="n">type</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">period_final</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_num_period_toks</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Look for new abbreviations, and for types that no longer are</span>
        <span class="n">unique_types</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unique_types</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">abbr</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">is_add</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reclassify_abbrev_types</span><span class="p">(</span><span class="n">unique_types</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">score</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ABBREV</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_add</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">abbrev_types</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">abbr</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="k">print</span><span class="p">((</span><span class="s1">&#39;  Abbreviation: [</span><span class="si">%6.4f</span><span class="s1">] </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span>
                               <span class="p">(</span><span class="n">score</span><span class="p">,</span> <span class="n">abbr</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_add</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">abbrev_types</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">abbr</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="k">print</span><span class="p">((</span><span class="s1">&#39;  Removed abbreviation: [</span><span class="si">%6.4f</span><span class="s1">] </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span>
                               <span class="p">(</span><span class="n">score</span><span class="p">,</span> <span class="n">abbr</span><span class="p">)))</span>

        <span class="c1"># Make a preliminary pass through the document, marking likely</span>
        <span class="c1"># sentence breaks, abbreviations, and ellipsis tokens.</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_annotate_first_pass</span><span class="p">(</span><span class="n">tokens</span><span class="p">))</span>

        <span class="c1"># Check what contexts each word type can appear in, given the</span>
        <span class="c1"># case of its first letter.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_get_orthography_data</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>

        <span class="c1"># We need total number of sentence breaks to find sentence starters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sentbreak_count</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_sentbreak_count</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>

        <span class="c1"># The remaining heuristics relate to pairs of tokens where the first</span>
        <span class="c1"># ends in a period.</span>
        <span class="k">for</span> <span class="n">aug_tok1</span><span class="p">,</span> <span class="n">aug_tok2</span> <span class="ow">in</span> <span class="n">_pair_iter</span><span class="p">(</span><span class="n">tokens</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">aug_tok1</span><span class="o">.</span><span class="n">period_final</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">aug_tok2</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Is the first token a rare abbreviation?</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_rare_abbrev_type</span><span class="p">(</span><span class="n">aug_tok1</span><span class="p">,</span> <span class="n">aug_tok2</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">abbrev_types</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">aug_tok1</span><span class="o">.</span><span class="n">type_no_period</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">((</span><span class="s1">&#39;  Rare Abbrev: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">aug_tok1</span><span class="o">.</span><span class="n">type</span><span class="p">))</span>

            <span class="c1"># Does second token have a high likelihood of starting a sentence?</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_potential_sent_starter</span><span class="p">(</span><span class="n">aug_tok2</span><span class="p">,</span> <span class="n">aug_tok1</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sent_starter_fdist</span><span class="p">[</span><span class="n">aug_tok2</span><span class="o">.</span><span class="n">type</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Is this bigram a potential collocation?</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_potential_collocation</span><span class="p">(</span><span class="n">aug_tok1</span><span class="p">,</span> <span class="n">aug_tok2</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_collocation_fdist</span><span class="p">[</span>
                    <span class="p">(</span><span class="n">aug_tok1</span><span class="o">.</span><span class="n">type_no_period</span><span class="p">,</span> <span class="n">aug_tok2</span><span class="o">.</span><span class="n">type_no_sentperiod</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_unique_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">aug_tok</span><span class="o">.</span><span class="n">type</span> <span class="k">for</span> <span class="n">aug_tok</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">finalize_training</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Uses data that has been gathered in training to determine likely</span>
<span class="sd">        collocations and sentence starters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">clear_sent_starters</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">typ</span><span class="p">,</span> <span class="n">ll</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_sent_starters</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">sent_starters</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">typ</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span><span class="p">((</span><span class="s1">&#39;  Sent Starter: [</span><span class="si">%6.4f</span><span class="s1">] </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ll</span><span class="p">,</span> <span class="n">typ</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">clear_collocations</span><span class="p">()</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">typ1</span><span class="p">,</span> <span class="n">typ2</span><span class="p">),</span> <span class="n">ll</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_collocations</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">collocations</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="p">(</span><span class="n">typ1</span><span class="p">,</span><span class="n">typ2</span><span class="p">)</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span><span class="p">((</span><span class="s1">&#39;  Collocation: [</span><span class="si">%6.4f</span><span class="s1">] </span><span class="si">%r</span><span class="s1">+</span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span>
                       <span class="p">(</span><span class="n">ll</span><span class="p">,</span> <span class="n">typ1</span><span class="p">,</span> <span class="n">typ2</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_finalized</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="c1">#////////////////////////////////////////////////////////////</span>
    <span class="c1">#{ Overhead reduction</span>
    <span class="c1">#////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">freq_threshold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ortho_thresh</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">type_thresh</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">colloc_thres</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">sentstart_thresh</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Allows memory use to be reduced after much training by removing data</span>
<span class="sd">        about rare tokens that are unlikely to have a statistical effect with</span>
<span class="sd">        further training. Entries occurring above the given thresholds will be</span>
<span class="sd">        retained.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ortho_thresh</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">old_oc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">ortho_context</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">clear_ortho_context</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">tok</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="p">[</span><span class="n">tok</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="n">ortho_thresh</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">ortho_context</span><span class="p">[</span><span class="n">tok</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_oc</span><span class="p">[</span><span class="n">tok</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq_threshold</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="p">,</span> <span class="n">type_thresh</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_collocation_fdist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq_threshold</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_collocation_fdist</span><span class="p">,</span> <span class="n">colloc_thres</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sent_starter_fdist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq_threshold</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sent_starter_fdist</span><span class="p">,</span> <span class="n">sentstart_thresh</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_freq_threshold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fdist</span><span class="p">,</span> <span class="n">threshold</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a FreqDist containing only data with counts below a given</span>
<span class="sd">        threshold, as well as a mapping (None -&gt; count_removed).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We assume that there is more data below the threshold than above it</span>
        <span class="c1"># and so create a new FreqDist rather than working in place.</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">FreqDist</span><span class="p">()</span>
        <span class="n">num_removed</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">fdist</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">fdist</span><span class="p">[</span><span class="n">tok</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">:</span>
                <span class="n">num_removed</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span><span class="p">[</span><span class="n">tok</span><span class="p">]</span> <span class="o">+=</span> <span class="n">count</span>
        <span class="n">res</span><span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">+=</span> <span class="n">num_removed</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="c1">#////////////////////////////////////////////////////////////</span>
    <span class="c1">#{ Orthographic data</span>
    <span class="c1">#////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">_get_orthography_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collect information about whether each token type occurs</span>
<span class="sd">        with different case patterns (i) overall, (ii) at</span>
<span class="sd">        sentence-initial positions, and (iii) at sentence-internal</span>
<span class="sd">        positions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># &#39;initial&#39; or &#39;internal&#39; or &#39;unknown&#39;</span>
        <span class="n">context</span> <span class="o">=</span> <span class="s1">&#39;internal&#39;</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">aug_tok</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">:</span>
            <span class="c1"># If we encounter a paragraph break, then it&#39;s a good sign</span>
            <span class="c1"># that it&#39;s a sentence break.  But err on the side of</span>
            <span class="c1"># caution (by not positing a sentence break) if we just</span>
            <span class="c1"># saw an abbreviation.</span>
            <span class="k">if</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">parastart</span> <span class="ow">and</span> <span class="n">context</span> <span class="o">!=</span> <span class="s1">&#39;unknown&#39;</span><span class="p">:</span>
                <span class="n">context</span> <span class="o">=</span> <span class="s1">&#39;initial&#39;</span>

            <span class="c1"># If we&#39;re at the beginning of a line, then we can&#39;t decide</span>
            <span class="c1"># between &#39;internal&#39; and &#39;initial&#39;.</span>
            <span class="k">if</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">linestart</span> <span class="ow">and</span> <span class="n">context</span> <span class="o">==</span> <span class="s1">&#39;internal&#39;</span><span class="p">:</span>
                <span class="n">context</span> <span class="o">=</span> <span class="s1">&#39;unknown&#39;</span>

            <span class="c1"># Find the case-normalized type of the token.  If it&#39;s a</span>
            <span class="c1"># sentence-final token, strip off the period.</span>
            <span class="n">typ</span> <span class="o">=</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">type_no_sentperiod</span>

            <span class="c1"># Update the orthographic context table.</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="n">_ORTHO_MAP</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">context</span><span class="p">,</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">first_case</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">flag</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">add_ortho_context</span><span class="p">(</span><span class="n">typ</span><span class="p">,</span> <span class="n">flag</span><span class="p">)</span>

            <span class="c1"># Decide whether the next word is at a sentence boundary.</span>
            <span class="k">if</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">sentbreak</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">aug_tok</span><span class="o">.</span><span class="n">is_number</span> <span class="ow">or</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">is_initial</span><span class="p">):</span>
                    <span class="n">context</span> <span class="o">=</span> <span class="s1">&#39;initial&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">context</span> <span class="o">=</span> <span class="s1">&#39;unknown&#39;</span>
            <span class="k">elif</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">ellipsis</span> <span class="ow">or</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">abbr</span><span class="p">:</span>
                <span class="n">context</span> <span class="o">=</span> <span class="s1">&#39;unknown&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">context</span> <span class="o">=</span> <span class="s1">&#39;internal&#39;</span>

    <span class="c1">#////////////////////////////////////////////////////////////</span>
    <span class="c1">#{ Abbreviations</span>
    <span class="c1">#////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">_reclassify_abbrev_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">types</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (Re)classifies each given token if</span>
<span class="sd">          - it is period-final and not a known abbreviation; or</span>
<span class="sd">          - it is not period-final and is otherwise a known abbreviation</span>
<span class="sd">        by checking whether its previous classification still holds according</span>
<span class="sd">        to the heuristics of section 3.</span>
<span class="sd">        Yields triples (abbr, score, is_add) where abbr is the type in question,</span>
<span class="sd">        score is its log-likelihood with penalties applied, and is_add specifies</span>
<span class="sd">        whether the present type is a candidate for inclusion or exclusion as an</span>
<span class="sd">        abbreviation, such that:</span>
<span class="sd">          - (is_add and score &gt;= 0.3)    suggests a new abbreviation; and</span>
<span class="sd">          - (not is_add and score &lt; 0.3) suggests excluding an abbreviation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># (While one could recalculate abbreviations from all .-final tokens at</span>
        <span class="c1"># every iteration, in cases requiring efficiency, the number of tokens</span>
        <span class="c1"># in the present training document will be much less.)</span>

        <span class="k">for</span> <span class="n">typ</span> <span class="ow">in</span> <span class="n">types</span><span class="p">:</span>
            <span class="c1"># Check some basic conditions, to rule out words that are</span>
            <span class="c1"># clearly not abbrev_types.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">_re_non_punct</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">typ</span><span class="p">)</span> <span class="ow">or</span> <span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;##number##&#39;</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">typ</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">typ</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">abbrev_types</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">typ</span> <span class="o">=</span> <span class="n">typ</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">is_add</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">typ</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">abbrev_types</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">is_add</span> <span class="o">=</span> <span class="bp">False</span>

            <span class="c1"># Count how many periods &amp; nonperiods are in the</span>
            <span class="c1"># candidate.</span>
            <span class="n">num_periods</span> <span class="o">=</span> <span class="n">typ</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">num_nonperiods</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">typ</span><span class="p">)</span> <span class="o">-</span> <span class="n">num_periods</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="c1"># Let &lt;a&gt; be the candidate without the period, and &lt;b&gt;</span>
            <span class="c1"># be the period.  Find a log likelihood ratio that</span>
            <span class="c1"># indicates whether &lt;ab&gt; occurs as a single unit (high</span>
            <span class="c1"># value of ll), or as two independent units &lt;a&gt; and</span>
            <span class="c1"># &lt;b&gt; (low value of ll).</span>
            <span class="n">count_with_period</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="p">[</span><span class="n">typ</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span><span class="p">]</span>
            <span class="n">count_without_period</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="p">[</span><span class="n">typ</span><span class="p">]</span>
            <span class="n">ll</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dunning_log_likelihood</span><span class="p">(</span>
                <span class="n">count_with_period</span> <span class="o">+</span> <span class="n">count_without_period</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_num_period_toks</span><span class="p">,</span> <span class="n">count_with_period</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="o">.</span><span class="n">N</span><span class="p">())</span>

            <span class="c1"># Apply three scaling factors to &#39;tweak&#39; the basic log</span>
            <span class="c1"># likelihood ratio:</span>
            <span class="c1">#   F_length: long word -&gt; less likely to be an abbrev</span>
            <span class="c1">#   F_periods: more periods -&gt; more likely to be an abbrev</span>
            <span class="c1">#   F_penalty: penalize occurrences w/o a period</span>
            <span class="n">f_length</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">num_nonperiods</span><span class="p">)</span>
            <span class="n">f_periods</span> <span class="o">=</span> <span class="n">num_periods</span>
            <span class="n">f_penalty</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">IGNORE_ABBREV_PENALTY</span><span class="p">)</span>
                    <span class="ow">or</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">num_nonperiods</span><span class="p">,</span> <span class="o">-</span><span class="n">count_without_period</span><span class="p">))</span>
            <span class="n">score</span> <span class="o">=</span> <span class="n">ll</span> <span class="o">*</span> <span class="n">f_length</span> <span class="o">*</span> <span class="n">f_periods</span> <span class="o">*</span> <span class="n">f_penalty</span>

            <span class="k">yield</span> <span class="n">typ</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">is_add</span>

    <span class="k">def</span> <span class="nf">find_abbrev_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recalculates abbreviations given type frequencies, despite no prior</span>
<span class="sd">        determination of abbreviations.</span>
<span class="sd">        This fails to include abbreviations otherwise found as &quot;rare&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">clear_abbrevs</span><span class="p">()</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="p">(</span><span class="n">typ</span> <span class="k">for</span> <span class="n">typ</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span> <span class="k">if</span> <span class="n">typ</span> <span class="ow">and</span> <span class="n">typ</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">abbr</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">is_add</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reclassify_abbrev_types</span><span class="p">(</span><span class="n">tokens</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">score</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ABBREV</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">abbrev_types</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">abbr</span><span class="p">)</span>

    <span class="c1"># This function combines the work done by the original code&#39;s</span>
    <span class="c1"># functions `count_orthography_context`, `get_orthography_count`,</span>
    <span class="c1"># and `get_rare_abbreviations`.</span>
    <span class="k">def</span> <span class="nf">_is_rare_abbrev_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cur_tok</span><span class="p">,</span> <span class="n">next_tok</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A word type is counted as a rare abbreviation if...</span>
<span class="sd">          - it&#39;s not already marked as an abbreviation</span>
<span class="sd">          - it occurs fewer than ABBREV_BACKOFF times</span>
<span class="sd">          - either it is followed by a sentence-internal punctuation</span>
<span class="sd">            mark, *or* it is followed by a lower-case word that</span>
<span class="sd">            sometimes appears with upper case, but never occurs with</span>
<span class="sd">            lower case at the beginning of sentences.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cur_tok</span><span class="o">.</span><span class="n">abbr</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">cur_tok</span><span class="o">.</span><span class="n">sentbreak</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="c1"># Find the case-normalized type of the token.  If it&#39;s</span>
        <span class="c1"># a sentence-final token, strip off the period.</span>
        <span class="n">typ</span> <span class="o">=</span> <span class="n">cur_tok</span><span class="o">.</span><span class="n">type_no_sentperiod</span>

        <span class="c1"># Proceed only if the type hasn&#39;t been categorized as an</span>
        <span class="c1"># abbreviation already, and is sufficiently rare...</span>
        <span class="n">count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="p">[</span><span class="n">typ</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="p">[</span><span class="n">typ</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">typ</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">abbrev_types</span> <span class="ow">or</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ABBREV_BACKOFF</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="c1"># Record this token as an abbreviation if the next</span>
        <span class="c1"># token is a sentence-internal punctuation mark.</span>
        <span class="c1"># [XX] :1 or check the whole thing??</span>
        <span class="k">if</span> <span class="n">next_tok</span><span class="o">.</span><span class="n">tok</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lang_vars</span><span class="o">.</span><span class="n">internal_punctuation</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>

        <span class="c1"># Record this type as an abbreviation if the next</span>
        <span class="c1"># token...  (i) starts with a lower case letter,</span>
        <span class="c1"># (ii) sometimes occurs with an uppercase letter,</span>
        <span class="c1"># and (iii) never occus with an uppercase letter</span>
        <span class="c1"># sentence-internally.</span>
        <span class="c1"># [xx] should the check for (ii) be modified??</span>
        <span class="k">elif</span> <span class="n">next_tok</span><span class="o">.</span><span class="n">first_lower</span><span class="p">:</span>
            <span class="n">typ2</span> <span class="o">=</span> <span class="n">next_tok</span><span class="o">.</span><span class="n">type_no_sentperiod</span>
            <span class="n">typ2ortho_context</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">ortho_context</span><span class="p">[</span><span class="n">typ2</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">typ2ortho_context</span> <span class="o">&amp;</span> <span class="n">_ORTHO_BEG_UC</span><span class="p">)</span> <span class="ow">and</span>
                 <span class="ow">not</span> <span class="p">(</span><span class="n">typ2ortho_context</span> <span class="o">&amp;</span> <span class="n">_ORTHO_MID_UC</span><span class="p">)</span> <span class="p">):</span>
                <span class="k">return</span> <span class="bp">True</span>

    <span class="c1">#////////////////////////////////////////////////////////////</span>
    <span class="c1">#{ Log Likelihoods</span>
    <span class="c1">#////////////////////////////////////////////////////////////</span>

    <span class="c1"># helper for _reclassify_abbrev_types:</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_dunning_log_likelihood</span><span class="p">(</span><span class="n">count_a</span><span class="p">,</span> <span class="n">count_b</span><span class="p">,</span> <span class="n">count_ab</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A function that calculates the modified Dunning log-likelihood</span>
<span class="sd">        ratio scores for abbreviation candidates.  The details of how</span>
<span class="sd">        this works is available in the paper.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">count_b</span> <span class="o">/</span> <span class="n">N</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="mf">0.99</span>

        <span class="n">null_hypo</span> <span class="o">=</span> <span class="p">(</span><span class="n">count_ab</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span> <span class="o">+</span>
                     <span class="p">(</span><span class="n">count_a</span> <span class="o">-</span> <span class="n">count_ab</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">p1</span><span class="p">))</span>
        <span class="n">alt_hypo</span>  <span class="o">=</span> <span class="p">(</span><span class="n">count_ab</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span> <span class="o">+</span>
                     <span class="p">(</span><span class="n">count_a</span> <span class="o">-</span> <span class="n">count_ab</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">p2</span><span class="p">))</span>

        <span class="n">likelihood</span> <span class="o">=</span> <span class="n">null_hypo</span> <span class="o">-</span> <span class="n">alt_hypo</span>

        <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">likelihood</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_col_log_likelihood</span><span class="p">(</span><span class="n">count_a</span><span class="p">,</span> <span class="n">count_b</span><span class="p">,</span> <span class="n">count_ab</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A function that will just compute log-likelihood estimate, in</span>
<span class="sd">        the original paper it&#39;s described in algorithm 6 and 7.</span>

<span class="sd">        This *should* be the original Dunning log-likelihood values,</span>
<span class="sd">        unlike the previous log_l function where it used modified</span>
<span class="sd">        Dunning log-likelihood values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">math</span>

        <span class="n">p</span> <span class="o">=</span> <span class="n">count_b</span> <span class="o">/</span> <span class="n">N</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">count_ab</span> <span class="o">/</span> <span class="n">count_a</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="p">(</span><span class="n">count_b</span> <span class="o">-</span> <span class="n">count_ab</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">count_a</span><span class="p">)</span>

        <span class="n">summand1</span> <span class="o">=</span> <span class="p">(</span><span class="n">count_ab</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span>
                    <span class="p">(</span><span class="n">count_a</span> <span class="o">-</span> <span class="n">count_ab</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">p</span><span class="p">))</span>

        <span class="n">summand2</span> <span class="o">=</span> <span class="p">((</span><span class="n">count_b</span> <span class="o">-</span> <span class="n">count_ab</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span>
                    <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">count_a</span> <span class="o">-</span> <span class="n">count_b</span> <span class="o">+</span> <span class="n">count_ab</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">p</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">count_a</span> <span class="o">==</span> <span class="n">count_ab</span><span class="p">:</span>
            <span class="n">summand3</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">summand3</span> <span class="o">=</span> <span class="p">(</span><span class="n">count_ab</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span> <span class="o">+</span>
                        <span class="p">(</span><span class="n">count_a</span> <span class="o">-</span> <span class="n">count_ab</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">p1</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">count_b</span> <span class="o">==</span> <span class="n">count_ab</span><span class="p">:</span>
            <span class="n">summand4</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">summand4</span> <span class="o">=</span> <span class="p">((</span><span class="n">count_b</span> <span class="o">-</span> <span class="n">count_ab</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span> <span class="o">+</span>
                        <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">count_a</span> <span class="o">-</span> <span class="n">count_b</span> <span class="o">+</span> <span class="n">count_ab</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">p2</span><span class="p">))</span>

        <span class="n">likelihood</span> <span class="o">=</span> <span class="n">summand1</span> <span class="o">+</span> <span class="n">summand2</span> <span class="o">-</span> <span class="n">summand3</span> <span class="o">-</span> <span class="n">summand4</span>

        <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">likelihood</span><span class="p">)</span>

    <span class="c1">#////////////////////////////////////////////////////////////</span>
    <span class="c1">#{ Collocation Finder</span>
    <span class="c1">#////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">_is_potential_collocation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aug_tok1</span><span class="p">,</span> <span class="n">aug_tok2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if the pair of tokens may form a collocation given</span>
<span class="sd">        log-likelihood statistics.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">INCLUDE_ALL_COLLOCS</span> <span class="ow">or</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">INCLUDE_ABBREV_COLLOCS</span> <span class="ow">and</span> <span class="n">aug_tok1</span><span class="o">.</span><span class="n">abbr</span><span class="p">)</span> <span class="ow">or</span>
                <span class="p">(</span><span class="n">aug_tok1</span><span class="o">.</span><span class="n">sentbreak</span> <span class="ow">and</span>
                    <span class="p">(</span><span class="n">aug_tok1</span><span class="o">.</span><span class="n">is_number</span> <span class="ow">or</span> <span class="n">aug_tok1</span><span class="o">.</span><span class="n">is_initial</span><span class="p">)))</span>
                <span class="ow">and</span> <span class="n">aug_tok1</span><span class="o">.</span><span class="n">is_non_punct</span>
                <span class="ow">and</span> <span class="n">aug_tok2</span><span class="o">.</span><span class="n">is_non_punct</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_find_collocations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates likely collocations and their log-likelihood.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">types</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_collocation_fdist</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">typ1</span><span class="p">,</span> <span class="n">typ2</span> <span class="o">=</span> <span class="n">types</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="c1"># types may be None after calling freq_threshold()</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">typ2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">sent_starters</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">col_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_collocation_fdist</span><span class="p">[</span><span class="n">types</span><span class="p">]</span>
            <span class="n">typ1_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="p">[</span><span class="n">typ1</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="p">[</span><span class="n">typ1</span><span class="o">+</span><span class="s1">&#39;.&#39;</span><span class="p">]</span>
            <span class="n">typ2_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="p">[</span><span class="n">typ2</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="p">[</span><span class="n">typ2</span><span class="o">+</span><span class="s1">&#39;.&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">typ1_count</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">typ2_count</span> <span class="o">&gt;</span> <span class="mi">1</span>
                    <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">MIN_COLLOC_FREQ</span> <span class="o">&lt;</span>
                        <span class="n">col_count</span> <span class="o">&lt;=</span> <span class="nb">min</span><span class="p">(</span><span class="n">typ1_count</span><span class="p">,</span> <span class="n">typ2_count</span><span class="p">)):</span>

                <span class="n">ll</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_col_log_likelihood</span><span class="p">(</span><span class="n">typ1_count</span><span class="p">,</span> <span class="n">typ2_count</span><span class="p">,</span>
                                              <span class="n">col_count</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="o">.</span><span class="n">N</span><span class="p">())</span>
                <span class="c1"># Filter out the not-so-collocative</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ll</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">COLLOCATION</span> <span class="ow">and</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="o">.</span><span class="n">N</span><span class="p">()</span><span class="o">/</span><span class="n">typ1_count</span> <span class="o">&gt;</span>
                     <span class="n">typ2_count</span><span class="o">/</span><span class="n">col_count</span><span class="p">)):</span>
                    <span class="k">yield</span> <span class="p">(</span><span class="n">typ1</span><span class="p">,</span> <span class="n">typ2</span><span class="p">),</span> <span class="n">ll</span>

    <span class="c1">#////////////////////////////////////////////////////////////</span>
    <span class="c1">#{ Sentence-Starter Finder</span>
    <span class="c1">#////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">_is_potential_sent_starter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cur_tok</span><span class="p">,</span> <span class="n">prev_tok</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True given a token and the token that preceds it if it</span>
<span class="sd">        seems clear that the token is beginning a sentence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If a token (i) is preceded by a sentece break that is</span>
        <span class="c1"># not a potential ordinal number or initial, and (ii) is</span>
        <span class="c1"># alphabetic, then it is a a sentence-starter.</span>
        <span class="k">return</span> <span class="p">(</span> <span class="n">prev_tok</span><span class="o">.</span><span class="n">sentbreak</span> <span class="ow">and</span>
             <span class="ow">not</span> <span class="p">(</span><span class="n">prev_tok</span><span class="o">.</span><span class="n">is_number</span> <span class="ow">or</span> <span class="n">prev_tok</span><span class="o">.</span><span class="n">is_initial</span><span class="p">)</span> <span class="ow">and</span>
             <span class="n">cur_tok</span><span class="o">.</span><span class="n">is_alpha</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_find_sent_starters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Uses collocation heuristics for each candidate token to</span>
<span class="sd">        determine if it frequently starts sentences.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">typ</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sent_starter_fdist</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">typ</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">typ_at_break_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sent_starter_fdist</span><span class="p">[</span><span class="n">typ</span><span class="p">]</span>
            <span class="n">typ_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="p">[</span><span class="n">typ</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="p">[</span><span class="n">typ</span><span class="o">+</span><span class="s1">&#39;.&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">typ_count</span> <span class="o">&lt;</span> <span class="n">typ_at_break_count</span><span class="p">:</span>
                <span class="c1"># needed after freq_threshold</span>
                <span class="k">continue</span>

            <span class="n">ll</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_col_log_likelihood</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sentbreak_count</span><span class="p">,</span> <span class="n">typ_count</span><span class="p">,</span>
                                         <span class="n">typ_at_break_count</span><span class="p">,</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="o">.</span><span class="n">N</span><span class="p">())</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">ll</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SENT_STARTER</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="o">.</span><span class="n">N</span><span class="p">()</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_sentbreak_count</span> <span class="o">&gt;</span>
                <span class="n">typ_count</span><span class="o">/</span><span class="n">typ_at_break_count</span><span class="p">):</span>

                <span class="k">yield</span> <span class="n">typ</span><span class="p">,</span> <span class="n">ll</span>

    <span class="k">def</span> <span class="nf">_get_sentbreak_count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of sentence breaks marked in a given set of</span>
<span class="sd">        augmented tokens.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">aug_tok</span> <span class="ow">in</span> <span class="n">tokens</span> <span class="k">if</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">sentbreak</span><span class="p">)</span>


<span class="c1">######################################################################</span>
<span class="c1">#{ Punkt Sentence Tokenizer</span>
<span class="c1">######################################################################</span>


<div class="viewcode-block" id="PunktSentenceTokenizer"><a class="viewcode-back" href="../../../generated/generated/nltk.PunktSentenceTokenizer.html#nltk.PunktSentenceTokenizer">[docs]</a><span class="k">class</span> <span class="nc">PunktSentenceTokenizer</span><span class="p">(</span><span class="n">PunktBaseClass</span><span class="p">,</span><span class="n">TokenizerI</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A sentence tokenizer which uses an unsupervised algorithm to build</span>
<span class="sd">    a model for abbreviation words, collocations, and words that start</span>
<span class="sd">    sentences; and then uses that model to find sentence boundaries.</span>
<span class="sd">    This approach has been shown to work well for many European</span>
<span class="sd">    languages.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="PunktSentenceTokenizer.__init__"><a class="viewcode-back" href="../../../generated/generated/nltk.PunktSentenceTokenizer.__init__.html#nltk.PunktSentenceTokenizer.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_text</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
            <span class="n">lang_vars</span><span class="o">=</span><span class="n">PunktLanguageVars</span><span class="p">(),</span> <span class="n">token_cls</span><span class="o">=</span><span class="n">PunktToken</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        train_text can either be the sole training text for this sentence</span>
<span class="sd">        boundary detector, or can be a PunktParameters object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">PunktBaseClass</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lang_vars</span><span class="o">=</span><span class="n">lang_vars</span><span class="p">,</span>
                <span class="n">token_cls</span><span class="o">=</span><span class="n">token_cls</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">train_text</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">train_text</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span></div>

<div class="viewcode-block" id="PunktSentenceTokenizer.train"><a class="viewcode-back" href="../../../generated/generated/nltk.PunktSentenceTokenizer.train.html#nltk.PunktSentenceTokenizer.train">[docs]</a>    <span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_text</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Derives parameters from a given training text, or uses the parameters</span>
<span class="sd">        given. Repeated calls to this method destroy previous parameters. For</span>
<span class="sd">        incremental training, instantiate a separate PunktTrainer instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">train_text</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">train_text</span>
        <span class="k">return</span> <span class="n">PunktTrainer</span><span class="p">(</span><span class="n">train_text</span><span class="p">,</span> <span class="n">lang_vars</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_lang_vars</span><span class="p">,</span>
                <span class="n">token_cls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_Token</span><span class="p">)</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span></div>

    <span class="c1">#////////////////////////////////////////////////////////////</span>
    <span class="c1">#{ Tokenization</span>
    <span class="c1">#////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="PunktSentenceTokenizer.tokenize"><a class="viewcode-back" href="../../../generated/generated/nltk.PunktSentenceTokenizer.tokenize.html#nltk.PunktSentenceTokenizer.tokenize">[docs]</a>    <span class="k">def</span> <span class="nf">tokenize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">realign_boundaries</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a text, returns a list of the sentences in that text.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sentences_from_text</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">realign_boundaries</span><span class="p">))</span></div>

<div class="viewcode-block" id="PunktSentenceTokenizer.debug_decisions"><a class="viewcode-back" href="../../../generated/generated/nltk.PunktSentenceTokenizer.debug_decisions.html#nltk.PunktSentenceTokenizer.debug_decisions">[docs]</a>    <span class="k">def</span> <span class="nf">debug_decisions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Classifies candidate periods as sentence breaks, yielding a dict for</span>
<span class="sd">        each that may be used to understand why the decision was made.</span>

<span class="sd">        See format_debug_decision() to help make this output readable.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lang_vars</span><span class="o">.</span><span class="n">period_context_re</span><span class="p">()</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
            <span class="n">decision_text</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">()</span> <span class="o">+</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;after_tok&#39;</span><span class="p">)</span>
            <span class="n">tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tokenize_words</span><span class="p">(</span><span class="n">decision_text</span><span class="p">)</span>
            <span class="n">tokens</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_annotate_first_pass</span><span class="p">(</span><span class="n">tokens</span><span class="p">))</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">period_final</span><span class="p">:</span>
                <span class="n">tokens</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">yield</span> <span class="nb">dict</span><span class="p">(</span><span class="n">period_index</span><span class="o">=</span><span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                <span class="n">text</span><span class="o">=</span><span class="n">decision_text</span><span class="p">,</span>
                <span class="n">type1</span><span class="o">=</span><span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
                <span class="n">type2</span><span class="o">=</span><span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
                <span class="n">type1_in_abbrs</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abbr</span><span class="p">),</span>
                <span class="n">type1_is_initial</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_initial</span><span class="p">),</span>
                <span class="n">type2_is_sent_starter</span><span class="o">=</span><span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">type_no_sentperiod</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">sent_starters</span><span class="p">,</span>
                <span class="n">type2_ortho_heuristic</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_ortho_heuristic</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                <span class="n">type2_ortho_contexts</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">_debug_ortho_context</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">type_no_sentperiod</span><span class="p">)),</span>
                <span class="n">collocation</span><span class="o">=</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">type_no_sentperiod</span><span class="p">,</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">type_no_sentperiod</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">collocations</span><span class="p">,</span>

                <span class="n">reason</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_second_pass_annotation</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="ow">or</span> <span class="n">REASON_DEFAULT_DECISION</span><span class="p">,</span>
                <span class="n">break_decision</span><span class="o">=</span><span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sentbreak</span><span class="p">,</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="PunktSentenceTokenizer.span_tokenize"><a class="viewcode-back" href="../../../generated/generated/nltk.PunktSentenceTokenizer.span_tokenize.html#nltk.PunktSentenceTokenizer.span_tokenize">[docs]</a>    <span class="k">def</span> <span class="nf">span_tokenize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">realign_boundaries</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a text, returns a list of the (start, end) spans of sentences</span>
<span class="sd">        in the text.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slices_from_text</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">realign_boundaries</span><span class="p">:</span>
            <span class="n">slices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_realign_boundaries</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">slices</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[(</span><span class="n">sl</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">sl</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span> <span class="k">for</span> <span class="n">sl</span> <span class="ow">in</span> <span class="n">slices</span><span class="p">]</span></div>

<div class="viewcode-block" id="PunktSentenceTokenizer.sentences_from_text"><a class="viewcode-back" href="../../../generated/generated/nltk.PunktSentenceTokenizer.sentences_from_text.html#nltk.PunktSentenceTokenizer.sentences_from_text">[docs]</a>    <span class="k">def</span> <span class="nf">sentences_from_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">realign_boundaries</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a text, generates the sentences in that text by only</span>
<span class="sd">        testing candidate sentence breaks. If realign_boundaries is</span>
<span class="sd">        True, includes in the sentence closing punctuation that</span>
<span class="sd">        follows the period.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">text</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">e</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">span_tokenize</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">realign_boundaries</span><span class="p">)]</span></div>

    <span class="k">def</span> <span class="nf">_slices_from_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="n">last_break</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lang_vars</span><span class="o">.</span><span class="n">period_context_re</span><span class="p">()</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
            <span class="n">context</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">()</span> <span class="o">+</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;after_tok&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">text_contains_sentbreak</span><span class="p">(</span><span class="n">context</span><span class="p">):</span>
                <span class="k">yield</span> <span class="nb">slice</span><span class="p">(</span><span class="n">last_break</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;next_tok&#39;</span><span class="p">):</span>
                    <span class="c1"># next sentence starts after whitespace</span>
                    <span class="n">last_break</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="s1">&#39;next_tok&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># next sentence starts at following punctuation</span>
                    <span class="n">last_break</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
        <span class="k">yield</span> <span class="nb">slice</span><span class="p">(</span><span class="n">last_break</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_realign_boundaries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">slices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attempts to realign punctuation that falls after the period but</span>
<span class="sd">        should otherwise be included in the same sentence.</span>

<span class="sd">        For example: &quot;(Sent1.) Sent2.&quot; will otherwise be split as::</span>

<span class="sd">            [&quot;(Sent1.&quot;, &quot;) Sent1.&quot;].</span>

<span class="sd">        This method will produce::</span>

<span class="sd">            [&quot;(Sent1.)&quot;, &quot;Sent2.&quot;].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">realign</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">sl1</span><span class="p">,</span> <span class="n">sl2</span> <span class="ow">in</span> <span class="n">_pair_iter</span><span class="p">(</span><span class="n">slices</span><span class="p">):</span>
            <span class="n">sl1</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">sl1</span><span class="o">.</span><span class="n">start</span> <span class="o">+</span> <span class="n">realign</span><span class="p">,</span> <span class="n">sl1</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sl2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">text</span><span class="p">[</span><span class="n">sl1</span><span class="p">]:</span>
                    <span class="k">yield</span> <span class="n">sl1</span>
                <span class="k">continue</span>

            <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lang_vars</span><span class="o">.</span><span class="n">re_boundary_realignment</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="n">sl2</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">m</span><span class="p">:</span>
                <span class="k">yield</span> <span class="nb">slice</span><span class="p">(</span><span class="n">sl1</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">sl2</span><span class="o">.</span><span class="n">start</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()))</span>
                <span class="n">realign</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">realign</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">text</span><span class="p">[</span><span class="n">sl1</span><span class="p">]:</span>
                    <span class="k">yield</span> <span class="n">sl1</span>

<div class="viewcode-block" id="PunktSentenceTokenizer.text_contains_sentbreak"><a class="viewcode-back" href="../../../generated/generated/nltk.PunktSentenceTokenizer.text_contains_sentbreak.html#nltk.PunktSentenceTokenizer.text_contains_sentbreak">[docs]</a>    <span class="k">def</span> <span class="nf">text_contains_sentbreak</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if the given text includes a sentence break.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">found</span> <span class="o">=</span> <span class="bp">False</span> <span class="c1"># used to ignore last token</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotate_tokens</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tokenize_words</span><span class="p">(</span><span class="n">text</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">found</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">sentbreak</span><span class="p">:</span>
                <span class="n">found</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span></div>

<div class="viewcode-block" id="PunktSentenceTokenizer.sentences_from_text_legacy"><a class="viewcode-back" href="../../../generated/generated/nltk.PunktSentenceTokenizer.sentences_from_text_legacy.html#nltk.PunktSentenceTokenizer.sentences_from_text_legacy">[docs]</a>    <span class="k">def</span> <span class="nf">sentences_from_text_legacy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a text, generates the sentences in that text. Annotates all</span>
<span class="sd">        tokens, rather than just those with possible sentence breaks. Should</span>
<span class="sd">        produce the same results as ``sentences_from_text``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotate_tokens</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tokenize_words</span><span class="p">(</span><span class="n">text</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_sentence_list</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">tokens</span><span class="p">)</span></div>

<div class="viewcode-block" id="PunktSentenceTokenizer.sentences_from_tokens"><a class="viewcode-back" href="../../../generated/generated/nltk.PunktSentenceTokenizer.sentences_from_tokens.html#nltk.PunktSentenceTokenizer.sentences_from_tokens">[docs]</a>    <span class="k">def</span> <span class="nf">sentences_from_tokens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a sequence of tokens, generates lists of tokens, each list</span>
<span class="sd">        corresponding to a sentence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_annotate_tokens</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Token</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">))</span>
        <span class="n">sentence</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">aug_tok</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">:</span>
            <span class="n">sentence</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aug_tok</span><span class="o">.</span><span class="n">tok</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">sentbreak</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">sentence</span>
                <span class="n">sentence</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">sentence</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">sentence</span></div>

    <span class="k">def</span> <span class="nf">_annotate_tokens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a set of tokens augmented with markers for line-start and</span>
<span class="sd">        paragraph-start, returns an iterator through those tokens with full</span>
<span class="sd">        annotation including predicted sentence breaks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make a preliminary pass through the document, marking likely</span>
        <span class="c1"># sentence breaks, abbreviations, and ellipsis tokens.</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotate_first_pass</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>

        <span class="c1"># Make a second pass through the document, using token context</span>
        <span class="c1"># information to change our preliminary decisions about where</span>
        <span class="c1"># sentence breaks, abbreviations, and ellipsis occurs.</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotate_second_pass</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>

        <span class="c1">## [XX] TESTING</span>
        <span class="c1">#tokens = list(tokens)</span>
        <span class="c1">#self.dump(tokens)</span>

        <span class="k">return</span> <span class="n">tokens</span>

    <span class="k">def</span> <span class="nf">_build_sentence_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given the original text and the list of augmented word tokens,</span>
<span class="sd">        construct and return a tokenized list of sentence strings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Most of the work here is making sure that we put the right</span>
        <span class="c1"># pieces of whitespace back in all the right places.</span>

        <span class="c1"># Our position in the source text, used to keep track of which</span>
        <span class="c1"># whitespace to add:</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># A regular expression that finds pieces of whitespace:</span>
        <span class="n">WS_REGEXP</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">r&#39;\s*&#39;</span><span class="p">)</span>

        <span class="n">sentence</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">aug_tok</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">:</span>
            <span class="n">tok</span> <span class="o">=</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">tok</span>

            <span class="c1"># Find the whitespace before this token, and update pos.</span>
            <span class="n">ws</span> <span class="o">=</span> <span class="n">WS_REGEXP</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
            <span class="n">pos</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ws</span><span class="p">)</span>

            <span class="c1"># Some of the rules used by the punkt word tokenizer</span>
            <span class="c1"># strip whitespace out of the text, resulting in tokens</span>
            <span class="c1"># that contain whitespace in the source text.  If our</span>
            <span class="c1"># token doesn&#39;t match, see if adding whitespace helps.</span>
            <span class="c1"># If so, then use the version with whitespace.</span>
            <span class="k">if</span> <span class="n">text</span><span class="p">[</span><span class="n">pos</span><span class="p">:</span><span class="n">pos</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">tok</span><span class="p">)]</span> <span class="o">!=</span> <span class="n">tok</span><span class="p">:</span>
                <span class="n">pat</span> <span class="o">=</span> <span class="s1">&#39;\s*&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">tok</span><span class="p">)</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pat</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">text</span><span class="p">,</span><span class="n">pos</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">m</span><span class="p">:</span> <span class="n">tok</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>

            <span class="c1"># Move our position pointer to the end of the token.</span>
            <span class="k">assert</span> <span class="n">text</span><span class="p">[</span><span class="n">pos</span><span class="p">:</span><span class="n">pos</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">tok</span><span class="p">)]</span> <span class="o">==</span> <span class="n">tok</span>
            <span class="n">pos</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span>

            <span class="c1"># Add this token.  If it&#39;s not at the beginning of the</span>
            <span class="c1"># sentence, then include any whitespace that separated it</span>
            <span class="c1"># from the previous token.</span>
            <span class="k">if</span> <span class="n">sentence</span><span class="p">:</span>
                <span class="n">sentence</span> <span class="o">+=</span> <span class="n">ws</span>
            <span class="n">sentence</span> <span class="o">+=</span> <span class="n">tok</span>

            <span class="c1"># If we&#39;re at a sentence break, then start a new sentence.</span>
            <span class="k">if</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">sentbreak</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">sentence</span>
                <span class="n">sentence</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

        <span class="c1"># If the last sentence is emtpy, discard it.</span>
        <span class="k">if</span> <span class="n">sentence</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">sentence</span>

    <span class="c1"># [XX] TESTING</span>
<div class="viewcode-block" id="PunktSentenceTokenizer.dump"><a class="viewcode-back" href="../../../generated/generated/nltk.PunktSentenceTokenizer.dump.html#nltk.PunktSentenceTokenizer.dump">[docs]</a>    <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;writing to /tmp/punkt.new...&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/tmp/punkt.new&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outfile</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">aug_tok</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">parastart</span><span class="p">:</span>
                    <span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">linestart</span><span class="p">:</span>
                    <span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>

                <span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">aug_tok</span><span class="p">))</span></div>

    <span class="c1">#////////////////////////////////////////////////////////////</span>
    <span class="c1">#{ Customization Variables</span>
    <span class="c1">#////////////////////////////////////////////////////////////</span>

    <span class="n">PUNCTUATION</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="s1">&#39;;:,.!?&#39;</span><span class="p">)</span>

    <span class="c1">#////////////////////////////////////////////////////////////</span>
    <span class="c1">#{ Annotation Procedures</span>
    <span class="c1">#////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">_annotate_second_pass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs a token-based classification (section 4) over the given</span>
<span class="sd">        tokens, making use of the orthographic heuristic (4.1.1), collocation</span>
<span class="sd">        heuristic (4.1.2) and frequent sentence starter heuristic (4.1.3).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span> <span class="ow">in</span> <span class="n">_pair_iter</span><span class="p">(</span><span class="n">tokens</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_second_pass_annotation</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">t1</span>

    <span class="k">def</span> <span class="nf">_second_pass_annotation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aug_tok1</span><span class="p">,</span> <span class="n">aug_tok2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs token-based classification over a pair of contiguous tokens</span>
<span class="sd">        updating the first.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Is it the last token? We can&#39;t do anything then.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">aug_tok2</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">tok</span> <span class="o">=</span> <span class="n">aug_tok1</span><span class="o">.</span><span class="n">tok</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">aug_tok1</span><span class="o">.</span><span class="n">period_final</span><span class="p">:</span>
            <span class="c1"># We only care about words ending in periods.</span>
            <span class="k">return</span>

        <span class="n">typ</span> <span class="o">=</span> <span class="n">aug_tok1</span><span class="o">.</span><span class="n">type_no_period</span>
        <span class="n">next_tok</span> <span class="o">=</span> <span class="n">aug_tok2</span><span class="o">.</span><span class="n">tok</span>
        <span class="n">next_typ</span> <span class="o">=</span> <span class="n">aug_tok2</span><span class="o">.</span><span class="n">type_no_sentperiod</span>
        <span class="n">tok_is_initial</span> <span class="o">=</span> <span class="n">aug_tok1</span><span class="o">.</span><span class="n">is_initial</span>

        <span class="c1"># [4.1.2. Collocation Heuristic] If there&#39;s a</span>
        <span class="c1"># collocation between the word before and after the</span>
        <span class="c1"># period, then label tok as an abbreviation and NOT</span>
        <span class="c1"># a sentence break. Note that collocations with</span>
        <span class="c1"># frequent sentence starters as their second word are</span>
        <span class="c1"># excluded in training.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">typ</span><span class="p">,</span> <span class="n">next_typ</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">collocations</span><span class="p">:</span>
            <span class="n">aug_tok1</span><span class="o">.</span><span class="n">sentbreak</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">aug_tok1</span><span class="o">.</span><span class="n">abbr</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">return</span> <span class="n">REASON_KNOWN_COLLOCATION</span>

        <span class="c1"># [4.2. Token-Based Reclassification of Abbreviations] If</span>
        <span class="c1"># the token is an abbreviation or an ellipsis, then decide</span>
        <span class="c1"># whether we should *also* classify it as a sentbreak.</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">aug_tok1</span><span class="o">.</span><span class="n">abbr</span> <span class="ow">or</span> <span class="n">aug_tok1</span><span class="o">.</span><span class="n">ellipsis</span><span class="p">)</span> <span class="ow">and</span>
             <span class="p">(</span><span class="ow">not</span> <span class="n">tok_is_initial</span><span class="p">)</span> <span class="p">):</span>
            <span class="c1"># [4.1.1. Orthographic Heuristic] Check if there&#39;s</span>
            <span class="c1"># orthogrpahic evidence about whether the next word</span>
            <span class="c1"># starts a sentence or not.</span>
            <span class="n">is_sent_starter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ortho_heuristic</span><span class="p">(</span><span class="n">aug_tok2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_sent_starter</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
                <span class="n">aug_tok1</span><span class="o">.</span><span class="n">sentbreak</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">return</span> <span class="n">REASON_ABBR_WITH_ORTHOGRAPHIC_HEURISTIC</span>

            <span class="c1"># [4.1.3. Frequent Sentence Starter Heruistic] If the</span>
            <span class="c1"># next word is capitalized, and is a member of the</span>
            <span class="c1"># frequent-sentence-starters list, then label tok as a</span>
            <span class="c1"># sentence break.</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">aug_tok2</span><span class="o">.</span><span class="n">first_upper</span> <span class="ow">and</span>
                 <span class="n">next_typ</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">sent_starters</span><span class="p">):</span>
                <span class="n">aug_tok1</span><span class="o">.</span><span class="n">sentbreak</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">return</span> <span class="n">REASON_ABBR_WITH_SENTENCE_STARTER</span>

        <span class="c1"># [4.3. Token-Based Detection of Initials and Ordinals]</span>
        <span class="c1"># Check if any initials or ordinals tokens that are marked</span>
        <span class="c1"># as sentbreaks should be reclassified as abbreviations.</span>
        <span class="k">if</span> <span class="n">tok_is_initial</span> <span class="ow">or</span> <span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;##number##&#39;</span><span class="p">:</span>

            <span class="c1"># [4.1.1. Orthographic Heuristic] Check if there&#39;s</span>
            <span class="c1"># orthogrpahic evidence about whether the next word</span>
            <span class="c1"># starts a sentence or not.</span>
            <span class="n">is_sent_starter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ortho_heuristic</span><span class="p">(</span><span class="n">aug_tok2</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">is_sent_starter</span> <span class="o">==</span> <span class="bp">False</span><span class="p">:</span>
                <span class="n">aug_tok1</span><span class="o">.</span><span class="n">sentbreak</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="n">aug_tok1</span><span class="o">.</span><span class="n">abbr</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">if</span> <span class="n">tok_is_initial</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">REASON_INITIAL_WITH_ORTHOGRAPHIC_HEURISTIC</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">REASON_NUMBER_WITH_ORTHOGRAPHIC_HEURISTIC</span>

            <span class="c1"># Special heuristic for initials: if orthogrpahic</span>
            <span class="c1"># heuristc is unknown, and next word is always</span>
            <span class="c1"># capitalized, then mark as abbrev (eg: J. Bach).</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">is_sent_starter</span> <span class="o">==</span> <span class="s1">&#39;unknown&#39;</span> <span class="ow">and</span> <span class="n">tok_is_initial</span> <span class="ow">and</span>
                 <span class="n">aug_tok2</span><span class="o">.</span><span class="n">first_upper</span> <span class="ow">and</span>
                 <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">ortho_context</span><span class="p">[</span><span class="n">next_typ</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">_ORTHO_LC</span><span class="p">)</span> <span class="p">):</span>
                <span class="n">aug_tok1</span><span class="o">.</span><span class="n">sentbreak</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="n">aug_tok1</span><span class="o">.</span><span class="n">abbr</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">return</span> <span class="n">REASON_INITIAL_WITH_SPECIAL_ORTHOGRAPHIC_HEURISTIC</span>

        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_ortho_heuristic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aug_tok</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decide whether the given token is the first token in a sentence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Sentences don&#39;t start with punctuation marks:</span>
        <span class="k">if</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">tok</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">PUNCTUATION</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="n">ortho_context</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">ortho_context</span><span class="p">[</span><span class="n">aug_tok</span><span class="o">.</span><span class="n">type_no_sentperiod</span><span class="p">]</span>

        <span class="c1"># If the word is capitalized, occurs at least once with a</span>
        <span class="c1"># lower case first letter, and never occurs with an upper case</span>
        <span class="c1"># first letter sentence-internally, then it&#39;s a sentence starter.</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">first_upper</span> <span class="ow">and</span>
             <span class="p">(</span><span class="n">ortho_context</span> <span class="o">&amp;</span> <span class="n">_ORTHO_LC</span><span class="p">)</span> <span class="ow">and</span>
             <span class="ow">not</span> <span class="p">(</span><span class="n">ortho_context</span> <span class="o">&amp;</span> <span class="n">_ORTHO_MID_UC</span><span class="p">)</span> <span class="p">):</span>
            <span class="k">return</span> <span class="bp">True</span>

        <span class="c1"># If the word is lower case, and either (a) we&#39;ve seen it used</span>
        <span class="c1"># with upper case, or (b) we&#39;ve never seen it used</span>
        <span class="c1"># sentence-initially with lower case, then it&#39;s not a sentence</span>
        <span class="c1"># starter.</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">first_lower</span> <span class="ow">and</span>
             <span class="p">((</span><span class="n">ortho_context</span> <span class="o">&amp;</span> <span class="n">_ORTHO_UC</span><span class="p">)</span> <span class="ow">or</span>
              <span class="ow">not</span> <span class="p">(</span><span class="n">ortho_context</span> <span class="o">&amp;</span> <span class="n">_ORTHO_BEG_LC</span><span class="p">))</span> <span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="c1"># Otherwise, we&#39;re not sure.</span>
        <span class="k">return</span> <span class="s1">&#39;unknown&#39;</span></div>


<span class="n">DEBUG_DECISION_FMT</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;Text: </span><span class="si">%(text)r</span><span class="s1"> (at offset </span><span class="si">%(period_index)d</span><span class="s1">)</span>
<span class="s1">Sentence break? </span><span class="si">%(break_decision)s</span><span class="s1"> (</span><span class="si">%(reason)s</span><span class="s1">)</span>
<span class="s1">Collocation? </span><span class="si">%(collocation)s</span><span class="s1"></span>
<span class="si">%(type1)r</span><span class="s1">:</span>
<span class="s1">    known abbreviation: </span><span class="si">%(type1_in_abbrs)s</span><span class="s1"></span>
<span class="s1">    is initial: </span><span class="si">%(type1_is_initial)s</span><span class="s1"></span>
<span class="si">%(type2)r</span><span class="s1">:</span>
<span class="s1">    known sentence starter: </span><span class="si">%(type2_is_sent_starter)s</span><span class="s1"></span>
<span class="s1">    orthographic heuristic suggests is a sentence starter? </span><span class="si">%(type2_ortho_heuristic)s</span><span class="s1"></span>
<span class="s1">    orthographic contexts in training: </span><span class="si">%(type2_ortho_contexts)s</span><span class="s1"></span>
<span class="s1">&#39;&#39;&#39;</span>
<span class="k">def</span> <span class="nf">format_debug_decision</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">DEBUG_DECISION_FMT</span> <span class="o">%</span> <span class="n">d</span>

<span class="k">def</span> <span class="nf">demo</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">tok_cls</span><span class="o">=</span><span class="n">PunktSentenceTokenizer</span><span class="p">,</span> <span class="n">train_cls</span><span class="o">=</span><span class="n">PunktTrainer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Builds a punkt model and applies it to the same text&quot;&quot;&quot;</span>
    <span class="n">cleanup</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">r&#39;(?:\r|^\s+)&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)</span>
    <span class="n">trainer</span> <span class="o">=</span> <span class="n">train_cls</span><span class="p">()</span>
    <span class="n">trainer</span><span class="o">.</span><span class="n">INCLUDE_ALL_COLLOCS</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">trainer</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="n">sbd</span> <span class="o">=</span> <span class="n">tok_cls</span><span class="p">(</span><span class="n">trainer</span><span class="o">.</span><span class="n">get_params</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">sbd</span><span class="o">.</span><span class="n">sentences_from_text</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">cleanup</span><span class="p">(</span><span class="n">l</span><span class="p">))</span>


</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../../_static/copybutton.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>